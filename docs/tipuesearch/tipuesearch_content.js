var tipuesearch = {"pages":[{"title":" KohonenF08 ","text":"KohonenF08 Fortran KohonenF08 API Documentation Goals and Motivation Scope Code of Conduct License Note Use the navigation bar at the top of the screen to browse modules, procedures, source files, etc.\nThe listings near the bottom of the page are incomplete. Fortran KohonenF08 API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Goals and Motivation Self-Organizing Maps or Kohonen Maps are powerful computational tools to cluster multivariate data using a topology preservation approach, that is, the clustering obtained by using this methodology is designed to preserve neighboring relationships between samples (closer samples in the input space remain closer in the output space). Two Level Self-Organizing Maps are important in many applied areas but currently there is not a proper implementation that suited my needs. So I decided to implement this clustering approach in Fortran using the features included in the new standard Fortran2008. This ensures computational efficiency and software extensibility, in addition to having to learn more about Fortran. Scope The goal of the KohonenF08 Library is to achieve the following general scope: Data transformation (normal and uniform standarization) Clustering using Self-Organizing Maps with one a several layers Clustering using VISOM Code of Conduct In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. License The KohonenF08 source code and related files and documentation are distributed under the MIT license . Developer Info Oscar Garcia-Cabrejo Faculty @ UPTC Colombia","tags":"home","loc":"index.html"},{"title":"neighborhood_function_base – KohonenF08 ","text":"type, public, abstract :: neighborhood_function_base Abstract class used to derive classes that calculates the effect of the input on the \nunits of a SOM (neighborhood function) Type-Bound Procedures procedure( neighborhood_function_calculate ), public, deferred :: calculate subroutine neighborhood_function_calculate(my_neigh_fn, geometric_distance) Prototype Subroutine template to calculate function\nImport section Arguments Type Intent Optional Attributes Name class( neighborhood_function_base ) :: my_neigh_fn A neighborhood_function_base object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric or grid distance of a SOM unit Source Code type , abstract :: neighborhood_function_base !! Abstract class used to derive classes that calculates the effect of the input on the !! units of a SOM (neighborhood function) contains procedure ( neighborhood_function_calculate ), deferred :: calculate end type neighborhood_function_base","tags":"","loc":"type\\neighborhood_function_base.html"},{"title":"kohonen_map_base – KohonenF08 ","text":"type, public, abstract :: kohonen_map_base Abstract Class to represent a template for a kohonen map Inherited by type~~kohonen_map_base~~InheritedByGraph type~kohonen_map_base kohonen_map_base type~self_organizing_map self_organizing_map type~self_organizing_map->type~kohonen_map_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( kohonen_map_constructor ), public, deferred :: create subroutine kohonen_map_constructor(kohonen_map, training_parameters) Prototype Template function for the constructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object procedure( kohonen_map_destructor ), public, deferred :: destroy subroutine kohonen_map_destructor(kohonen_map) Prototype Template function for the destructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object procedure( kohonen_map_function1 ), public, deferred :: train subroutine kohonen_map_function1(kohonen_map, input_data) Prototype Template function for the training function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects procedure( kohonen_map_function2 ), public, deferred :: predict subroutine kohonen_map_function2(kohonen_map, input_data, map_output) Prototype Template function for the prediction function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects integer, intent(out), dimension(:,:) :: map_output An integer array Source Code type , abstract :: kohonen_map_base !! Abstract Class to represent a template for a kohonen map contains procedure ( kohonen_map_constructor ), public , deferred :: create procedure ( kohonen_map_destructor ), public , deferred :: destroy procedure ( kohonen_map_function1 ), public , deferred :: train procedure ( kohonen_map_function2 ), public , deferred :: predict end type kohonen_map_base","tags":"","loc":"type\\kohonen_map_base.html"},{"title":"kohonen_prototype – KohonenF08 ","text":"type, public :: kohonen_prototype Class to store a prototype inside a Kohonen map Inherited by type~~kohonen_prototype~~InheritedByGraph type~kohonen_prototype kohonen_prototype type~kohonen_pattern kohonen_pattern type~kohonen_pattern->type~kohonen_prototype pattern type~self_organizing_map self_organizing_map type~self_organizing_map->type~kohonen_prototype grid Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => kohonen_prototype_constructor private  subroutine kohonen_prototype_constructor(prototype, input_data) Class Constructor Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object real(kind=wp), dimension(:,:) :: input_data A real array procedure, public :: destroy => kohonen_prototype_destructor private  subroutine kohonen_prototype_destructor(prototype) Class Destructor Arguments Type Intent Optional Attributes Name class( kohonen_prototype ), intent(inout) :: prototype A kohonen_prototype object procedure, public :: get_prototype => kohonen_prototype_accessor private  subroutine kohonen_prototype_accessor(prototype, d) Acccessor Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object real(kind=wp), dimension(prototype%number_rows,prototype%number_columns) :: d A real variable with the value of the prototype procedure, public :: set_prototype => kohonen_prototype_mutator private  subroutine kohonen_prototype_mutator(prototype, new_data) Mutator Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object real(kind=wp), intent(inout), dimension(:,:) :: new_data procedure, public :: print => kohonen_prototype_print private  subroutine kohonen_prototype_print(prototype, unit_) Function to print a kohonen prototype Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit procedure, public :: distance => kohonen_prototype_distance private  function kohonen_prototype_distance(prototype, prototype1, f) result(d) Function to calculate the distance between two prototypes Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object type( kohonen_prototype ) :: prototype1 A kohonen_prototype object class( distance_base ), allocatable :: f Return Value real(kind=wp) A real variable with the distance between prototypes procedure, public :: get_nrow => kohonen_prototype_nrow private  function kohonen_prototype_nrow(prototype) result(nr) Function to get the number of rows of the prototype Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object Return Value integer Integer variable with the number of rows procedure, public :: get_ncol => kohonen_prototype_ncol private  function kohonen_prototype_ncol(prototype) result(nc) Function to get the number of columns of the prototype Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object Return Value integer Integer variable with the number of columns Source Code type kohonen_prototype !!   Class to store a prototype inside a Kohonen map private real ( kind = wp ), allocatable :: data_ (:,:) integer :: number_rows , number_columns contains ! procedure :: create => kohonen_prototype_constructor procedure :: destroy => kohonen_prototype_destructor procedure :: get_prototype => kohonen_prototype_accessor procedure :: set_prototype => kohonen_prototype_mutator procedure :: print => kohonen_prototype_print procedure :: distance => kohonen_prototype_distance procedure :: get_nrow => kohonen_prototype_nrow procedure :: get_ncol => kohonen_prototype_ncol ! end type kohonen_prototype","tags":"","loc":"type\\kohonen_prototype.html"},{"title":"random_number_generator – KohonenF08 ","text":"type, public :: random_number_generator The random_number_generator class is used to encapsulate a generator or random numbers\nAn object of this class is defined through the specification of the random seed or seeds Type-Bound Procedures generic, public :: create => create_random_number_grator_single, create_random_number_grator_array private  subroutine create_random_number_grator_single(grator, iseed) Class Constructor 1 Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object to be defined integer(kind=i64) :: iseed An integer value with the seed of the random_number_generator program main\n       use random_number_generator_utilities;\n       ...\n       integer :: iseed\n       type(random_number_generator) :: my_grator\n       ...\n       iseed=12345;\n       call my_grator%create(iseed);\n       ...\n   end program main private  subroutine create_random_number_grator_array(grator, iseed) Class Destructor 2 Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object to be defined integer(kind=i64), intent(inout), dimension(:) :: iseed An integer array with the seeds of the random_number_generator program main\n       use random_number_generator_utilities;\n       ...\n       integer :: i\n       integer,dimension(5) :: iseed\n       type(random_number_generator) :: my_grator\n       ...\n       do i=1,5\n           iseed(i)=12345+i;\n       enddo\n       call my_grator%create(iseed);\n       ...\n   end program main procedure, public :: destroy => destroy_random_number_grator private  subroutine destroy_random_number_grator(grator) Class Destructor Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object to be destroyed program main\n       use random_number_generator_utilities;\n       ...\n       integer :: iseed\n       type(random_number_generator) :: my_grator\n       ...\n       iseed=12345;\n       call my_grator%create(iseed);\n       ...\n       call my_grator%destroy();\n       ...\n   end program main procedure, public :: generate private  function generate(grator) result(rn) Function used to generate random numbers Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object Return Value real(kind=wp) A real value with the random number generated program main\n       use random_number_generator_utilities;\n       ...\n       integer :: iseed\n       real(wp) :: rnum\n       type(random_number_generator) :: my_grator\n       ...\n       iseed=12345;\n       call my_grator%create(iseed);\n       rnum=my_grator%generate();\n       write( , ) 'Random number= ',rnum;\n       ...\n   end program main Source Code type random_number_generator private !! The random_number_generator class is used to encapsulate a generator or random numbers !! An object of this class is defined through the specification of the random seed or seeds integer ( i64 ) :: seed integer ( i64 ), allocatable :: seed_array (:) contains procedure , private :: create_random_number_grator_single procedure , private :: create_random_number_grator_array generic , public :: create => create_random_number_grator_single , create_random_number_grator_array procedure , public :: destroy => destroy_random_number_grator procedure , public :: generate end type random_number_generator","tags":"","loc":"type\\random_number_generator.html"},{"title":"factory_distance – KohonenF08 ","text":"type, public :: factory_distance Class to represent a distance factory Inherited by type~~factory_distance~~InheritedByGraph type~factory_distance factory_distance type~self_organizing_map self_organizing_map type~self_organizing_map->type~factory_distance factory Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create_distance public  subroutine create_distance (factory, type_, dist) Class constructor Arguments Type Intent Optional Attributes Name class( factory_distance ) :: factory A factory_distance object character(len=*) :: type_ A character string with the type of distance to be instantiated class( distance_base ), allocatable :: dist An allocatable distance_base object Source Code type factory_distance !!  Class to represent a distance factory contains procedure , public :: create_distance end type factory_distance","tags":"","loc":"type\\factory_distance.html"},{"title":"distance_base – KohonenF08 ","text":"type, public, abstract :: distance_base Abstract class distance_base Inherited by type~~distance_base~~InheritedByGraph type~distance_base distance_base type~euclidean_distance euclidean_distance type~euclidean_distance->type~distance_base type~manhattan_distance manhattan_distance type~manhattan_distance->type~distance_base type~self_organizing_map self_organizing_map type~self_organizing_map->type~distance_base distance_function Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( distance_function1 ), public, deferred :: calculate function distance_function1(distance, vector1, vector2) result(d) Prototype Template for the calculate function\nImport section Arguments Type Intent Optional Attributes Name class( distance_base ) :: distance A distance_base object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Source Code type , abstract :: distance_base !! Abstract class `distance_base` contains procedure ( distance_function1 ), deferred :: calculate end type distance_base","tags":"","loc":"type\\distance_base.html"},{"title":"logger – KohonenF08 ","text":"type, public :: logger The Logger class is used to store all the variables related to the units of \nfiles used to store or print messages during the development (debugging ) or \nrunning Type-Bound Procedures procedure, public :: create => create_logger private  subroutine create_logger(current_log) logger constructor Arguments Type Intent Optional Attributes Name class( logger ) :: current_log a logger object procedure, public :: destroy => destroy_logger private  subroutine destroy_logger(current_log) Logger destructor Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object procedure, public :: startup private  subroutine startup(current_log, log_file, append_) Subroutine to initialize a logger object Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*) :: log_file A character variable with the name of the file associated to the logger logical, intent(in), optional :: append_ A logical (optional) variable to indicate if appending to an existing file \n         is desired procedure, public :: shutdown private  subroutine shutdown(current_log) Subroutine to turn-off the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object procedure, public :: is_initialized private  function is_initialized(current_log) result(initialized) Function to check if a logger is initialized Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object Return Value logical A logical variable procedure, public :: message private  subroutine message(current_log, msg) Subroutine to send a message to the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*) :: msg A character variable with the message to send to the logger procedure, public :: write private  subroutine write(current_log, unit_, msg) Subroutine to write a message in a file associated with the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object integer, intent(in) :: unit_ An integer variable with the value of the output unit character(len=*) :: msg A character variable with the message to be written in the output unit generic, public :: configure => configure_logical, configure_integer, configure_character private  subroutine configure_logical(current_log, option, value) Subroutine to define the logger state Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: option A character variable with the name of the state to be defined logical, intent(in) :: value A logical variable private  subroutine configure_integer(current_log, option, value) Subroutine to define a logger integer state Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: option A character variable with the name of the state to be defined integer, intent(in) :: value An integer variable private  subroutine configure_character(current_log, option, value) Subroutine to define a logger character state Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: option A character variable with the name of the state to be defined character(len=*), intent(in) :: value A character variable procedure, public :: get_unit private  function get_unit(current_log) result(logger_unit) Function to get the logger unit Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object Return Value integer An integer variable with the logger unit procedure, public :: delimiter private  subroutine delimiter(current_log, level) Subroutine that defines the delimiter in a logger repport Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), optional :: level A character variable with the definition of the delimiter procedure, public :: get_delimiter private  subroutine get_delimiter(current_log, level, msg) Subroutine to get the delimiter text Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*) :: level A character variable character(len=100) :: msg A character variable procedure, public :: reset private  subroutine reset(current_log) Subroutine to reset the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object procedure, public :: error private  subroutine error(current_log, message) Subroutine to print an error message Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: message A character varaible with the error message Source Code type logger private !! The Logger class is used to store all the variables related to the units of !! files used to store or print messages during the development (debugging ) or !! running integer :: fileunit , stdout logical :: activate_screen , activate_file , timestamp logical :: initialized , stoponerror character ( len = NUMCHAR ) :: level_string_volume , level_string_chapter , level_string_section character ( len = NUMCHAR ) :: level_string_subsection contains procedure , public :: create => create_logger procedure , public :: destroy => destroy_logger procedure , public :: startup procedure , public :: shutdown procedure , public :: is_initialized procedure , public :: message procedure , public :: write procedure , private :: get_available_unit procedure , private :: configure_logical procedure , private :: configure_integer procedure , private :: configure_character generic , public :: configure => configure_logical , configure_integer , configure_character !        generic,public :: get procedure , public :: get_unit procedure , public :: delimiter procedure , public :: get_delimiter procedure , public :: reset procedure , public :: error end type logger","tags":"","loc":"type\\logger.html"},{"title":"rkiss05_generator – KohonenF08 ","text":"type, public, extends( random_generator_base ) :: rkiss05_generator Class to represent a random number generator that implements the rkiss method Inherits type~~rkiss05_generator~~InheritsGraph type~rkiss05_generator rkiss05_generator type~random_generator_base random_generator_base type~rkiss05_generator->type~random_generator_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~rkiss05_generator~~InheritedByGraph type~rkiss05_generator rkiss05_generator type~self_organizing_map self_organizing_map type~self_organizing_map->type~rkiss05_generator rnumber_grator Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_rkiss05_generator private  subroutine create_rkiss05_generator(generator, iseed) Constructor of the rkiss05_generator class. In this class random seed is assigned to the \nrandom number generator and the internal state of the corresponding generator  is \ninitialized. Arguments Type Intent Optional Attributes Name class( rkiss05_generator ) :: generator generator: A rkiss05_generator object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random number generator procedure, public :: destroy => destroy_rkiss05_generator private  subroutine destroy_rkiss05_generator(generator) Destructor of the rkiss05_generator class. In this class, the random seed is set to 0 Arguments Type Intent Optional Attributes Name class( rkiss05_generator ) :: generator generator: A rkiss05_generator object procedure, public :: generate => generate_rkiss05_generator private  function generate_rkiss05_generator(generator) result(r) Function used to generate realizations of the random numbers with the rkiss05_generator class. Arguments Type Intent Optional Attributes Name class( rkiss05_generator ) :: generator generator: A rkiss05_generator object Return Value real(kind=wp) r: A real variable with the generated random number Source Code type , extends ( random_generator_base ) :: rkiss05_generator private !! Class to represent a random number generator that implements the rkiss method integer :: seed integer :: x , y , w , z contains !  * constructor procedure , public :: create => create_rkiss05_generator !  * destructor procedure , public :: destroy => destroy_rkiss05_generator !  * generate procedure , public :: generate => generate_rkiss05_generator ! end type rkiss05_generator","tags":"","loc":"type\\rkiss05_generator.html"},{"title":"quicksort – KohonenF08 ","text":"type, public, extends( sort_base ) :: quicksort class that encapsulates the quicksort algorithm Inherits type~~quicksort~~InheritsGraph type~quicksort quicksort type~sort_base sort_base type~quicksort->type~sort_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass :: sort => quick_sort private recursive subroutine quick_sort(my_sort, list, order) main subroutine of the quick sort algorithm. Arguments Type Intent Optional Attributes Name class( quicksort ), intent(inout) :: my_sort A quicksort object real(kind=wp), intent(inout), dimension (:) :: list A real vector with the values to be sorted. integer, intent(inout), dimension (:) :: order An integer vector with the positions of the ordered samples.\nquick sort routine from:\nbrainerd, w.s., goldberg, c.h. & adams, j.c. (1990) \"programmer's guide to\nfortran 90\", mcgraw-hill  isbn 0-07-000248-7, pages 149-150.\nmodified by alan miller to include an associated integer array which gives\nthe positions of the elements in the original order. Source Code type , extends ( sort_base ) :: quicksort !!  class that encapsulates the quicksort algorithm contains procedure , pass :: sort => quick_sort end type quicksort","tags":"","loc":"type\\quicksort.html"},{"title":"sort_base – KohonenF08 ","text":"type, public, abstract :: sort_base Abstract class to represent a generic sort algoritm Inherited by type~~sort_base~~InheritedByGraph type~sort_base sort_base type~quicksort quicksort type~quicksort->type~sort_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( sort_procedure ), public, deferred, pass :: sort subroutine sort_procedure(my_sort, list, order) Prototype Subroutine to sort an array\nimport sort_base Arguments Type Intent Optional Attributes Name class( sort_base ), intent(inout) :: my_sort my_sort: A sort_base object real(kind=wp), intent(inout), dimension(:) :: list list: A real vector integer, intent(inout), dimension(:) :: order order: An integer vector Source Code type , abstract :: sort_base !! Abstract class to represent a generic sort algoritm contains ! METHODS !   * sort procedure ( sort_procedure ), deferred , pass :: sort end type sort_base","tags":"","loc":"type\\sort_base.html"},{"title":"kohonen_layer_parameters – KohonenF08 ","text":"type, public :: kohonen_layer_parameters Inherited by type~~kohonen_layer_parameters~~InheritedByGraph type~kohonen_layer_parameters kohonen_layer_parameters type~self_organizing_map self_organizing_map type~self_organizing_map->type~kohonen_layer_parameters parameters Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: train_option integer, public :: number_nodes_nx integer, public :: number_nodes_ny integer, public :: number_nodes_nz integer, public :: number_patterns integer, public :: number_variables1 integer, public :: number_variables2 integer, public :: number_variables integer, public, allocatable :: column_var (:) integer, public :: number_epochs integer, public :: debug_level integer, public, dimension(1) :: random_seed_ real(kind=wp), public :: learning_rate character(len=NUMCHAR), public :: node_type character(len=NUMCHAR), public :: debug_file character(len=NUMCHAR), public :: pattern_file character(len=NUMCHAR), public :: output_file character(len=NUMCHAR), public :: distance_type character(len=NUMCHAR), public :: neighborhood_type character(len=NUMCHAR), public :: som_type character(len=NUMCHAR), public :: m_estimator logical, public :: toroidal_grid integer, public :: idbg integer, public :: iout integer, public :: iindex integer, public :: iprot integer, public :: ihit integer, public :: idist integer, public :: iumat integer, public :: ipar integer, public :: isam integer, public :: iclus integer, public :: icen integer, public :: iclus1 integer, public :: idisto integer, public :: iout1 integer, public :: imeas logical, public :: view_flag integer, public :: ireal Type-Bound Procedures procedure, public :: print => print_parameters private  subroutine print_parameters(parameters, layer_ind, unit_) Arguments Type Intent Optional Attributes Name class( kohonen_layer_parameters ) :: parameters integer, intent(inout) :: layer_ind integer, intent(inout), optional :: unit_ procedure, public :: read_parameters private  subroutine read_parameters(parameters, unit_) Arguments Type Intent Optional Attributes Name class( kohonen_layer_parameters ) :: parameters integer, intent(inout), optional :: unit_ procedure, public :: read_parameters_toml private  subroutine read_parameters_toml(parameters, unit_) Arguments Type Intent Optional Attributes Name class( kohonen_layer_parameters ) :: parameters integer, intent(inout), optional :: unit_ Source Code type kohonen_layer_parameters integer :: train_option ! integer :: number_nodes_nx , number_nodes_ny , number_nodes_nz , number_patterns integer :: number_variables1 , number_variables2 , number_variables integer , allocatable :: column_var (:) integer :: number_epochs , debug_level !number_clusters, integer , dimension ( 1 ) :: random_seed_ real ( kind = wp ) :: learning_rate character ( len = NUMCHAR ) :: node_type !rectangular, hexagonal character ( len = NUMCHAR ) :: debug_file , pattern_file , output_file character ( len = NUMCHAR ) :: distance_type !euclidean, manhattan, correlation, correlation2 character ( len = NUMCHAR ) :: neighborhood_type !gaussian,bubble character ( len = NUMCHAR ) :: som_type !normal_som,visom,robust_som character ( len = NUMCHAR ) :: m_estimator !name of the M-estimator to be used logical :: toroidal_grid ! UNITS FOR TRAINING OUTPUT integer :: idbg , iout , iindex , iprot , ihit , idist , iumat , ipar , isam , iclus , icen , iclus1 , idisto ! UNITS FOR ESTIMATION OUTPUT integer :: iout1 , imeas logical :: view_flag ! FLAG FOR DEBUGGING REALIZATION integer :: ireal ! contains procedure , public :: print => print_parameters procedure , public :: read_parameters procedure , public :: read_parameters_toml !generic,public :: read => read_parameters, read_parameters_toml end type kohonen_layer_parameters","tags":"","loc":"type\\kohonen_layer_parameters.html"},{"title":"euclidean_distance – KohonenF08 ","text":"type, public, extends( distance_base ) :: euclidean_distance Class to calculate the euclidean distance Inherits type~~euclidean_distance~~InheritsGraph type~euclidean_distance euclidean_distance type~distance_base distance_base type~euclidean_distance->type~distance_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: calculate => calculate_euclidean_distance public  function calculate_euclidean_distance (distance, vector1, vector2) result(d) Function to calculate euclidean distance between vectors Arguments Type Intent Optional Attributes Name class( euclidean_distance ) :: distance A euclidean_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Source Code type , extends ( distance_base ) :: euclidean_distance !! Class to calculate the euclidean distance contains procedure , public :: calculate => calculate_euclidean_distance ! end type euclidean_distance","tags":"","loc":"type\\euclidean_distance.html"},{"title":"kohonen_pattern – KohonenF08 ","text":"type, public :: kohonen_pattern Class to represent a container for input data to  a kohonen map Inherits type~~kohonen_pattern~~InheritsGraph type~kohonen_pattern kohonen_pattern type~kohonen_prototype kohonen_prototype type~kohonen_pattern->type~kohonen_prototype pattern Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => kohonen_pattern_create public  subroutine kohonen_pattern_create (current_pattern, input, name) Kohonen pattern constructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object real(kind=wp), intent(inout), dimension(:,:) :: input A real array character(len=*), optional :: name A character string with the name of the pattern procedure, public :: destroy => kohonen_pattern_destroy public  subroutine kohonen_pattern_destroy (current_pattern) Kohonen pattern destructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object procedure, public :: get => kohonen_pattern_accessor public  subroutine kohonen_pattern_accessor (current_pattern, pattern_value) Kohonen pattern accessor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value procedure, public :: set => kohonen_pattern_mutator public  subroutine kohonen_pattern_mutator (current_pattern, pattern_value) kohonen_pattern_mutator Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value procedure, public :: print => kohonen_pattern_print public  subroutine kohonen_pattern_print (current_pattern, unit_) Subroutine to print a Kohonen pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit where the patterns will be printed procedure, public :: get_nrow => kohonen_pattern_nrow public  function kohonen_pattern_nrow (current_pattern) result(nr) Function to calculate the number of rows (samples) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of rows (samples) in a pattern procedure, public :: get_ncol => kohonen_pattern_ncol public  function kohonen_pattern_ncol (current_pattern) result(nc) Function to calculate the number of columns (variables) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of columns (variables) in a pattern Source Code type kohonen_pattern !!  Class to represent a container for input data to  a kohonen map private type ( kohonen_prototype ) :: pattern character ( len = NUMCHAR ) :: pattern_name contains procedure , public :: create => kohonen_pattern_create procedure , public :: destroy => kohonen_pattern_destroy procedure , public :: get => kohonen_pattern_accessor procedure , public :: set => kohonen_pattern_mutator procedure , public :: print => kohonen_pattern_print procedure , public :: get_nrow => kohonen_pattern_nrow procedure , public :: get_ncol => kohonen_pattern_ncol ! end type kohonen_pattern","tags":"","loc":"type\\kohonen_pattern.html"},{"title":"random_generator_base – KohonenF08 ","text":"type, public, abstract :: random_generator_base Abstract class to derive random number generator classes Inherited by type~~random_generator_base~~InheritedByGraph type~random_generator_base random_generator_base type~rkiss05_generator rkiss05_generator type~rkiss05_generator->type~random_generator_base type~self_organizing_map self_organizing_map type~self_organizing_map->type~rkiss05_generator rnumber_grator Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( random_generator_constructor ), public, deferred :: create subroutine random_generator_constructor(generator, iseed) Prototype Template of the constructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random generator. procedure( random_generator_destructor ), public, deferred :: destroy subroutine random_generator_destructor(generator) Prototype Template of the destructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object procedure( random_generator_generate ), public, deferred :: generate function random_generator_generate(generator) result(r) Prototype Template of the function used to generate realizations of the random numbers in the \nclasses derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Return Value real(kind=wp) r: A real number Source Code type , abstract :: random_generator_base !! Abstract class to derive random number generator classes contains !  * constructor procedure ( random_generator_constructor ), deferred :: create !  * destructor procedure ( random_generator_destructor ), deferred :: destroy !  * generate procedure ( random_generator_generate ), deferred :: generate !     procedure(random_generator_initialize),deferred :: initialize end type random_generator_base","tags":"","loc":"type\\random_generator_base.html"},{"title":"manhattan_distance – KohonenF08 ","text":"type, public, extends( distance_base ) :: manhattan_distance Class to calculate the Manhattan distance Inherits type~~manhattan_distance~~InheritsGraph type~manhattan_distance manhattan_distance type~distance_base distance_base type~manhattan_distance->type~distance_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: calculate => calculate_manhattan_distance private  function calculate_manhattan_distance(distance, vector1, vector2) result(d) Function to calculate the Manhattan distance between vectors\nA real variable with the distance Arguments Type Intent Optional Attributes Name class( manhattan_distance ) :: distance A Manhattan_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real vector Source Code type , extends ( distance_base ) :: manhattan_distance !! Class to calculate the Manhattan distance contains procedure , public :: calculate => calculate_manhattan_distance end type manhattan_distance","tags":"","loc":"type\\manhattan_distance.html"},{"title":"self_organizing_map – KohonenF08 ","text":"type, public, extends( kohonen_map_base ) :: self_organizing_map Class to represent a self_organizing_map Inherits type~~self_organizing_map~~InheritsGraph type~self_organizing_map self_organizing_map type~distance_base distance_base type~self_organizing_map->type~distance_base distance_function type~factory_distance factory_distance type~self_organizing_map->type~factory_distance factory type~kohonen_layer_parameters kohonen_layer_parameters type~self_organizing_map->type~kohonen_layer_parameters parameters type~kohonen_map_base kohonen_map_base type~self_organizing_map->type~kohonen_map_base type~kohonen_prototype kohonen_prototype type~self_organizing_map->type~kohonen_prototype grid type~rkiss05_generator rkiss05_generator type~self_organizing_map->type~rkiss05_generator rnumber_grator type~random_generator_base random_generator_base type~rkiss05_generator->type~random_generator_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_som public  subroutine create_som (kohonen_map, training_parameters) Constructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object procedure, public :: destroy => destroy_som public  subroutine destroy_som (kohonen_map) Destructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object procedure, public :: train => train_som_data public  subroutine train_som_data (kohonen_map, input_data) Training function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data procedure, public :: predict => predict_som public  subroutine predict_som (kohonen_map, input_data, map_output) Function for Prediction of a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data integer, intent(out), dimension(:,:) :: map_output An integer array with the map output procedure, public :: print => print_som public  subroutine print_som (kohonen_map, unit_) Print function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), optional :: unit_ procedure, public :: read => read_som public  subroutine read_som (kohonen_map, som_fl) Subroutine to read the prototypes to define a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object character(len=*) :: som_fl A character variable with the name of the file procedure, public :: get_count => get_count_som public  subroutine get_count_som (kohonen_map, count_) Function to get count matrix for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), dimension(:,:,:) :: count_ procedure, public :: query => query_som public  subroutine query_som (kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map real(kind=wp), intent(inout), dimension(:,:) :: input_pattern integer, allocatable :: sample_index (:) procedure, public :: get_prototypes public  subroutine get_prototypes (kohonen_map, prototypes) Subroutine to get SOM prototypes Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: prototypes A real array to return the values of the SOM prototypes procedure, public :: get_u_matrix => get_u_matrix_som public  subroutine get_u_matrix_som (kohonen_map, u_matrix) Subroutine to get the u_matrix from a SOM Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:,:) :: u_matrix A real array to return the u_matrix procedure, public, nopass :: external_train_map public  subroutine external_train_map (x, nvar, npat, nx, ny, nepoch, alpha, grid_type, distance_type, neigh_type, toroidal, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_som_\") Subroutine to connect the self_organizing_map module to R o C\nImport section Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real array with the input patterns integer(kind=c_int), intent(in) :: nvar Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: npat Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: nx Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: ny Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: nepoch Integer variables to indicate the number of epochs for training real(kind=c_double), intent(in) :: alpha Real value with the initial learning rate integer(kind=c_int), intent(in) :: grid_type Integer variable to indicate the type of grid integer(kind=c_int), intent(in) :: distance_type Integer variable to indicate the distance type integer(kind=c_int), intent(in) :: neigh_type Integer variable to indicate the neighborhood type integer(kind=c_int), intent(in) :: toroidal Integer variable to indicate if a toroidal grid is used real(kind=c_double), intent(out) :: prot (nx*ny,nvar) Real array for the prototypes real(kind=c_double), intent(out) :: distortion (nepoch) Real array for the distortion measure (error during training) real(kind=c_double), intent(out) :: u_matrix (2*nx-1,2*ny-1) Real array for the u_matrix real(kind=c_double), intent(out) :: coords (nx*ny,3) Real array for the grid coordinates of the SOM integer(kind=c_int), intent(out) :: number_patterns (nx,ny) Integer array with the number of hits for each neuron integer(kind=c_int), intent(out) :: node_index (npat,3) Integer array with the index node for all the neurons of the SOM procedure, public, nopass :: external_predict_map public  subroutine external_predict_map (prot, nx, ny, new_pat, npat, nvar, node_index) bind(C, name=\"predict_som_\") Subroutine to connect this module to R Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: prot (nx*ny,nvar) integer(kind=c_int), intent(in) :: nx integer(kind=c_int), intent(in) :: ny real(kind=c_double), intent(in) :: new_pat (npat,nvar) integer(kind=c_int), intent(in) :: npat integer(kind=c_int), intent(in) :: nvar integer(kind=c_int), intent(out) :: node_index (npat,3) Source Code type , extends ( kohonen_map_base ) :: self_organizing_map !!   Class to represent a self_organizing_map private character ( len = NUMCHAR ) :: class_name = 'self_organizing_map' ; type ( kohonen_prototype ), allocatable :: grid (:,:,:) integer , allocatable :: number_patterns (:,:,:), cells_index (:,:) real ( kind = wp ), allocatable :: u_matrix (:,:,:), distance (:,:) real ( kind = wp ), allocatable :: cells_distances (:,:), coordinates (:,:) type ( kohonen_layer_parameters ) :: parameters type ( factory_distance ) :: factory class ( distance_base ), allocatable :: distance_function real ( kind = wp ), allocatable :: distortion (:) type ( rkiss05_generator ) :: rnumber_grator integer :: seed integer , allocatable :: grid_pattern_index (:,:,:), list_node_grid (:,:,:,:) contains procedure , public :: create => create_som procedure , public :: destroy => destroy_som procedure , private :: create_random_sample procedure , private :: train_som_data procedure , public :: train => train_som_data procedure , public :: predict => predict_som procedure , public :: print => print_som procedure , public :: read => read_som procedure , public :: get_count => get_count_som procedure , public :: query => query_som procedure , public :: get_prototypes !procedure,public :: get_index => get_index_som procedure , public :: get_u_matrix => get_u_matrix_som procedure , private :: find_best_match_unit procedure , private :: update_weights !procedure,private :: update_weights1 procedure , private :: find_bmu_grid procedure , private :: calculate_u_matrix procedure , private :: calculate_u_matrix_hexagonal procedure , private :: calculate_u_matrix_rectangular procedure , private :: calculate_sigma procedure , nopass , private :: position2index procedure , nopass , private :: index2position procedure , nopass , private :: calculate_distance_matrix procedure , nopass , private :: calculate_coordinates procedure , private :: calculate_distance_between_prototypes procedure , nopass , public :: external_train_map procedure , nopass , public :: external_predict_map ! end type self_organizing_map","tags":"","loc":"type\\self_organizing_map.html"},{"title":"neighborhood_function_calculate – KohonenF08","text":"interface public  subroutine neighborhood_function_calculate(my_neigh_fn, geometric_distance) Arguments Type Intent Optional Attributes Name class( neighborhood_function_base ) :: my_neigh_fn A neighborhood_function_base object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric or grid distance of a SOM unit Description Subroutine template to calculate function\nImport section","tags":"","loc":"interface\\neighborhood_function_calculate.html"},{"title":"kohonen_map_constructor – KohonenF08","text":"interface public  subroutine kohonen_map_constructor(kohonen_map, training_parameters) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object Description Template function for the constructor of a kohonen map\nImport section","tags":"","loc":"interface\\kohonen_map_constructor.html"},{"title":"kohonen_map_destructor – KohonenF08","text":"interface public  subroutine kohonen_map_destructor(kohonen_map) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object Description Template function for the destructor of a kohonen map\nImport section","tags":"","loc":"interface\\kohonen_map_destructor.html"},{"title":"kohonen_map_function1 – KohonenF08","text":"interface public  subroutine kohonen_map_function1(kohonen_map, input_data) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects Description Template function for the training function of a kohonen map\nimport section","tags":"","loc":"interface\\kohonen_map_function1.html"},{"title":"kohonen_map_function2 – KohonenF08","text":"interface public  subroutine kohonen_map_function2(kohonen_map, input_data, map_output) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects integer, intent(out), dimension(:,:) :: map_output An integer array Description Template function for the prediction function of a kohonen map\nimport section","tags":"","loc":"interface\\kohonen_map_function2.html"},{"title":"distance_function1 – KohonenF08","text":"interface public  function distance_function1(distance, vector1, vector2) result(d) Arguments Type Intent Optional Attributes Name class( distance_base ) :: distance A distance_base object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Description Template for the calculate function\nImport section","tags":"","loc":"interface\\distance_function1.html"},{"title":"sort_procedure – KohonenF08","text":"interface public  subroutine sort_procedure(my_sort, list, order) Arguments Type Intent Optional Attributes Name class( sort_base ), intent(inout) :: my_sort my_sort: A sort_base object real(kind=wp), intent(inout), dimension(:) :: list list: A real vector integer, intent(inout), dimension(:) :: order order: An integer vector Description Subroutine to sort an array\nimport sort_base","tags":"","loc":"interface\\sort_procedure.html"},{"title":"random_generator_generate – KohonenF08","text":"interface public  function random_generator_generate(generator) result(r) Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Return Value real(kind=wp) r: A real number Description Template of the function used to generate realizations of the random numbers in the \nclasses derived from the random_generator class.\nrandom_generator_base","tags":"","loc":"interface\\random_generator_generate.html"},{"title":"random_generator_constructor – KohonenF08","text":"interface public  subroutine random_generator_constructor(generator, iseed) Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random generator. Description Template of the constructor of the classes derived from the random_generator class.\nrandom_generator_base","tags":"","loc":"interface\\random_generator_constructor.html"},{"title":"random_generator_destructor – KohonenF08","text":"interface public  subroutine random_generator_destructor(generator) Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Description Template of the destructor of the classes derived from the random_generator class.\nrandom_generator_base","tags":"","loc":"interface\\random_generator_destructor.html"},{"title":"create_distance – KohonenF08","text":"public  subroutine create_distance(factory, type_, dist) Class constructor Type Bound factory_distance Arguments Type Intent Optional Attributes Name class( factory_distance ) :: factory A factory_distance object character(len=*) :: type_ A character string with the type of distance to be instantiated class( distance_base ), allocatable :: dist An allocatable distance_base object Called by proc~~create_distance~~CalledByGraph proc~create_distance factory_distance%create_distance proc~create_som self_organizing_map%create_som proc~create_som->proc~create_distance proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine create_distance ( factory , type_ , dist ) !======================================================================================== !! Class constructor class ( factory_distance ) :: factory !! A `factory_distance` object character ( len =* ) :: type_ !! A character string with the type of distance to be instantiated class ( distance_base ), allocatable :: dist !! An allocatable `distance_base` object select case ( trim ( type_ )) case ( 'euclidean' ) !write(*,*) 'Euclidean distance'; if ( allocated ( dist )) deallocate ( dist ); allocate ( euclidean_distance :: dist ); case ( 'manhattan' ) !         !write(*,*) 'Manhattan distance allocated'; if ( allocated ( dist )) deallocate ( dist ); allocate ( manhattan_distance :: dist ); case default write ( * , * ) 'ERROR: the requested distance is not defined' stop end select ! end subroutine create_distance","tags":"","loc":"proc\\create_distance.html"},{"title":"initialize_variables – KohonenF08","text":"public  subroutine initialize_variables(par_file) Arguments Type Intent Optional Attributes Name character(len=*) :: par_file Calls proc~~initialize_variables~~CallsGraph proc~initialize_variables initialize_variables error_stop error_stop proc~initialize_variables->error_stop none~configure logger%configure proc~initialize_variables->none~configure none~create~4 logger%create proc~initialize_variables->none~create~4 none~delimiter logger%delimiter proc~initialize_variables->none~delimiter none~message~2 logger%message proc~initialize_variables->none~message~2 none~startup logger%startup proc~initialize_variables->none~startup none~error logger%error none~configure->none~error none~delimiter->none~message~2 none~get_delimiter logger%get_delimiter none~delimiter->none~get_delimiter none~startup->none~error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: idata integer, public :: ipattern integer, public :: ivar integer, public :: ierr integer, public :: number_variables integer, public :: i integer, public :: j integer, public :: ipar integer, public :: toroidal integer, public :: layer_ind integer, public :: ferr real(kind=wp), public, allocatable :: var (:,:) logical, public :: testfl logical, public :: testop character(len=NUMCHAR), public :: current_line character(len=NUMCHAR), public :: current_file character(len=NUMCHAR), public, allocatable :: pattern_files (:) character(len=NUMCHAR), public :: base_message character(len=NUMCHAR), public :: message Source Code subroutine initialize_variables ( par_file ) !============================================================================== character ( len =* ) :: par_file ! integer :: idata , ipattern , ivar , ierr , number_variables , i , j , ipar , toroidal integer :: layer_ind , ferr real ( kind = wp ), allocatable :: var (:,:) logical :: testfl , testop character ( len = NUMCHAR ) :: current_line character ( len = NUMCHAR ) :: current_file !integer,allocatable :: column_var(:) character ( len = NUMCHAR ), allocatable :: pattern_files (:) character ( len = NUMCHAR ) :: base_message , message ! idata = 1 ; ipar = 2 ; base_message = \"SOM_TRAIN_VARIABLES ERROR\" ; call global_logger % create (); call global_logger % startup ( 'som_train.log' ); call global_logger % configure ( 'timestamp' ,. true .); call global_logger % delimiter ( 'volume' ); ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then message = trim ( base_message ) // \"The parameter file does not exist\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif open ( ipar , file = trim ( par_file ), status = 'unknown' , access = 'sequential' ,& action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \"while opening \" // trim ( par_file ) // \" file\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'SOM_TRAIN_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo read ( ipar , * ) som_parameters ( 1 )% train_option write ( * , * ) 'Train option= ' , som_parameters ( 1 )% train_option read ( ipar , '(A40)' ) som_parameters ( 1 )% pattern_file write ( * , * ) 'Pattern file= ' , trim ( som_parameters ( 1 )% pattern_file ) read ( ipar , * ) som_parameters ( 1 )% number_patterns ; write ( * , * ) 'Number patterns= ' , som_parameters ( 1 )% number_patterns ; read ( ipar , * ) som_parameters ( 1 )% number_variables1 som_parameters ( 1 )% number_variables2 = 1 ; number_variables = som_parameters ( 1 )% number_variables1 * & som_parameters ( 1 )% number_variables2 ; som_parameters ( 1 )% number_variables = number_variables ; write ( * , * ) 'nvar= ' , som_parameters ( 1 )% number_variables ; allocate ( var ( som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for var array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif allocate ( som_parameters ( 1 )% column_var ( number_variables ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for column_var array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif if ( som_parameters ( 1 )% train_option . eq . 0 ) then if ( number_variables . le . 10 ) then read ( ipar , * ) ( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); write ( * , * ) 'columns= ' ,( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); else read ( ipar , * ) write ( * , * ) 'Columns read' do ivar = 1 , number_variables som_parameters ( 1 )% column_var ( ivar ) = ivar ; enddo write ( * , * ) som_parameters ( 1 )% column_var ( 1 : number_variables ); endif else read ( ipar , * ) endif read ( ipar , '(A40)' ) som_parameters ( 1 )% som_type write ( * , * ) 'SOM type= ' , trim ( som_parameters ( 1 )% som_type ); read ( ipar , * ) som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz read ( ipar , * ) som_parameters ( 1 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 1 )% number_epochs read ( ipar , * ) som_parameters ( 1 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 1 )% learning_rate read ( ipar , * ) som_parameters ( 1 )% random_seed_ write ( * , * ) 'random seed= ' , som_parameters ( 1 )% random_seed_ read ( ipar , '(A40)' ) som_parameters ( 1 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 1 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 1 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 1 )% neighborhood_type ) read ( ipar , * ) som_parameters ( 1 )% debug_level write ( * , * ) 'debug level= ' , som_parameters ( 1 )% debug_level read ( ipar , '(A40)' ) som_parameters ( 1 )% debug_file write ( * , * ) 'debug file= ' , trim ( som_parameters ( 1 )% debug_file ); read ( ipar , '(A40)' ) som_parameters ( 1 )% output_file write ( * , * ) 'output file base= ' , trim ( som_parameters ( 1 )% output_file ) read ( ipar , * ) toroidal write ( * , * ) 'Toroidal grid= ' , toroidal if ( toroidal . eq . 1 ) then som_parameters ( 1 )% toroidal_grid = . true .; else som_parameters ( 1 )% toroidal_grid = . false .; endif write ( * , * ) 'Reading parameter file...finished' close ( ipar ) ! inquire ( file = trim ( som_parameters ( 1 )% pattern_file ), exist = testfl ) if (. not . testfl ) then message = trim ( base_message ) // 'the file ' // trim ( som_parameters ( 1 )% pattern_file ) // ' does not exist' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif ! som_parameters ( 1 )% idbg = 10 ; !debugging som_parameters ( 1 )% iout = 11 ; !output som_parameters ( 1 )% iindex = 12 ; !SOM output by index som_parameters ( 1 )% iprot = 13 ; !SOM prototpyes som_parameters ( 1 )% ihit = 14 ; !SOM neuron_hit som_parameters ( 1 )% idist = 15 ; !neuron_distances som_parameters ( 1 )% iumat = 16 ; ! umatrix som_parameters ( 1 )% ipar = 17 ; som_parameters ( 1 )% isam = 18 ; ! som_parameters ( 1 )% idisto = 19 ; !save distortion ! !   call random_seed ! allocate ( input_patterns ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for input_patterns array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif if ( som_parameters ( 1 )% train_option . eq . 0 ) then ! write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // \" file\" ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' elseif ( som_parameters ( 1 )% train_option . eq . 1 ) then allocate ( pattern_files ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for pattern_files array\" ; call error_stop ( message ); endif write ( * , * ) 'Reading pattern files...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // \" file\" ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , '(A)' , err = 90 ) pattern_files ( ipattern ); enddo !ipattern write ( * , * ) 'Reading pattern files...finished!' ; ! write ( * , * ) 'Reading patterns...' ; do ipattern = 1 , som_parameters ( 1 )% number_patterns inquire ( file = trim ( pattern_files ( ipattern )), exist = testfl ); if (. not . testfl ) then message = trim ( base_message ) // \"the file \" // trim ( pattern_files ( ipattern )) // ' does not exist' ; call error_stop ( message ); endif write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )); open ( idata , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' ,& access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( pattern_files ( ipattern )) // ' file' ; call error_stop ( message ); endif do i = 1 , size ( var , 1 ) read ( idata , * , err = 91 ) ( var ( i , j ), j = 1 , size ( var , 2 )); enddo !ix close ( idata ); write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )), ' finished' ; call input_patterns ( ipattern )% create ( var ); enddo !ipattern write ( * , * ) 'Reading patterns...finished!' ; ! elseif ( som_parameters ( 1 )% train_option . eq . 2 ) then write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // ' file' ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' ! write ( * , * ) 'Reading distance matrix....' ; allocate ( distance_matrix ( som_parameters ( 1 )% number_patterns , som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for distance_matrix array\" ; call error_stop ( message ); endif open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // ' file' ; call error_stop ( message ); endif do i = 1 , som_parameters ( 1 )% number_patterns read ( idata , * ) ( distance_matrix ( i , j ), j = 1 , som_parameters ( 1 )% number_patterns ); enddo write ( * , * ) 'Reading distance matrix....finished!' ; endif ! if ( som_parameters ( 1 )% debug_level . gt . 0 ) then open ( som_parameters ( 1 )% idbg , file = trim ( som_parameters ( 1 )% debug_file ),& status = 'unknown' , access = 'sequential' , action = 'write' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% debug_file ) // ' file' ; call error_stop ( message ); endif endif ! if ( som_parameters ( 1 )% train_option < 3 ) then write ( * , * ) 'Opening output files...' ; ! parameter file current_file = trim ( som_parameters ( 1 )% output_file ) // '_parameters.som' ; open ( som_parameters ( 1 )% ipar , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_parameter.som file' ; call error_stop ( message ); endif layer_ind = 1 ; call som_parameters ( 1 )% print ( layer_ind , som_parameters ( 1 )% ipar ); close ( som_parameters ( 1 )% ipar ) ! neuron indices current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out' ; open ( som_parameters ( 1 )% iindex , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out file' ; call error_stop ( message ); endif !   write(som_parameters(1)%iindex,'(A)') 'KOHONEN MAP PATTERN INDICES' !   write(som_parameters(1)%iindex,'(A17,1X,2I6)') 'Number Patterns= ',& !         som_parameters(1)%number_patterns,3; write ( som_parameters ( 1 )% iindex , '(A22)' ) 'PatternNumber ix iy iz' ! neuron prototypes current_file = trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out' ; open ( som_parameters ( 1 )% iprot , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% iprot , '(A)' ) 'KOHONEN MAP PROTOTYPES' write ( som_parameters ( 1 )% iprot , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( som_parameters ( 1 )% iprot , '(A21,1X,2I6)' ) 'number of variables= ' ,& som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 !rectangular !hexagonal write ( som_parameters ( 1 )% iprot , '(A25,1X,A11,1X,L4)' ) 'node_type,toroidal_grid= ' ,& trim ( som_parameters ( 1 )% node_type ), som_parameters ( 1 )% toroidal_grid ! neuron hit current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_hit.out' ; open ( som_parameters ( 1 )% ihit , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_hits.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% ihit , '(A)' ) 'KOHONEN MAP NEURON HITS' write ( som_parameters ( 1 )% ihit , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! neuron distances current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out' ; open ( som_parameters ( 1 )% idist , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% idist , '(A)' ) 'KOHONEN MAP DISTANCE MATRIX' write ( som_parameters ( 1 )% idist , '(A17,1X,2I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ! u-matrix current_file = trim ( som_parameters ( 1 )% output_file ) // '_u-matrix.out' ; open ( som_parameters ( 1 )% iumat , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_u_matrix.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% iumat , '(A)' ) 'KOHONEN MAP U-MATRIX' write ( som_parameters ( 1 )% iumat , '(A17,1X,3I6)' ) 'number of nodes= ' ,& 2 * som_parameters ( 1 )% number_nodes_nx - 1 , 2 * som_parameters ( 1 )% number_nodes_ny - 1 ,& 2 * som_parameters ( 1 )% number_nodes_nz - 1 ! map_samples current_file = trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out' ; open ( som_parameters ( 1 )% isam , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% isam , '(A)' ) 'KOHONEN MAP SAMPLE LOCATION' write ( som_parameters ( 1 )% isam , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! SOM distortion current_file = trim ( som_parameters ( 1 )% output_file ) // '_distortion.out' ; open ( som_parameters ( 1 )% idisto , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_distortion.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% idisto , '(A)' ) 'KOHONEN MAP DISTORTION' ! write ( * , * ) 'Opening output files...finished!!!' ; endif ! deallocate ( var ); return ! 90 stop 'ERROR while reading pattern file' 91 stop 'ERROR while reading pattern sample file' ! end subroutine initialize_variables","tags":"","loc":"proc\\initialize_variables.html"},{"title":"release_variables – KohonenF08","text":"public  subroutine release_variables() Arguments None Calls proc~~release_variables~~CallsGraph proc~release_variables release_variables none~shutdown logger%shutdown proc~release_variables->none~shutdown proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~release_variables->proc~kohonen_pattern_destroy none~destroy~2 kohonen_prototype%destroy proc~kohonen_pattern_destroy->none~destroy~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i logical, public :: testop Source Code subroutine release_variables () !============================================================================== integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( distance_matrix )) then deallocate ( distance_matrix ); endif ! if ( allocated ( som_parameters ( 1 )% column_var )) then deallocate ( som_parameters ( 1 )% column_var ) endif ! inquire ( unit = som_parameters ( 1 )% iindex , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iindex ); endif ! inquire ( unit = som_parameters ( 1 )% iprot , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iprot ); endif ! inquire ( unit = som_parameters ( 1 )% ihit , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% ihit ); endif ! inquire ( unit = som_parameters ( 1 )% idist , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idist ); endif ! inquire ( unit = som_parameters ( 1 )% iumat , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iumat ); endif ! inquire ( unit = som_parameters ( 1 )% isam , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% isam ); endif ! inquire ( file = trim ( som_parameters ( 1 )% debug_file ), opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idbg ); endif ! inquire ( unit = som_parameters ( 1 )% idisto , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idisto ); endif ! call global_logger % shutdown (); call global_logger % destroy (); ! end subroutine release_variables","tags":"","loc":"proc\\release_variables.html"},{"title":"genrand64_real1 – KohonenF08","text":"public  function genrand64_real1() Generates a random number on [0,1]-real-interval Arguments None Return Value real(kind=r64) Calls proc~~genrand64_real1~~CallsGraph proc~genrand64_real1 genrand64_real1 proc~init_genrand64 init_genrand64 proc~genrand64_real1->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r64 ) function genrand64_real1 () !! Generates a random number on [0,1]-real-interval implicit none genrand64_real1 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253_1 end function genrand64_real1","tags":"","loc":"proc\\genrand64_real1.html"},{"title":"genrand64_real2 – KohonenF08","text":"public  function genrand64_real2() Generates a random number on [0,1)-real-interval Arguments None Return Value real(kind=r64) Calls proc~~genrand64_real2~~CallsGraph proc~genrand64_real2 genrand64_real2 proc~init_genrand64 init_genrand64 proc~genrand64_real2->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r64 ) function genrand64_real2 () !! Generates a random number on [0,1)-real-interval implicit none genrand64_real2 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253 end function genrand64_real2","tags":"","loc":"proc\\genrand64_real2.html"},{"title":"genrand64_real3 – KohonenF08","text":"public  function genrand64_real3() Generates a random number on (0,1)-real-interval Arguments None Return Value real(kind=r64) Calls proc~~genrand64_real3~~CallsGraph proc~genrand64_real3 genrand64_real3 proc~init_genrand64 init_genrand64 proc~genrand64_real3->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r64 ) function genrand64_real3 () !! Generates a random number on (0,1)-real-interval implicit none genrand64_real3 = real ( ishft ( genrand64_int64 (), - 12 ), kind = r64 ) genrand64_real3 = ( genrand64_real3 + 0.5_r64 ) * pi252 end function genrand64_real3","tags":"","loc":"proc\\genrand64_real3.html"},{"title":"init_genrand64 – KohonenF08","text":"public  subroutine init_genrand64(seed) Initializes mt(nn) with a seed Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: seed Called by proc~~init_genrand64~~CalledByGraph proc~init_genrand64 init_genrand64 proc~genrand64_real1 genrand64_real1 proc~genrand64_real1->proc~init_genrand64 proc~genrand64_real2 genrand64_real2 proc~genrand64_real2->proc~init_genrand64 proc~genrand64_real3 genrand64_real3 proc~genrand64_real3->proc~init_genrand64 proc~init_by_array64 init_by_array64 proc~init_by_array64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_genrand64 ( seed ) !! Initializes mt(nn) with a seed implicit none integer ( i64 ), intent ( in ) :: seed integer :: i mt ( 1 ) = seed do i = 1 , nn - 1 mt ( i + 1 ) = 6364136223846793005_i64 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 )) + i end do mti = nn end subroutine init_genrand64","tags":"","loc":"proc\\init_genrand64.html"},{"title":"init_by_array64 – KohonenF08","text":"public  subroutine init_by_array64(init_key) Initializes by an array with array-length\n  init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: init_key (:) Calls proc~~init_by_array64~~CallsGraph proc~init_by_array64 init_by_array64 proc~init_genrand64 init_genrand64 proc~init_by_array64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_by_array64 ( init_key ) !! Initializes by an array with array-length !!   init_key is the array for initializing keys implicit none integer ( i64 ), intent ( in ) :: init_key (:) integer ( i64 ), parameter :: c1 = 3935559000370003845_i64 integer ( i64 ), parameter :: c2 = 2862933555777941757_i64 integer ( i64 ) :: i , j , k , kk , key_length call init_genrand64 ( 19650218_i64 ) key_length = size ( init_key ) i = 1_i64 ; j = 0_i64 k = max ( nn , key_length ) do kk = 1 , k mt ( i + 1 ) = ieor ( mt ( i + 1 ), c1 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) & + init_key ( j + 1 ) + j i = i + 1 ; j = j + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if if ( j >= key_length ) j = 0 end do do kk = 1 , nn - 1 mt ( i + 1 ) = ieor ( mt ( i + 1 ), c2 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) - i i = i + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if end do mt ( 1 ) = ishft ( 1_i64 , 63 ) ! MSB is 1; assuring non-zero initial array end subroutine init_by_array64","tags":"","loc":"proc\\init_by_array64.html"},{"title":"calculate_euclidean_distance – KohonenF08","text":"public  function calculate_euclidean_distance(distance, vector1, vector2) result(d) Function to calculate euclidean distance between vectors Type Bound euclidean_distance Arguments Type Intent Optional Attributes Name class( euclidean_distance ) :: distance A euclidean_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Source Code function calculate_euclidean_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate euclidean distance between vectors class ( euclidean_distance ) :: distance !! A `euclidean_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 !! A real vector real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector2 !! A real vector real ( kind = wp ) :: d !! A real variable with the distance d = sum (( vector1 - vector2 ) ** 2 ); ! end function calculate_euclidean_distance","tags":"","loc":"proc\\calculate_euclidean_distance.html"},{"title":"kohonen_pattern_nrow – KohonenF08","text":"public  function kohonen_pattern_nrow(current_pattern) result(nr) Function to calculate the number of rows (samples) in a pattern Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of rows (samples) in a pattern Calls proc~~kohonen_pattern_nrow~~CallsGraph proc~kohonen_pattern_nrow kohonen_pattern%kohonen_pattern_nrow none~get_nrow kohonen_prototype%get_nrow proc~kohonen_pattern_nrow->none~get_nrow Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function kohonen_pattern_nrow ( current_pattern ) result ( nr ) !======================================================================================== !! Function to calculate the number of rows (samples) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nr !! An integer with the number of rows (samples) in a pattern nr = current_pattern % pattern % get_nrow (); ! end function kohonen_pattern_nrow","tags":"","loc":"proc\\kohonen_pattern_nrow.html"},{"title":"kohonen_pattern_ncol – KohonenF08","text":"public  function kohonen_pattern_ncol(current_pattern) result(nc) Function to calculate the number of columns (variables) in a pattern Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of columns (variables) in a pattern Calls proc~~kohonen_pattern_ncol~~CallsGraph proc~kohonen_pattern_ncol kohonen_pattern%kohonen_pattern_ncol none~get_ncol kohonen_prototype%get_ncol proc~kohonen_pattern_ncol->none~get_ncol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function kohonen_pattern_ncol ( current_pattern ) result ( nc ) !======================================================================================== !! Function to calculate the number of columns (variables) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nc !! An integer with the number of columns (variables) in a pattern nc = current_pattern % pattern % get_ncol (); ! end function kohonen_pattern_ncol","tags":"","loc":"proc\\kohonen_pattern_ncol.html"},{"title":"kohonen_pattern_create – KohonenF08","text":"public  subroutine kohonen_pattern_create(current_pattern, input, name) Kohonen pattern constructor Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object real(kind=wp), intent(inout), dimension(:,:) :: input A real array character(len=*), optional :: name A character string with the name of the pattern Calls proc~~kohonen_pattern_create~~CallsGraph proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create none~create~2 kohonen_prototype%create proc~kohonen_pattern_create->none~create~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~kohonen_pattern_create~~CalledByGraph proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~kohonen_pattern_create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine kohonen_pattern_create ( current_pattern , input , name ) !======================================================================================== !!   Kohonen pattern constructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input !! A real array character ( len =* ), optional :: name !! A character string with the name of the pattern call current_pattern % pattern % create ( input ); if ( present ( name )) then current_pattern % pattern_name = trim ( name ); else current_pattern % pattern_name = \"\" ; endif ! end subroutine kohonen_pattern_create","tags":"","loc":"proc\\kohonen_pattern_create.html"},{"title":"kohonen_pattern_destroy – KohonenF08","text":"public  subroutine kohonen_pattern_destroy(current_pattern) Kohonen pattern destructor Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Calls proc~~kohonen_pattern_destroy~~CallsGraph proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy none~destroy~2 kohonen_prototype%destroy proc~kohonen_pattern_destroy->none~destroy~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~kohonen_pattern_destroy~~CalledByGraph proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~release_variables release_variables proc~release_variables->proc~kohonen_pattern_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine kohonen_pattern_destroy ( current_pattern ) !======================================================================================== !!   Kohonen pattern destructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object call current_pattern % pattern % destroy (); ! end subroutine kohonen_pattern_destroy","tags":"","loc":"proc\\kohonen_pattern_destroy.html"},{"title":"kohonen_pattern_accessor – KohonenF08","text":"public  subroutine kohonen_pattern_accessor(current_pattern, pattern_value) Kohonen pattern accessor Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value Called by proc~~kohonen_pattern_accessor~~CalledByGraph proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~find_bmu_grid self_organizing_map%find_bmu_grid proc~find_bmu_grid->proc~kohonen_pattern_accessor proc~predict_som self_organizing_map%predict_som proc~predict_som->proc~kohonen_pattern_accessor proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~kohonen_pattern_accessor proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~predict_som proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine kohonen_pattern_accessor ( current_pattern , pattern_value ) !======================================================================================== !! Kohonen pattern accessor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! pattern_value = current_pattern % pattern ; ! end subroutine kohonen_pattern_accessor","tags":"","loc":"proc\\kohonen_pattern_accessor.html"},{"title":"kohonen_pattern_mutator – KohonenF08","text":"public  subroutine kohonen_pattern_mutator(current_pattern, pattern_value) kohonen_pattern_mutator Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value Source Code subroutine kohonen_pattern_mutator ( current_pattern , pattern_value ) !======================================================================================== !!   kohonen_pattern_mutator class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! current_pattern % pattern = pattern_value ; ! end subroutine kohonen_pattern_mutator","tags":"","loc":"proc\\kohonen_pattern_mutator.html"},{"title":"kohonen_pattern_print – KohonenF08","text":"public  subroutine kohonen_pattern_print(current_pattern, unit_) Subroutine to print a Kohonen pattern Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit where the patterns will be printed Source Code subroutine kohonen_pattern_print ( current_pattern , unit_ ) !======================================================================================== !! Subroutine to print a Kohonen pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer , intent ( inout ), optional :: unit_ !! An integer variable with the number of the unit where the patterns will be printed if ( present ( unit_ )) then write ( unit_ , * ) write ( unit_ , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( unit_ , * ) call current_pattern % pattern % print ( unit_ ); else write ( * , * ) write ( * , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( * , * ) call current_pattern % pattern % print (); endif ! end subroutine kohonen_pattern_print","tags":"","loc":"proc\\kohonen_pattern_print.html"},{"title":"minimum – KohonenF08","text":"public  function minimum(a) result(mn) Function to calculate the minimum of an array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a Real array Return Value real(kind=wp) Real value with the minimum Source Code function minimum ( a ) result ( mn ) !=================================================================================================== !! Function to calculate the minimum of an array real ( kind = wp ), dimension (:) :: a !! Real array real ( kind = wp ) :: mn !! Real value with the minimum integer :: i , number_elements mn = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . lt . mn ) then mn = a ( i ) endif enddo ! end function minimum","tags":"","loc":"proc\\minimum.html"},{"title":"mean – KohonenF08","text":"public  function mean(a) result(mn) Function to calculate the mean of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real value with the calculated mean Calls proc~~mean~~CallsGraph proc~mean mean float float proc~mean->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mean~~CalledByGraph proc~mean mean proc~coefficient_of_variation coefficient_of_variation proc~coefficient_of_variation->proc~mean proc~std std proc~coefficient_of_variation->proc~std proc~variance variance proc~variance->proc~mean proc~std->proc~variance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function mean ( a ) result ( mn ) !============================================================================================= !! Function to calculate the mean of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: mn !! A real value with the calculated mean mn = sum ( a ) / float ( size ( a )); ! end function mean","tags":"","loc":"proc\\mean.html"},{"title":"variance – KohonenF08","text":"public  function variance(a) result(v) Function to calculate the variance of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated variance Calls proc~~variance~~CallsGraph proc~variance variance proc~mean mean proc~variance->proc~mean float float proc~mean->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~variance~~CalledByGraph proc~variance variance proc~std std proc~std->proc~variance proc~coefficient_of_variation coefficient_of_variation proc~coefficient_of_variation->proc~std Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function variance ( a ) result ( v ) !============================================================================================= !! Function to calculate the variance of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: v !! A real variable with the calculated variance real ( kind = wp ), dimension ( size ( a )) :: a2 ! a2 = a ** 2 ; v = mean ( a2 ) - ( mean ( a )) ** 2 ; ! end function variance","tags":"","loc":"proc\\variance.html"},{"title":"std – KohonenF08","text":"public  function std(a) result(s) Function to calculate the standard deviation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated standard deviation Calls proc~~std~~CallsGraph proc~std std proc~variance variance proc~std->proc~variance proc~mean mean proc~variance->proc~mean float float proc~mean->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~std~~CalledByGraph proc~std std proc~coefficient_of_variation coefficient_of_variation proc~coefficient_of_variation->proc~std Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function std ( a ) result ( s ) !============================================================================================= !! Function to calculate the standard deviation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: s !! A real variable with the calculated standard deviation real ( kind = wp ) :: v ! v = variance ( a ); s = sqrt ( v ); ! end function std","tags":"","loc":"proc\\std.html"},{"title":"coefficient_of_variation – KohonenF08","text":"public  function coefficient_of_variation(a) result(cov) Function to calculate the coefficient of variation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated coefficient of variation Calls proc~~coefficient_of_variation~~CallsGraph proc~coefficient_of_variation coefficient_of_variation proc~mean mean proc~coefficient_of_variation->proc~mean proc~std std proc~coefficient_of_variation->proc~std float float proc~mean->float proc~variance variance proc~std->proc~variance proc~variance->proc~mean Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function coefficient_of_variation ( a ) result ( cov ) !============================================================================================ !! Function to calculate the coefficient of variation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: cov !! A real variable with the calculated coefficient of variation cov = std ( a ) / mean ( a ); end function coefficient_of_variation","tags":"","loc":"proc\\coefficient_of_variation.html"},{"title":"maximum – KohonenF08","text":"public interface maximum Module Procedures private  subroutine maximum_only(a, mx) Subroutine to calculate the maximum of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a real(kind=wp) :: mx private  subroutine maximum_position(a, mx, p) Subroutine to find the position of the maximum value of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a A real array real(kind=wp) :: mx A real value with the maximum integer :: p An integer value with the position of the maximum","tags":"","loc":"interface\\maximum.html"},{"title":"position2index – KohonenF08","text":"public  function position2index(ix, iy, iz, nx, ny) result(index_) Function to calculate the index inside a rectangular grid from position ix,iy,iz Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix Integer variables integer, intent(in) :: iy Integer variables integer, intent(in) :: iz Integer variables integer, intent(in) :: nx Integer variables integer, intent(in) :: ny Integer variables Return Value integer Integer variable with the required index Called by proc~~position2index~~CalledByGraph proc~position2index self_organizing_map%position2index proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~calculate_distance_between_prototypes->proc~position2index proc~create_som self_organizing_map%create_som proc~create_som->proc~position2index proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~position2index proc~train_som_data self_organizing_map%train_som_data proc~external_train_map->proc~train_som_data proc~read_som self_organizing_map%read_som proc~read_som->proc~position2index proc~update_weights self_organizing_map%update_weights proc~update_weights->proc~position2index proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som_data->proc~calculate_distance_between_prototypes proc~train_som_data->proc~update_weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function position2index ( ix , iy , iz , nx , ny ) result ( index_ ) !======================================================================================== !! Function to calculate the index inside a rectangular grid from position ix,iy,iz integer , intent ( in ) :: ix , iy , iz , nx , ny !! Integer variables integer :: index_ !! Integer variable with the required index index_ = ix + ( iy - 1 ) * nx + ( iz - 1 ) * nx * ny ; ! end function position2index","tags":"","loc":"proc\\position2index.html"},{"title":"calculate_sigma – KohonenF08","text":"public  function calculate_sigma(kohonen_map, input_data, seed) result(sigma) Function to calculate the scaling factor sigma Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_data A real array with the input data integer, intent(inout), optional :: seed An integer with the random seed Return Value real(kind=wp) A real variable with the value of sigma Calls proc~~calculate_sigma~~CallsGraph proc~calculate_sigma self_organizing_map%calculate_sigma none~generate~2 rkiss05_generator%generate proc~calculate_sigma->none~generate~2 none~sort quicksort%sort proc~calculate_sigma->none~sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ndat integer, public :: nvar integer, public :: seed1 integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nxyz integer, public :: ierr integer, public :: i integer, public :: j real(kind=wp), public, allocatable :: sample_pos (:) real(kind=wp), public, allocatable :: p_vector (:,:) real(kind=wp), public, allocatable :: sigma_table (:,:) real(kind=wp), public, allocatable :: current_sigma (:) integer, public, allocatable :: sample_index (:) type( quicksort ), public :: qsort Source Code function calculate_sigma ( kohonen_map , input_data , seed ) result ( sigma ) !======================================================================================== !!    Function to calculate the scaling factor sigma class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_data !! A real array with the input data integer , intent ( inout ), optional :: seed !! An integer with the random seed real ( kind = wp ) :: sigma !! A real variable with the value of sigma integer :: ndat , nvar , seed1 , nx , ny , nz , nxyz , ierr , i , j real ( kind = wp ), allocatable :: sample_pos (:), p_vector (:,:), sigma_table (:,:) real ( kind = wp ), allocatable :: current_sigma (:) integer , allocatable :: sample_index (:) type ( quicksort ) :: qsort ! if (. not . present ( seed )) then seed1 = 12345 ; else seed1 = seed ; endif ! ndat = size ( input_data , 1 ); nvar = size ( input_data , 2 ); ! !kohonen_map%parameters=training_parameters(1); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; nxyz = nx * ny * nz ; allocate ( sample_pos ( ndat ), stat = ierr ); allocate ( sample_index ( ndat ), stat = ierr ); allocate ( p_vector ( nxyz , nvar ), stat = ierr ); allocate ( sigma_table ( ndat , nxyz ), stat = ierr ); allocate ( current_sigma ( ndat ), stat = ierr ); !call sgrnd(seed1); do i = 1 , size ( sample_pos ); sample_pos ( i ) = kohonen_map % rnumber_grator % generate (); enddo !call grnd_array(sample_pos); do i = 1 , nxyz sample_index ( i ) = i ; enddo ! call qsort % sort ( sample_pos , sample_index ); ! !  define p vector (See Lopez-Rubio et al, 2015) ! p_vector ( 1 : nxyz , 1 : nvar ) = input_data ( sample_index ( 1 : nxyz ), 1 : nvar ); ! !  Calculate the distance between the input data and the selected prototypes ! do i = 1 , ndat do j = 1 , nxyz sigma_table ( i , j ) = sum (( input_data ( i ,:) - p_vector ( j ,:)) ** 2 ); enddo enddo ! do j = 1 , nxyz current_sigma ( 1 : ndat ) = sigma_table ( 1 : ndat , j ); !(sample_index(i)=i,i=1,ndat) call qsort % sort ( current_sigma , sample_index ); !    if(current_sigma(1) > 1d-10) then !       current_sigma_value() enddo ! deallocate ( sample_pos , sample_index , p_vector , sigma_table , current_sigma ); ! end function calculate_sigma","tags":"","loc":"proc\\calculate_sigma.html"},{"title":"create_som – KohonenF08","text":"public  subroutine create_som(kohonen_map, training_parameters) Constructor for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object Calls proc~~create_som~~CallsGraph proc~create_som self_organizing_map%create_som error_stop error_stop proc~create_som->error_stop none~create~5 rkiss05_generator%create proc~create_som->none~create~5 proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som->proc~calculate_distance_matrix proc~create_distance factory_distance%create_distance proc~create_som->proc~create_distance proc~create_random_sample self_organizing_map%create_random_sample proc~create_som->proc~create_random_sample proc~position2index self_organizing_map%position2index proc~create_som->proc~position2index none~generate~2 rkiss05_generator%generate proc~create_random_sample->none~generate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_som~~CalledByGraph proc~create_som self_organizing_map%create_som proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=NUMCHAR), public, parameter :: fname = 'create_som' A character variable with the name of the function integer, public :: ierr integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: nvar1 integer, public :: nvar2 integer, public :: seed integer, public :: current_index integer, public :: nepoch integer, public :: i integer, public :: j real(kind=wp), public, allocatable :: input (:,:) character(len=NUMCHAR), public :: base_message character(len=NUMCHAR), public :: message Source Code subroutine create_som ( kohonen_map , training_parameters ) !======================================================================================== !!   Constructor for self_organizing_map character ( len = NUMCHAR ), parameter :: fname = 'create_som' !! A character variable with the name of the function class ( self_organizing_map ) :: kohonen_map !! A  `self_organizing_map` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` object integer :: ierr , nx , ny , nz , ix , iy , iz , nvar1 , nvar2 , seed , current_index , nepoch integer :: i , j real ( kind = wp ), allocatable :: input (:,:) character ( len = NUMCHAR ) :: base_message , message ! base_message = trim ( kohonen_map % class_name ) // '_' // trim ( fname ) // '_ERROR' ; ! kohonen_map % parameters = training_parameters ( 1 ); nx = training_parameters ( 1 )% number_nodes_nx ; ny = training_parameters ( 1 )% number_nodes_ny ; nz = training_parameters ( 1 )% number_nodes_nz ; nvar1 = training_parameters ( 1 )% number_variables1 ; nvar2 = training_parameters ( 1 )% number_variables2 ; nepoch = training_parameters ( 1 )% number_epochs ; write ( * , * ) 'Create= ' , nx , ny , nz , nvar1 , nvar2 , nepoch ; allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % grid_pattern_index ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid_pattern_index array' ; call error_stop ( message ); endif ! allocate ( input ( nvar1 , nvar2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for input array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % number_patterns ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for number_patterns array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % cells_index ( training_parameters ( 1 )% number_patterns , 3 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for cell_index array' ; call error_stop ( message ); endif ! kohonen_map % number_patterns = 0 ; kohonen_map % cells_index = 0 ; allocate ( kohonen_map % u_matrix ( 2 * nx - 1 , 2 * ny - 1 , 2 * nz - 1 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for u_matrix array' ; call error_stop ( message ); endif kohonen_map % u_matrix = 0.0_wp ; ! allocate ( kohonen_map % distance ( nx * ny , nx * ny ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for distance array' ; call error_stop ( message ); endif kohonen_map % distance = 0.0_wp ; ! allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); kohonen_map % cells_distances = 0.0d0 ; allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); kohonen_map % coordinates = 0.0d0 ; allocate ( kohonen_map % distortion ( nepoch ), stat = ierr ); kohonen_map % distortion = 0.0d0 ; ! call kohonen_map % factory % create_distance ( training_parameters ( 1 )% distance_type ,& kohonen_map % distance_function ); ! kohonen_map % seed = training_parameters ( 1 )% random_seed_ ( 1 ); call kohonen_map % rnumber_grator % create ( kohonen_map % seed ); ! do i=1,nvar1; !     do j=1,nvar2; !         input(i,j)=kohonen_map%rnumber_grator%generate(); !         !write(*,*) 'input= ',input(i,j); !     enddo ! enddo ! write ( * , * ) 'SOM: Initializing grid...' , kohonen_map % seed ; do iz = 1 , nz ; do iy = 1 , ny ; do ix = 1 , nx ; !write(*,*) 'creating ',ix,iy,iz call kohonen_map % create_random_sample ( input ); call kohonen_map % grid ( ix , iy , iz )% create ( input ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , training_parameters ( 1 )% node_type ); enddo !ix enddo !iy enddo !iz deallocate ( input ); ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& training_parameters ( 1 )% node_type , training_parameters ( 1 )% toroidal_grid ); write ( * , * ) 'SOM: Initializing grid...OK' ; ! end subroutine create_som","tags":"","loc":"proc\\create_som.html"},{"title":"destroy_som – KohonenF08","text":"public  subroutine destroy_som(kohonen_map) Destructor for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Calls proc~~destroy_som~~CallsGraph proc~destroy_som self_organizing_map%destroy_som none~destroy~2 kohonen_prototype%destroy proc~destroy_som->none~destroy~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_som~~CalledByGraph proc~destroy_som self_organizing_map%destroy_som proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~destroy_som proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~destroy_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz Source Code subroutine destroy_som ( kohonen_map ) !======================================================================================== !!   Destructor for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: ix , iy , iz ! !       write(*,*) 'SOM: Releasing memory...' if ( allocated ( kohonen_map % grid )) then do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif ! if ( allocated ( kohonen_map % number_patterns )) then deallocate ( kohonen_map % number_patterns ); endif ! if ( allocated ( kohonen_map % cells_index )) then deallocate ( kohonen_map % cells_index ); endif ! if ( allocated ( kohonen_map % u_matrix )) then deallocate ( kohonen_map % u_matrix ); endif ! if ( allocated ( kohonen_map % distance_function )) then deallocate ( kohonen_map % distance_function ); endif ! if ( allocated ( kohonen_map % distance )) then deallocate ( kohonen_map % distance ); endif ! if ( allocated ( kohonen_map % cells_distances )) then deallocate ( kohonen_map % cells_distances ); endif ! if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif ! if ( allocated ( kohonen_map % distortion )) then deallocate ( kohonen_map % distortion ) endif ! if ( allocated ( kohonen_map % grid_pattern_index )) then deallocate ( kohonen_map % grid_pattern_index ); endif ! if ( allocated ( kohonen_map % list_node_grid )) then deallocate ( kohonen_map % list_node_grid ); endif call kohonen_map % rnumber_grator % destroy (); ! !        write(*,*) 'SOM: Releasing memory...OK!' ! end subroutine destroy_som","tags":"","loc":"proc\\destroy_som.html"},{"title":"create_random_sample – KohonenF08","text":"public  subroutine create_random_sample(kohonen_map, input) Subroutine to generate random values that serve as inputs to the SOM Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: input A real array with the initial values of the prototypes Calls proc~~create_random_sample~~CallsGraph proc~create_random_sample self_organizing_map%create_random_sample none~generate~2 rkiss05_generator%generate proc~create_random_sample->none~generate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_random_sample~~CalledByGraph proc~create_random_sample self_organizing_map%create_random_sample proc~create_som self_organizing_map%create_som proc~create_som->proc~create_random_sample proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nvar1 integer, public :: nvar2 integer, public :: i integer, public :: j Source Code subroutine create_random_sample ( kohonen_map , input ) !======================================================================================== !! Subroutine to generate random values that serve as inputs to the SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: input !! A real array with the initial values of the prototypes integer :: nvar1 , nvar2 , i , j ! nvar1 = size ( input , 1 ); nvar2 = size ( input , 2 ); do i = 1 , nvar1 ; do j = 1 , nvar2 ; input ( i , j ) = kohonen_map % rnumber_grator % generate (); end do end do ! end subroutine create_random_sample","tags":"","loc":"proc\\create_random_sample.html"},{"title":"train_som_data – KohonenF08","text":"public  subroutine train_som_data(kohonen_map, input_data) Training function for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data Calls proc~~train_som_data~~CallsGraph proc~train_som_data self_organizing_map%train_som_data none~get_prototype kohonen_prototype%get_prototype proc~train_som_data->none~get_prototype proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data->proc~calculate_distance_between_prototypes proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data->proc~calculate_u_matrix proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data->proc~find_best_match_unit proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~train_som_data->proc~kohonen_pattern_accessor proc~update_weights self_organizing_map%update_weights proc~train_som_data->proc~update_weights proc~position2index self_organizing_map%position2index proc~calculate_distance_between_prototypes->proc~position2index none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance float float proc~find_best_match_unit->float proc~find_best_match_unit->none~distance proc~update_weights->none~get_prototype dexp dexp proc~update_weights->dexp none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position proc~update_weights->proc~position2index none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~train_som_data~~CalledByGraph proc~train_som_data self_organizing_map%train_som_data proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: iteration integer, public :: iepoch integer, public :: ipattern integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: jhit integer, public :: ihit integer, public :: khit integer, public :: ineigh integer, public :: jneigh integer, public :: kneigh integer, public :: idbg integer, public :: number_variables integer, public :: idisto integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: i integer, public :: j integer, public :: k integer, public :: number_nodes integer, public :: debug_option integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 integer, public :: pos integer, public :: pos1 integer, public :: max_pattern integer, public :: ierr integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ipos integer, public :: current_pos integer, public :: ic integer, public :: itemp real(kind=wp), public :: distortion real(kind=wp), public :: dist real(kind=wp), public :: dist_hit real(kind=wp), public :: maximum_radius real(kind=wp), public :: minimum_radius real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: u_temp type( kohonen_prototype ), public :: current_prototype real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_values integer, public, allocatable :: pattern_index (:,:,:,:) integer, public, allocatable :: positions (:) Source Code subroutine train_som_data ( kohonen_map , input_data ) !======================================================================================== !!   Training function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: iteration , iepoch , ipattern , ix , iy , iz , jhit , ihit , khit , ineigh , jneigh integer :: kneigh , idbg , number_variables , idisto !neff, integer :: cx , cy , cz , i , j , k , number_nodes , debug_option , ix1 , iy1 , iz1 , pos , pos1 , max_pattern integer :: ierr , nx , ny , nz , ipos integer :: current_pos , ic , itemp real ( kind = wp ) :: distortion , dist , dist_hit , maximum_radius , minimum_radius real ( kind = wp ) :: current_radius , alpha , u_temp type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values integer , allocatable :: pattern_index (:,:,:,:), positions (:) ! ! ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; allocate ( positions ( nx * ny * nz ), stat = ierr ); idbg = kohonen_map % parameters % idbg ; idisto = kohonen_map % parameters % idisto ; debug_option = kohonen_map % parameters % debug_level ; if ( debug_option > 0 ) then open ( idbg , file = trim ( kohonen_map % parameters % debug_file ), status = 'unknown' ); endif iteration = 0 ; distortion = 0.0_wp ; number_variables = kohonen_map % parameters % number_variables1 * kohonen_map % parameters % number_variables2 ; maximum_radius = dble ( max ( kohonen_map % parameters % number_nodes_nx , kohonen_map % parameters % number_nodes_ny )); minimum_radius = 1.0_wp ; write ( * , * ) 'SOM: Training starting...' do iepoch = 1 , kohonen_map % parameters % number_epochs ; kohonen_map % distortion ( iepoch ) = distortion ; write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion ; if ( iepoch > 1 ) write ( idisto , * ) iepoch , distortion distortion = 0.0_wp ; do ipattern = 1 , kohonen_map % parameters % number_patterns ; iteration = iteration + 1 ; ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); call current_prototype % get_prototype ( current_values ); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); !write(*,*) 'Test= ',ipattern,ihit,jhit,khit,dist_hit if ( debug_option > 0 ) then write ( idbg , * ) 'Epoch,Current Pattern' , iepoch , ipattern ; call current_prototype % print ( idbg ); endif distortion = distortion + dist_hit ; if ( debug_option > 0 ) then write ( idbg , * ) 'Neighborhood,alpha= ' , alpha ; endif call kohonen_map % update_weights ( current_values , ihit , jhit , khit , maximum_radius , iteration ); ! enddo !ipattern enddo !iepoch !       write(*,*) 'SOM: Training finished' !       write(*,*) 'Total number of iterations= ',iteration !     print prototypes ! if(kohonen_map%parameters%train_option < 3) then ! do iz=1,size(kohonen_map%grid,3) !    !write(kohonen_map%parameters%iprot,'(A,I4)') 'Layer ',iz !    do iy=1,size(kohonen_map%grid,2); !       do ix=1,size(kohonen_map%grid,1); !          !write(kohonen_map%parameters%iprot,'(A6,1X,3I4)') 'node= ',ix,iy,iz !          call kohonen_map%grid(ix,iy,iz)%print(kohonen_map%parameters%iprot); !       enddo !    enddo ! enddo!ix ! endif !     calculate and print distance matrix call kohonen_map % calculate_distance_between_prototypes (); !     final best match !      call kohonen_map%find_bmu_grid(input_data); max_pattern = 0 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); kohonen_map % number_patterns ( ihit , jhit , khit ) = kohonen_map % number_patterns ( ihit , jhit , khit ) + 1 ; if ( kohonen_map % number_patterns ( ihit , jhit , khit ) > max_pattern ) then max_pattern = kohonen_map % number_patterns ( ihit , jhit , khit ); endif kohonen_map % cells_index ( ipattern , 1 ) = ihit ; kohonen_map % cells_index ( ipattern , 2 ) = jhit ; kohonen_map % cells_index ( ipattern , 3 ) = khit ; if ( debug_option > 0 ) then write ( idbg , * ) ipattern , ihit , jhit , khit ; endif !if(kohonen_map%parameters%train_option < 3) then !   write(kohonen_map%parameters%iindex,*) ipattern,ihit,jhit,khit !endif !         write(*,*) 'BMU= ',ipattern,ihit,jhit,khit,dist_hit ! enddo !ipattern ! allocate ( pattern_index ( size ( kohonen_map % grid , 1 ),& size ( kohonen_map % grid , 2 ), size ( kohonen_map % grid , 3 ),& max_pattern ), stat = ierr ); pattern_index =- 1 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); do i = 1 , max_pattern ; if ( pattern_index ( ix , iy , iz , i ) < 0 ) then pattern_index ( ix , iy , iz , i ) = ipattern ; exit ; endif enddo enddo !ipattern if ( kohonen_map % parameters % train_option < 3 ) then do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % isam , '(A,3I4)' ) 'Node= ' , ix1 , iy1 , iz1 if ( kohonen_map % number_patterns ( ix1 , iy1 , iz1 ) > 0 ) then write ( kohonen_map % parameters % isam , '(A,10000I5)' ) 'Sample ID= ' ,& pattern_index ( ix1 , iy1 , iz1 , 1 : kohonen_map % number_patterns ( ix1 , iy1 , iz1 )); else write ( kohonen_map % parameters % isam , '(A,I4)' ) 'Sample ID= ' , 0 endif enddo enddo enddo deallocate ( pattern_index ); endif ! if ( debug_option . gt . 0 ) then close ( idbg ); endif close ( idisto ); !     print hit counter if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % grid , 3 ) do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % ihit , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % grid , 2 )); enddo !ix enddo endif call kohonen_map % calculate_u_matrix (); ! end subroutine train_som_data","tags":"","loc":"proc\\train_som_data.html"},{"title":"predict_som – KohonenF08","text":"public  subroutine predict_som(kohonen_map, input_data, map_output) Function for Prediction of a self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data integer, intent(out), dimension(:,:) :: map_output An integer array with the map output Calls proc~~predict_som~~CallsGraph proc~predict_som self_organizing_map%predict_som float float proc~predict_som->float none~distance kohonen_prototype%distance proc~predict_som->none~distance none~get_prototype kohonen_prototype%get_prototype proc~predict_som->none~get_prototype proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~predict_som->proc~kohonen_pattern_accessor none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~predict_som~~CalledByGraph proc~predict_som self_organizing_map%predict_som proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~predict_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ipattern integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: number_variables integer, public :: i integer, public :: j integer, public :: k real(kind=wp), public :: dist_hit real(kind=wp), public :: dist type( kohonen_prototype ), public :: current_prototype real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_values Source Code subroutine predict_som ( kohonen_map , input_data , map_output ) !======================================================================================== !! Function for Prediction of a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer , dimension (:,:), intent ( out ) :: map_output !! An integer array with the map output integer :: ipattern , ihit , jhit , khit , ix , iy , iz , number_variables , i , j , k real ( kind = wp ) :: dist_hit , dist type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values ! number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ; ! !       write(*,*) 'SOM: Prediction starting...'; !       write(*,*) number_variables do ipattern = 1 , size ( input_data , 1 ) ihit = 0 ; jhit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%print(); !write(*,*) ihit,jhit,dist_hit !call current_prototype%get_prototype(current_values); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; !write(*,*) ix,iy,dist !call kohonen_map%grid(ix,iy)%print(); dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo ! !$OMP end parallel do ! call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( current_values ); ! if(size(current_values,2) .eq. 1) then !   write(kohonen_map%parameters%iout,*) (current_values(i,1),& !         i=1,size(current_values,1)); ! else !   do i=1,size(current_values,1) !      write(kohonen_map%parameters%iout,*) (current_values(i,j),j=1,& !            size(current_values,2)) !   enddo ! endif !call map_output(ipattern)%create(current_values); map_output ( ipattern , 1 ) = ihit ; map_output ( ipattern , 2 ) = jhit ; map_output ( ipattern , 3 ) = khit ; !size(current_values,1),size(current_values,2) !write(*,*) current_values enddo !ipattern !       write(*,*) 'SOM: Prediction finished'; ! end subroutine predict_som","tags":"","loc":"proc\\predict_som.html"},{"title":"print_som – KohonenF08","text":"public  subroutine print_som(kohonen_map, unit_) Print function for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), optional :: unit_ Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: unit1 Source Code subroutine print_som ( kohonen_map , unit_ ) !======================================================================================== !!   Print function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , intent ( inout ), optional :: unit_ !! integer :: ix , iy , iz , unit1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif write ( unit1 , * ) 'SOM: Results' ; write ( unit1 , * ) call kohonen_map % parameters % print ( unit1 ); ! write(unit1,*) 'After' write ( unit1 , * ) write ( unit1 , * ) 'SOM: Grid nodes' ; write ( unit1 , * ) do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% print ( unit1 ); enddo enddo !iy enddo !ix write ( unit1 , * ) write ( unit1 , * ) 'SOM: Hit count' ; write ( unit1 , * ) write ( unit1 , * ) 'Pattern Numbers' ; do iz = 1 , size ( kohonen_map % number_patterns , 3 ); do ix = 1 , size ( kohonen_map % number_patterns , 1 ); write ( unit1 , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 ,& size ( kohonen_map % number_patterns , 2 )); enddo enddo write ( unit1 , * ) write ( * , * ) 'SOM: Pattern index' write ( unit1 , * ) write ( unit1 , * ) write ( unit1 , * ) 'Pattern #, ix   ,iy' ; do ix = 1 , size ( kohonen_map % cells_index , 1 ); write ( unit1 , '(100I5)' ) ix , ( kohonen_map % cells_index ( ix , iy ),& iy = 1 , size ( kohonen_map % cells_index , 2 )); enddo ! end subroutine print_som","tags":"","loc":"proc\\print_som.html"},{"title":"get_count_som – KohonenF08","text":"public  subroutine get_count_som(kohonen_map, count_) Function to get count matrix for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), dimension(:,:,:) :: count_ Source Code subroutine get_count_som ( kohonen_map , count_ ) !======================================================================================== !!   Function to get count matrix for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , dimension (:,:,:), intent ( inout ) :: count_ !! count_ = kohonen_map % number_patterns ; ! end subroutine get_count_som","tags":"","loc":"proc\\get_count_som.html"},{"title":"query_som – KohonenF08","text":"public  subroutine query_som(kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map real(kind=wp), intent(inout), dimension(:,:) :: input_pattern integer, allocatable :: sample_index (:) Calls proc~~query_som~~CallsGraph proc~query_som self_organizing_map%query_som none~get_prototype kohonen_prototype%get_prototype proc~query_som->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: ivar1 integer, public :: ivar2 integer, public :: nvar1 integer, public :: nvar2 integer, public :: number_patterns integer, public :: ipat integer, public :: ierr integer, public :: number_selected integer, public :: i integer, public :: pos real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_values real(kind=wp), public :: dist real(kind=wp), public :: dist_min integer, public, dimension(size(kohonen_map%cells_index,1)) :: position integer, public, dimension(size(kohonen_map%cells_index,1)) :: real_position Source Code subroutine query_som ( kohonen_map , input_pattern , sample_index ) !,output_patterns) !======================================================================================== !!   Function to find the input samples associated with specific vector class ( self_organizing_map ) :: kohonen_map !! real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_pattern !! integer , allocatable :: sample_index (:) !! integer :: ix , iy , iz , ihit , jhit , khit , ivar1 , ivar2 , nvar1 , nvar2 , number_patterns , ipat , ierr integer :: number_selected , i , pos real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values real ( kind = wp ) :: dist , dist_min integer , dimension ( size ( kohonen_map % cells_index , 1 )) :: position , real_position ! !(real_position(ix)=ix,ix=1,size(real_position)) do ix = 1 , size ( real_position ) real_position ( ix ) = ix ; enddo nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; dist_min = 1.0d10 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; call kohonen_map % grid ( ix , iy , iz )% get_prototype ( current_values ); do ivar1 = 1 , nvar1 ; do ivar2 = 1 , nvar2 ; if ( input_pattern ( ivar1 , ivar2 ) > 0.0_wp ) then dist = dist + ( input_pattern ( ivar1 , ivar2 ) - current_values ( ivar1 , ivar2 )) ** 2 ; endif enddo enddo if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo !$OMP end parallel do !         write(*,*) 'BMU' !         write(*,*) ihit,jhit,khit,dist_min ! position = 0 ; number_patterns = kohonen_map % number_patterns ( ihit , jhit , khit ); if ( number_patterns > 0 ) then where ( kohonen_map % cells_index (:, 1 ) == ihit . and . & kohonen_map % cells_index (:, 2 ) == jhit . and . & kohonen_map % cells_index (:, 3 ) == khit ) position = 1 ; !real_position; end where number_selected = sum ( position ); pos = 0 if ( number_selected > 0 ) then allocate ( sample_index ( number_selected ), stat = ierr ); do i = 1 , size ( real_position ) if ( position ( i ) == 1 ) then pos = pos + 1 ; sample_index ( pos ) = real_position ( i ); !write(*,*) 'Inside= ',i,real_position(i) endif enddo endif !write(*,*) kohonen_map%cells_index(118,1:3) else write ( * , * ) 'WARNING: Query has returned an empty result' return endif ! end subroutine query_som","tags":"","loc":"proc\\query_som.html"},{"title":"read_som – KohonenF08","text":"public  subroutine read_som(kohonen_map, som_fl) Subroutine to read the prototypes to define a self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object character(len=*) :: som_fl A character variable with the name of the file Calls proc~~read_som~~CallsGraph proc~read_som self_organizing_map%read_som none~destroy~2 kohonen_prototype%destroy proc~read_som->none~destroy~2 none~set_prototype kohonen_prototype%set_prototype proc~read_som->none~set_prototype proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~read_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~read_som->proc~calculate_distance_matrix proc~position2index self_organizing_map%position2index proc~read_som->proc~position2index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: testfl logical, public :: toroidal_grid integer, public :: isom integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nvar1 integer, public :: nvar2 integer, public :: ierr integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ivar integer, public :: current_index character(len=40), public :: current_line character(len=40), public :: node_type real(kind=wp), public, allocatable :: Prototype_value (:,:) Source Code subroutine read_som ( kohonen_map , som_fl ) !======================================================================================== !! Subroutine to read the prototypes to define a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len =* ) :: som_fl !! A character variable with the name of the file logical :: testfl , toroidal_grid integer :: isom , nx , ny , nz , nvar1 , nvar2 , ierr , ix , iy , iz , ivar , current_index character ( len = 40 ) :: current_line , node_type real ( kind = wp ), allocatable :: Prototype_value (:,:) ! isom = 20 ; inquire ( file = trim ( som_fl ), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the som file does not exist' stop endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...' write ( * , * ) open ( isom , file = trim ( som_fl ), status = 'unknown' , action = 'read' , access = 'sequential' ); read ( isom , '(A)' ) current_line write ( * , * ) trim ( current_line ) read ( isom , '(A17,1X,3I6)' ) current_line , nx , ny , nz write ( * , * ) current_line , nx , ny , nz read ( isom , '(A21,1X,2I6)' ) current_line , nvar1 , nvar2 write ( * , * ) current_line , nvar1 , nvar2 read ( isom , '(A25,1X,A11,1X,L4)' ) current_line , node_type , toroidal_grid write ( * , * ) current_line , node_type , toroidal_grid allocate ( Prototype_value ( nvar1 * nvar2 , 1 ), stat = ierr ); ! if ( allocated ( kohonen_map % grid )) then do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); do iz = 1 , nz read ( isom , '(A)' ) current_line ; write ( * , * ) 'Reading ' , trim ( current_line ); do iy = 1 , ny do ix = 1 , nx ; read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , * ) ( Prototype_value ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ); !write(*,*) ix,iy,(Prototype_value(ivar,1),ivar=1,nvar1*nvar2) call kohonen_map % grid ( ix , iy , iz )% set_prototype ( Prototype_value ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , node_type ); enddo enddo enddo close ( isom ) !write(*,*) 'Reading done' ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& node_type , toroidal_grid ); ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...finished' write ( * , * ) ! end subroutine read_som","tags":"","loc":"proc\\read_som.html"},{"title":"index2position – KohonenF08","text":"public  subroutine index2position(index_, nx, ny, nz, cx, cy, cz) Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: index_ Integer variable representing the index integer, intent(in) :: nx Integer variables representing the dimensions of the kohonen map integer, intent(in) :: ny Integer variables representing the dimensions of the kohonen map integer, intent(in) :: nz Integer variables representing the dimensions of the kohonen map integer, intent(inout) :: cx Integer variables representing the position of the node integer, intent(inout) :: cy Integer variables representing the position of the node integer, intent(inout) :: cz Integer variables representing the position of the node Called by proc~~index2position~~CalledByGraph proc~index2position self_organizing_map%index2position proc~update_weights self_organizing_map%update_weights proc~update_weights->proc~index2position proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~update_weights proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine index2position ( index_ , nx , ny , nz , cx , cy , cz ) !======================================================================================== !! Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index integer , intent ( in ) :: index_ !! Integer variable representing the index integer , intent ( in ) :: nx , ny , nz !! Integer variables representing the dimensions of the kohonen map integer , intent ( inout ) :: cx , cy , cz !! Integer variables representing the position of the node !  write(*,*) index_,nx,ny,1+int((index_-1)/(nx*ny)) cz = min ( 1 + int (( index_ - 1 ) / ( nx * ny )), nz ); cy = min ( 1 + int (( index_ - 1 - ( cz - 1 ) * nx * ny ) / nx ), ny ); cx = min ( index_ - ( cz - 1 ) * nx * ny - ( cy - 1 ) * nx , nx ); ! end subroutine index2position","tags":"","loc":"proc\\index2position.html"},{"title":"calculate_distance_matrix – KohonenF08","text":"public  subroutine calculate_distance_matrix(coordinates, distance_matrix, grid_type, toroidal) Subroutine to calculate the distance between the units inside a kohonen layer Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: coordinates Real array with the coordinates real(kind=wp), intent(inout), dimension(:,:) :: distance_matrix Real array with the distance_matrix character(len=*) :: grid_type Character variable with the grid type logical :: toroidal Logical variable for toroidal grid Called by proc~~calculate_distance_matrix~~CalledByGraph proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som self_organizing_map%create_som proc~create_som->proc~calculate_distance_matrix proc~read_som self_organizing_map%read_som proc~read_som->proc~calculate_distance_matrix proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=wp), public :: maxdiffx real(kind=wp), public :: maxdiffy real(kind=wp), public :: maxdiffz real(kind=wp), public, dimension(3) :: diffs Source Code subroutine calculate_distance_matrix ( coordinates , distance_matrix , grid_type , toroidal ) !======================================================================================== !! Subroutine to calculate the distance between the units inside a kohonen layer real ( kind = wp ), dimension (:,:), intent ( inout ) :: coordinates !! Real array with the coordinates real ( kind = wp ), dimension (:,:), intent ( inout ) :: distance_matrix !! Real array with the distance_matrix character ( len =* ) :: grid_type !! Character variable with the grid type logical :: toroidal !! Logical variable for toroidal grid integer :: i , j real ( kind = wp ) :: maxdiffx , maxdiffy , maxdiffz real ( kind = wp ), dimension ( 3 ) :: diffs ! maxdiffx = maxval ( coordinates (:, 1 )) / 2.0_wp ; maxdiffy = maxval ( coordinates (:, 2 )) / 2.0_wp ; maxdiffz = maxval ( coordinates (:, 3 )) / 2.0_wp ; ! distance_matrix = 0.0d0 ; ! if ( toroidal ) then do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); if ( diffs ( 1 ) > maxdiffx ) diffs ( 1 ) = 2.0_wp * maxdiffx - diffs ( 1 ); if ( diffs ( 2 ) > maxdiffy ) diffs ( 2 ) = 2.0_wp * maxdiffy - diffs ( 2 ); !if (diffs(3) > maxdiffy) diffs(3)=2*maxdiffz - diffs(3); if ( trim ( grid_type ) == 'hexagonal' ) then distance_matrix ( i , j ) = sum ( diffs ** 2 ); elseif ( trim ( grid_type ) == 'rectangular' ) then !rectangular distance_matrix ( i , j ) = maxval ( diffs ); endif !write(*,*) 'd= ',i,j,diffs(1:3),trim(grid_type)!distance_matrix(i,j) enddo enddo else do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); distance_matrix ( i , j ) = dsqrt ( sum ( diffs ** 2 )); enddo enddo endif ! distance_matrix = distance_matrix + transpose ( distance_matrix ); ! end subroutine calculate_distance_matrix","tags":"","loc":"proc\\calculate_distance_matrix.html"},{"title":"calculate_coordinates – KohonenF08","text":"public  subroutine calculate_coordinates(current_index, ix, iy, iz, nx, ny, nz, coordinates, node_type) Subroutine to calculate the coordinates of the units inside a kohonen layer Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_index integer, intent(in) :: ix integer, intent(in) :: iy integer, intent(in) :: iz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz real(kind=wp), intent(out), dimension(:,:) :: coordinates character(len=*), intent(in) :: node_type Called by proc~~calculate_coordinates~~CalledByGraph proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som self_organizing_map%create_som proc~create_som->proc~calculate_coordinates proc~read_som self_organizing_map%read_som proc~read_som->proc~calculate_coordinates proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , coordinates , node_type ) !======================================================================================== !!  Subroutine to calculate the coordinates of the units inside a kohonen layer integer , intent ( in ) :: current_index , ix , iy , iz , nx , ny , nz !! real ( kind = wp ), dimension (:,:), intent ( out ) :: coordinates !! character ( len =* ), intent ( in ) :: node_type !! coordinates ( current_index , 1 ) = dble ( ix ); coordinates ( current_index , 2 ) = dble ( iy ); coordinates ( current_index , 3 ) = dble ( iz ); !write(*,*) coordinates(current_index,1:3); if ( trim ( node_type ) == 'hexagonal' ) then coordinates ( current_index , 1 ) = coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( coordinates ( current_index , 2 ), 2.0_wp )); coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2.0_wp ) * coordinates ( current_index , 2 ); endif ! end subroutine calculate_coordinates","tags":"","loc":"proc\\calculate_coordinates.html"},{"title":"find_best_match_unit – KohonenF08","text":"public  subroutine find_best_match_unit(kohonen_map, current_prototype, ihit, jhit, khit, dist_hit) Subroutine to calculate the best match unit Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_prototype ), intent(inout) :: current_prototype A kohonen_prototype object integer, intent(out) :: ihit Integer variables for the coordinates of the BMU integer, intent(out) :: jhit Integer variables for the coordinates of the BMU integer, intent(out) :: khit Integer variables for the coordinates of the BMU real(kind=wp), intent(out) :: dist_hit Real variable with the distance to the BMU Calls proc~~find_best_match_unit~~CallsGraph proc~find_best_match_unit self_organizing_map%find_best_match_unit float float proc~find_best_match_unit->float none~distance kohonen_prototype%distance proc~find_best_match_unit->none~distance calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_best_match_unit~~CalledByGraph proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~find_best_match_unit proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: debug_option integer, public :: idbg integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: number_variables real(kind=wp), public :: dist Source Code subroutine find_best_match_unit ( kohonen_map , current_prototype , ihit , jhit , khit , dist_hit ) !======================================================================================== !! Subroutine to calculate the best match unit class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_prototype ), intent ( inout ) :: current_prototype !! A `kohonen_prototype` object integer , intent ( out ) :: ihit , jhit , khit !! Integer variables for the coordinates of the BMU real ( kind = wp ), intent ( out ) :: dist_hit !! Real variable with the distance to the BMU integer :: debug_option , idbg , ix , iy , iz , number_variables real ( kind = wp ) :: dist ! idbg = kohonen_map % parameters % idbg ; debug_option = kohonen_map % parameters % debug_level ; number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e7 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); !write(*,*) 'dist= ',dist if ( debug_option > 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ); write ( idbg , * ) ix , iy , iz , dist ; endif dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! !        write(*,*) 'find= ',ihit,jhit,khit,dist_hit return ! end subroutine find_best_match_unit","tags":"","loc":"proc\\find_best_match_unit.html"},{"title":"update_weights – KohonenF08","text":"public  subroutine update_weights(kohonen_map, current_values, ihit, jhit, khit, maximum_radius, iteration) Subroutine to update the weights Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: current_values A real array with the values of the current unit integer, intent(inout) :: ihit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: jhit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: khit Integer variables with the coordinates of the unit (neuron) to be modified real(kind=wp), intent(inout) :: maximum_radius Real variable with the maximum radius of the neighborhood integer, intent(inout) :: iteration Integer variables with the coordinates of the unit (neuron) to be modified Calls proc~~update_weights~~CallsGraph proc~update_weights self_organizing_map%update_weights dexp dexp proc~update_weights->dexp none~get_prototype kohonen_prototype%get_prototype proc~update_weights->none~get_prototype none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position proc~position2index self_organizing_map%position2index proc~update_weights->proc~position2index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~update_weights~~CalledByGraph proc~update_weights self_organizing_map%update_weights proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~update_weights proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: prototype_values real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: winner_values real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: term1 real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: term2 integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: debug_option integer, public :: ic integer, public :: current_pos integer, public :: ineigh integer, public :: jneigh integer, public :: kneigh integer, public :: idbg real(kind=wp), public :: time_factor real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: sigma2 real(kind=wp), public :: h_neighborhood real(kind=wp), public :: real_distance real(kind=wp), public :: term3 real(kind=wp), public :: distance_ratio real(kind=wp), public :: geometric_distance2 real(kind=wp), public :: eps real(kind=wp), public :: current_distance real(kind=wp), public :: lambda real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: v_vector real(kind=wp), public :: v_vector_norm real(kind=wp), public :: r real(kind=wp), public :: Psi character(len=NUMCHAR), public :: m_estimator Source Code subroutine update_weights ( kohonen_map , current_values , ihit , jhit , khit ,& maximum_radius , iteration ) !======================================================================================== !!    Subroutine to update the weights class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: current_values !! A real array with the values of the current unit integer , intent ( inout ) :: ihit , jhit , khit , iteration !! Integer variables with the coordinates of the unit (neuron) to be modified real ( kind = wp ), intent ( inout ) :: maximum_radius !! Real variable with the maximum radius of the neighborhood real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: prototype_values real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: winner_values , term1 , term2 integer :: nx , ny , nz , debug_option , ic , current_pos , ineigh , jneigh , kneigh , idbg real ( kind = wp ) :: time_factor , current_radius , alpha , sigma2 , h_neighborhood , real_distance , term3 real ( kind = wp ) :: distance_ratio , geometric_distance2 , eps , current_distance , lambda !type(influence_function) :: influence_func real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: v_vector real ( kind = wp ) :: v_vector_norm , r , Psi character ( len = NUMCHAR ) :: m_estimator ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; debug_option = kohonen_map % parameters % debug_level ; idbg = kohonen_map % parameters % idbg ; lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); time_factor = 1.0_wp - dble ( iteration ) / & dble ( kohonen_map % parameters % number_epochs * kohonen_map % parameters % number_patterns ); !current_radius = max(maximum_radius*real(1001-iteration)/1000.0 + 0.9999999999,4.0d0); current_radius = max ( maximum_radius * time_factor , 4.0_wp ); !alpha = max(kohonen_map%parameters%learning_rate*(1.0d0-real(iteration)/1000.0),0.01d0); alpha = max ( kohonen_map % parameters % learning_rate * time_factor , 0.01_wp ); sigma2 = current_radius ** 2 ; ! m_estimator = trim ( kohonen_map % parameters % m_estimator ); ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance < current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters % neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * dexp ( - 0.5_wp * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option > 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters % som_type )) case ( 'normal_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); !v_vector=(current_values-prototype_values); !v_vector_norm=dsqrt(sum(v_vector**2)); !r=v_vector_norm/sigma; !Psi=influence_func%calculate(m_estimator,r); !prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'visom' ) !write(*,*) trim(kohonen_map%parameters%som_type) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh == ihit ) . and . ( jneigh == jhit ) . and . ( kneigh == khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); eps = max ( 1.0_wp * time_factor , 0.0_wp ); term3 = 1.0_wp ; !((1.0d0-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * & ( distance_ratio - 1.0_wp ) * term3 ); endif !write(*,*) iteration,dsqrt(real_distance),dsqrt(geometric_distance2)*lambda,distance_ratio call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'robust_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); ! v_vector=(current_values-prototype_values); ! v_vector_norm=dsqrt(sum(v_vector**2)); ! r=v_vector_norm/sigma; ! Psi=influence_func%calculate(m_estimator,r); ! prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo !ic ! end subroutine update_weights","tags":"","loc":"proc\\update_weights.html"},{"title":"calculate_distance_between_prototypes – KohonenF08","text":"public  subroutine calculate_distance_between_prototypes(kohonen_map) Subroutine to calculate the distance between the prototypes Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Calls proc~~calculate_distance_between_prototypes~~CallsGraph proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~position2index self_organizing_map%position2index proc~calculate_distance_between_prototypes->proc~position2index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_distance_between_prototypes~~CalledByGraph proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~calculate_distance_between_prototypes proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 integer, public :: pos integer, public :: pos1 type( kohonen_prototype ), public :: current_prototype type( kohonen_prototype ), public :: current_prototype1 Source Code subroutine calculate_distance_between_prototypes ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the distance between the prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: nx , ny , ix , iy , iz , ix1 , iy1 , iz1 , pos , pos1 ! type ( kohonen_prototype ) :: current_prototype , current_prototype1 !! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_prototype = kohonen_map % grid ( ix , iy , iz ); pos = position2index ( ix , iy , iz , nx , ny ); do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); pos1 = position2index ( ix1 , iy1 , iz1 , nx , ny ) current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); kohonen_map % distance ( pos , pos1 ) = current_prototype1 % distance ( current_prototype ,& kohonen_map % distance_function ); enddo !ix1 enddo !iy1 enddo !iz1 enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! if ( kohonen_map % parameters % train_option < 3 ) then do ix = 1 , size ( kohonen_map % distance , 1 ) write ( kohonen_map % parameters % idist , * ) ( kohonen_map % distance ( ix , iy ), iy = 1 , size ( kohonen_map % distance , 2 )); enddo !ix endif ! end subroutine calculate_distance_between_prototypes","tags":"","loc":"proc\\calculate_distance_between_prototypes.html"},{"title":"find_bmu_grid – KohonenF08","text":"public  subroutine find_bmu_grid(kohonen_map, input_data) Subroutine to calculate the best match unit over the grid Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data Calls proc~~find_bmu_grid~~CallsGraph proc~find_bmu_grid self_organizing_map%find_bmu_grid float float proc~find_bmu_grid->float none~distance kohonen_prototype%distance proc~find_bmu_grid->none~distance proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~find_bmu_grid->proc~kohonen_pattern_accessor calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: idat integer, public :: pat_hit type( kohonen_prototype ), public :: current_prototype real(kind=wp), public :: dist real(kind=wp), public :: dist_min Source Code subroutine find_bmu_grid ( kohonen_map , input_data ) !======================================================================================== !! Subroutine to calculate the best match unit over the grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: nx , ny , nz , ix , iy , iz , ihit , jhit , khit , idat , pat_hit type ( kohonen_prototype ) :: current_prototype real ( kind = wp ) :: dist , dist_min ! do idat = 1 , size ( input_data ) dist_min = 1.0e7 ; ihit = 0 ; jhit = 0 ; khit = 0 ; call input_data ( idat )% get ( current_prototype ); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( kohonen_map % parameters % number_variables ) if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; pat_hit = idat ; endif enddo enddo enddo !$OMP end parallel do kohonen_map % grid_pattern_index ( ihit , jhit , khit ) = pat_hit ; kohonen_map % cells_index ( idat , 1 ) = ihit ; kohonen_map % cells_index ( idat , 2 ) = jhit ; kohonen_map % cells_index ( idat , 3 ) = khit ; !    write(*,*) 'BMU= ',idat,ihit,jhit,khit,dist_min enddo ! ! end subroutine find_bmu_grid","tags":"","loc":"proc\\find_bmu_grid.html"},{"title":"calculate_u_matrix – KohonenF08","text":"public  subroutine calculate_u_matrix(kohonen_map) Subroutine to calculate  the u_matrix Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Calls proc~~calculate_u_matrix~~CallsGraph proc~calculate_u_matrix self_organizing_map%calculate_u_matrix none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_u_matrix~~CalledByGraph proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~calculate_u_matrix proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=NUMCHAR), public :: type_ integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nt integer, public :: ierr integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: nxu integer, public :: nyu integer, public :: nzu real(kind=wp), public :: dist real(kind=wp), public :: u_temp Source Code subroutine calculate_u_matrix ( kohonen_map ) !======================================================================================== !! Subroutine to calculate  the u_matrix class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len = NUMCHAR ) :: type_ integer :: nx , ny , nz , nt , ierr , ix , iy , iz , cx , cy , cz , nxu , nyu , nzu real ( kind = wp ) :: dist , u_temp ! type_ = trim ( kohonen_map % parameters % node_type ); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; ! nxu = size ( kohonen_map % u_matrix , 1 ); nyu = size ( kohonen_map % u_matrix , 2 ); nzu = size ( kohonen_map % u_matrix , 3 ); ! select case ( trim ( type_ )) ! case ( 'rectangular' ) !call kohonen_map%calculate_u_matrix_rectangular(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); ! horizontal if ( ix < nx ) then cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif !vertical if ( iy < ny ) then cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; endif ! if ( iz < nz ) then cx = ix ; cy = iy ; cz = iz + 1 ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! Diagonal if ( ix < nx . and . iy < ny ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = dist + kohonen_map % grid ( ix , cy , iz )% distance ( kohonen_map % grid ( cx , iy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; endif enddo enddo enddo ! do iz = 1 , size ( kohonen_map % u_matrix , 3 ), 2 do iy = 1 , size ( kohonen_map % u_matrix , 2 ), 2 do ix = 1 , size ( kohonen_map % u_matrix , 1 ), 2 u_temp = 0.0d0 ; if ( ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 ) . and . & iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == 1 . and . ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( iy == size ( kohonen_map % u_matrix , 2 ) . and . ix > 1 . and .& ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == 1 . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = 0.0_wp ; endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! case ( 'hexagonal' ) !call kohonen_map%calculate_u_matrix_hexagonal(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); if ( ix < nx ) then !horizontal cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! if ( iy < ny ) then !diagonals cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; if ( mod ( iy , 2 ) == 0 . and . ix < nx ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; elseif ( mod ( iy , 2 ) == 1 . and . ix > 1 ) then cx = ix - 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 2 , 2 * iy , 2 * iz - 1 ) = dist ; endif endif enddo enddo enddo ! do iz = 1 , nzu , 2 ; do iy = 1 , nyu , 2 ; do ix = 1 , nxu , 2 ; u_temp = 0.0d0 ; if ( ix > 1 . and . iy > 1 . and . ix < nxu . and . iy < nyu ) then !middle part of the map u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); endif nt = 6 ; elseif ( iy == 1 . and . ix > 1 . and . ix < nxu ) then ! upper edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == nyu . and . ix > 1 . and . ix < nxu ) then ! lower edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); endif nt = 4 ; elseif ( ix == 1 . and . iy > 1 . and . iy < nyu ) then ! left edge u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); nt = 5 ; endif elseif ( ix == nxu . and . iy > 1 . and . iy < nyu ) then ! right edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ); nt = 5 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; endif elseif ( ix == 1 . and . iy == 1 ) then ! top left corner u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == nxu . and . iy == 1 ) then ! top right corner u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == nyu ) then ! bottom left corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); nt = 3 ; endif ; elseif ( ix == nxu . and . iy == nyu ) then ! bottom right corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ); nt = 3 ; else u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; endif endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! end select ! if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % u_matrix , 3 ); write ( kohonen_map % parameters % iumat , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % u_matrix , 1 ); write ( kohonen_map % parameters % iumat , '(100f10.5)' ) ( kohonen_map % u_matrix ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % u_matrix , 2 )); enddo enddo endif ! end subroutine calculate_u_matrix","tags":"","loc":"proc\\calculate_u_matrix.html"},{"title":"calculate_u_matrix_hexagonal – KohonenF08","text":"public  subroutine calculate_u_matrix_hexagonal(kohonen_map) Subroutine to calculate the u_matrix for an hexagonal grid Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Source Code subroutine calculate_u_matrix_hexagonal ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matrix for an hexagonal grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_hexagonal","tags":"","loc":"proc\\calculate_u_matrix_hexagonal.html"},{"title":"calculate_u_matrix_rectangular – KohonenF08","text":"public  subroutine calculate_u_matrix_rectangular(kohonen_map) Subroutine to calculate the u_matix for a rectangular grid Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Source Code subroutine calculate_u_matrix_rectangular ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matix for a rectangular grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_rectangular","tags":"","loc":"proc\\calculate_u_matrix_rectangular.html"},{"title":"get_u_matrix_som – KohonenF08","text":"public  subroutine get_u_matrix_som(kohonen_map, u_matrix) Subroutine to get the u_matrix from a SOM Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:,:) :: u_matrix A real array to return the u_matrix Source Code subroutine get_u_matrix_som ( kohonen_map , u_matrix ) !======================================================================================== !! Subroutine to get the u_matrix from a SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:,:), intent ( out ) :: u_matrix !! A real array to return the u_matrix u_matrix = kohonen_map % u_matrix ; ! end subroutine get_u_matrix_som","tags":"","loc":"proc\\get_u_matrix_som.html"},{"title":"get_prototypes – KohonenF08","text":"public  subroutine get_prototypes(kohonen_map, prototypes) Subroutine to get SOM prototypes Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: prototypes A real array to return the values of the SOM prototypes Calls proc~~get_prototypes~~CallsGraph proc~get_prototypes self_organizing_map%get_prototypes none~get_prototype kohonen_prototype%get_prototype proc~get_prototypes->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: pos integer, public :: nvar1 integer, public :: nvar2 integer, public, dimension(1) :: nvar real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_prototype real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1* kohonen_map%parameters%number_variables2) :: current_prototype1 Source Code subroutine get_prototypes ( kohonen_map , prototypes ) !======================================================================================== !! Subroutine to get SOM prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: prototypes !! A real array to return the values of the SOM prototypes integer :: i , j , k , pos , nvar1 , nvar2 integer , dimension ( 1 ) :: nvar real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ) :: current_prototype1 ! nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; nvar ( 1 ) = nvar1 * nvar2 pos = 0 ; do k = 1 , size ( kohonen_map % grid , 3 ) do j = 1 , size ( kohonen_map % grid , 2 ); do i = 1 , size ( kohonen_map % grid , 1 ); pos = pos + 1 ; call kohonen_map % grid ( i , j , k )% get_prototype ( current_prototype ); current_prototype1 ( 1 : nvar1 * nvar2 ) = reshape ( current_prototype , nvar ) prototypes ( pos ,:) = current_prototype1 ; enddo enddo enddo ! end subroutine get_prototypes","tags":"","loc":"proc\\get_prototypes.html"},{"title":"external_train_map – KohonenF08","text":"public  subroutine external_train_map(x, nvar, npat, nx, ny, nepoch, alpha, grid_type, distance_type, neigh_type, toroidal, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_som_\") Uses iso_c_binding proc~~external_train_map~~UsesGraph proc~external_train_map self_organizing_map%external_train_map iso_c_binding iso_c_binding proc~external_train_map->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutine to connect the self_organizing_map module to R o C\nImport section Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real array with the input patterns integer(kind=c_int), intent(in) :: nvar Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: npat Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: nx Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: ny Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: nepoch Integer variables to indicate the number of epochs for training real(kind=c_double), intent(in) :: alpha Real value with the initial learning rate integer(kind=c_int), intent(in) :: grid_type Integer variable to indicate the type of grid integer(kind=c_int), intent(in) :: distance_type Integer variable to indicate the distance type integer(kind=c_int), intent(in) :: neigh_type Integer variable to indicate the neighborhood type integer(kind=c_int), intent(in) :: toroidal Integer variable to indicate if a toroidal grid is used real(kind=c_double), intent(out) :: prot (nx*ny,nvar) Real array for the prototypes real(kind=c_double), intent(out) :: distortion (nepoch) Real array for the distortion measure (error during training) real(kind=c_double), intent(out) :: u_matrix (2*nx-1,2*ny-1) Real array for the u_matrix real(kind=c_double), intent(out) :: coords (nx*ny,3) Real array for the grid coordinates of the SOM integer(kind=c_int), intent(out) :: number_patterns (nx,ny) Integer array with the number of hits for each neuron integer(kind=c_int), intent(out) :: node_index (npat,3) Integer array with the index node for all the neurons of the SOM Calls proc~~external_train_map~~CallsGraph proc~external_train_map self_organizing_map%external_train_map none~get_prototype kohonen_prototype%get_prototype proc~external_train_map->none~get_prototype proc~destroy_som self_organizing_map%destroy_som proc~external_train_map->proc~destroy_som proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create proc~external_train_map->proc~kohonen_pattern_create proc~position2index self_organizing_map%position2index proc~external_train_map->proc~position2index proc~train_som_data self_organizing_map%train_som_data proc~external_train_map->proc~train_som_data none~destroy~2 kohonen_prototype%destroy proc~destroy_som->none~destroy~2 none~create~2 kohonen_prototype%create proc~kohonen_pattern_create->none~create~2 proc~train_som_data->none~get_prototype proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data->proc~calculate_distance_between_prototypes proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data->proc~calculate_u_matrix proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data->proc~find_best_match_unit proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~train_som_data->proc~kohonen_pattern_accessor proc~update_weights self_organizing_map%update_weights proc~train_som_data->proc~update_weights proc~calculate_distance_between_prototypes->proc~position2index none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance float float proc~find_best_match_unit->float proc~find_best_match_unit->none~distance proc~update_weights->none~get_prototype proc~update_weights->proc~position2index dexp dexp proc~update_weights->dexp none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: version = 0.1_wp Parameter version character(len=*), public, parameter :: program_name = \"som_train\" Parameter name of the function type( self_organizing_map ), public :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: parameters real(kind=wp), public, dimension(nvar,1) :: var integer, public :: i integer, public :: j integer, public :: k integer, public :: ierr integer, public :: pos integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: nx1 integer, public :: ny1 type( kohonen_pattern ), public, allocatable :: input_patterns (:) real(kind=wp), public, dimension(nx*ny,nvar) :: prototypes real(kind=wp), public, dimension(nvar,1) :: temp Source Code subroutine external_train_map ( x , nvar , npat , nx , ny , nepoch , alpha , grid_type ,& distance_type , neigh_type , toroidal , prot , distortion ,& u_matrix , coords , number_patterns , node_index ) bind ( C , name = \"train_som_\" ) !======================================================================================== !!    Subroutine to connect the self_organizing_map module to R o C use , intrinsic :: iso_c_binding , only : c_double , c_int , c_char !! Import section real ( kind = wp ), parameter :: version = 0.1_wp ; !! Parameter version character ( len =* ), parameter :: program_name = \"som_train\" ; !! Parameter name of the function integer ( c_int ), intent ( in ) :: nvar , npat !! Integer variables to indicate the number of variables and patterns integer ( c_int ), intent ( in ) :: nx , ny !! Integer variables to indicate the number of nodes of the SOM integer ( c_int ), intent ( in ) :: nepoch !! Integer variables to indicate the number of epochs for training integer ( c_int ), intent ( in ) :: toroidal !! Integer variable to indicate if a toroidal grid is used real ( c_double ), intent ( out ) :: prot ( nx * ny , nvar ) !! Real array for the prototypes real ( c_double ), intent ( out ) :: distortion ( nepoch ) !! Real array for the distortion measure (error during training) real ( c_double ), intent ( out ) :: u_matrix ( 2 * nx - 1 , 2 * ny - 1 ) !! Real array for the u_matrix real ( c_double ), intent ( out ) :: coords ( nx * ny , 3 ) !! Real array for the grid coordinates of the SOM integer ( c_int ), intent ( out ) :: number_patterns ( nx , ny ) !! Integer array with the number of hits for each neuron integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! Integer array with the index node for all the neurons of the SOM real ( c_double ), intent ( in ) :: x ( npat , nvar ) !! Real array with the input patterns real ( c_double ), intent ( in ) :: alpha !! Real value with the initial learning rate integer ( c_int ), intent ( in ) :: grid_type !! Integer variable to indicate the type of grid integer ( c_int ), intent ( in ) :: distance_type !! Integer variable to indicate the distance type integer ( c_int ), intent ( in ) :: neigh_type !! Integer variable to indicate the neighborhood type type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters real ( kind = wp ), dimension ( nvar , 1 ) :: var integer :: i , j , k , ierr , pos , ihit , jhit , khit , nx1 , ny1 type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), dimension ( nx * ny , nvar ) :: prototypes real ( kind = wp ), dimension ( nvar , 1 ) :: temp ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = nepoch ; parameters ( 1 )% learning_rate = alpha ; parameters ( 1 )% random_seed_ = 12345 ; if ( grid_type == 0 ) then parameters ( 1 )% node_type = \"rectangular\" ; !\"hexagonal\" !rectangular, hexagonal elseif ( grid_type == 1 ) then parameters ( 1 )% node_type = \"hexagonal\" ; endif parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" ; parameters ( 1 )% pattern_file = \"NOFILE\" ; parameters ( 1 )% output_file = \"NOFILE\" ; parameters ( 1 )% distance_type = \"euclidean\" ; !\"euclidean\" !euclidean, manhattan, correlation, correlation2 if ( neigh_type == 0 ) then parameters ( 1 )% neighborhood_type = \"bubble\" ; elseif ( neigh_type == 1 ) then parameters ( 1 )% neighborhood_type = \"gaussian\" ; !gaussian,bubble endif parameters ( 1 )% som_type = \"normal_som\" !,visom if ( toroidal == 1 ) then parameters ( 1 )% toroidal_grid = . TRUE .; else parameters ( 1 )% toroidal_grid = . FALSE .; endif ! ! ADDED TO AVOID PRINTING UNIT INFO (THE CAUSE IS UNKNONW) ! write(*,*) '' ! write(*,'(A,A,f10.5)') trim(program_name),' version: ',version ! write(*,*) '' allocate ( input_patterns ( npat ), stat = ierr ); do i = 1 , npat var ( 1 : nvar , 1 ) = x ( i , 1 : nvar ) !write(*,*) i,var call input_patterns ( i )% create ( var ); !    call input_patterns(i)%print(); enddo ! Create SOM call my_som % create ( parameters ); ! Train SOM call my_som % train ( input_patterns ); ! Extract results pos = 0 k = 1 nx1 = nx ; ny1 = ny ; do j = 1 , ny do i = 1 , nx pos = position2index ( i , j , k , nx1 , ny1 ); !write(*,*) i,j,pos,i+(j-1)*nx call my_som % grid ( i , j , k )% get_prototype ( temp ); !position2index() prototypes ( pos , 1 : nvar ) = temp ( 1 : nvar , 1 ); enddo enddo ! ! Get the results in the arrays ! distortion = my_som % distortion u_matrix ( 1 : 2 * nx - 1 , 1 : 2 * ny - 1 ) = my_som % u_matrix (:,:, 1 ); !do i=1,size(my_som%coordinates,1); !write(*,*) my_som%coordinates(i,1:3); !   coords(i,1:3)=my_som%coordinates(i,1:3); !enddo coords = my_som % coordinates ; !coords(1:nx*nx,1)=my_som%coordinates(:,1); !coords(1:nx*nx,2)=my_som%coordinates(:,2); !coords(1:nx*nx,3)=my_som%coordinates(:,3); number_patterns = my_som % number_patterns (:,:, 1 ); node_index = my_som % cells_index prot = prototypes ; ! call my_som % destroy (); ! do i = 1 , npat call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); ! ! ! write(*,*) ! write(*,'(A,A,f10.5,2X,A)') trim(program_name),' version: ',version,'Finished' ! write(*,*) ! end subroutine external_train_map","tags":"","loc":"proc\\external_train_map.html"},{"title":"external_predict_map – KohonenF08","text":"public  subroutine external_predict_map(prot, nx, ny, new_pat, npat, nvar, node_index) bind(C, name=\"predict_som_\") Uses iso_c_binding proc~~external_predict_map~~UsesGraph proc~external_predict_map self_organizing_map%external_predict_map iso_c_binding iso_c_binding proc~external_predict_map->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutine to connect this module to R Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: prot (nx*ny,nvar) integer(kind=c_int), intent(in) :: nx integer(kind=c_int), intent(in) :: ny real(kind=c_double), intent(in) :: new_pat (npat,nvar) integer(kind=c_int), intent(in) :: npat integer(kind=c_int), intent(in) :: nvar integer(kind=c_int), intent(out) :: node_index (npat,3) Calls proc~~external_predict_map~~CallsGraph proc~external_predict_map self_organizing_map%external_predict_map none~set_prototype kohonen_prototype%set_prototype proc~external_predict_map->none~set_prototype proc~create_som self_organizing_map%create_som proc~external_predict_map->proc~create_som proc~destroy_som self_organizing_map%destroy_som proc~external_predict_map->proc~destroy_som proc~predict_som self_organizing_map%predict_som proc~external_predict_map->proc~predict_som error_stop error_stop proc~create_som->error_stop none~create~5 rkiss05_generator%create proc~create_som->none~create~5 proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som->proc~calculate_distance_matrix proc~create_distance factory_distance%create_distance proc~create_som->proc~create_distance proc~create_random_sample self_organizing_map%create_random_sample proc~create_som->proc~create_random_sample proc~position2index self_organizing_map%position2index proc~create_som->proc~position2index none~destroy~2 kohonen_prototype%destroy proc~destroy_som->none~destroy~2 float float proc~predict_som->float none~distance kohonen_prototype%distance proc~predict_som->none~distance none~get_prototype kohonen_prototype%get_prototype proc~predict_som->none~get_prototype proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~predict_som->proc~kohonen_pattern_accessor none~distance->none~get_prototype calculate calculate none~distance->calculate none~generate~2 rkiss05_generator%generate proc~create_random_sample->none~generate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( self_organizing_map ), public :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: parameters integer, public :: ipat integer, public :: inode integer, public :: i_hit integer, public :: nx1 integer, public :: ny1 integer, public :: nz1 integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: pos integer, public :: ierr real(kind=wp), public :: dist real(kind=wp), public :: dist_hit real(kind=wp), public, dimension(nvar,1) :: temp type( kohonen_pattern ), public, dimension(npat) :: input_data Source Code subroutine external_predict_map ( prot , nx , ny , new_pat , npat , nvar , node_index ) & bind ( C , name = \"predict_som_\" ) !======================================================================================== !!    Subroutine to connect this module to R use , intrinsic :: iso_c_binding , only : c_double , c_int integer ( c_int ), intent ( in ) :: nx , ny , npat , nvar real ( c_double ), intent ( in ) :: prot ( nx * ny , nvar ), new_pat ( npat , nvar ) integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters integer :: ipat , inode , i_hit , nx1 , ny1 , nz1 , cx , cy , cz , ix , iy , iz , pos , ierr real ( kind = wp ) :: dist , dist_hit real ( kind = wp ), dimension ( nvar , 1 ) :: temp type ( kohonen_pattern ), dimension ( npat ) :: input_data ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = 1 ; parameters ( 1 )% learning_rate = 0.0d0 ; parameters ( 1 )% random_seed_ = 12345 ; parameters ( 1 )% node_type = \"hexagonal\" parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" parameters ( 1 )% pattern_file = \"NOFILE\" parameters ( 1 )% output_file = \"NOFILE\" parameters ( 1 )% distance_type = \"euclidean\" !\"euclidean\" !euclidean, manhattan, correlation, correlation2 parameters ( 1 )% neighborhood_type = \"gaussian\" !gaussian,bubble parameters ( 1 )% som_type = \"normal_som\" !,visom parameters ( 1 )% toroidal_grid = . TRUE . ! ! call parameters(1)%print(); ! call my_som % create ( parameters ); ! pos = 0 ; iz = 1 ; do iy = 1 , ny do ix = 1 , nx pos = pos + 1 ; temp ( 1 : nvar , 1 ) = prot ( pos , 1 : nvar ) call my_som % grid ( ix , iy , iz )% set_prototype ( temp ) enddo enddo ! do ipat = 1 , npat temp ( 1 : nvar , 1 ) = new_pat ( ipat , 1 : nvar ); call input_data ( ipat )% create ( temp ); enddo ! call my_som % predict ( input_data , node_index ); ! call my_som % destroy (); ! do ipat = 1 , size ( input_data ); call input_data ( ipat )% destroy (); enddo ! end subroutine external_predict_map","tags":"","loc":"proc\\external_predict_map.html"},{"title":"neighborhood_function_base_utilities – KohonenF08","text":"This module defines an abstract class to define neighborhood functions Uses precision_utilities module~~neighborhood_function_base_utilities~~UsesGraph module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~precision_utilities precision_utilities module~neighborhood_function_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine neighborhood_function_calculate(my_neigh_fn, geometric_distance) Subroutine template to calculate function\nImport section Arguments Type Intent Optional Attributes Name class( neighborhood_function_base ) :: my_neigh_fn A neighborhood_function_base object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric or grid distance of a SOM unit Derived Types type, public, abstract :: neighborhood_function_base Abstract class used to derive classes that calculates the effect of the input on the \nunits of a SOM (neighborhood function) Type-Bound Procedures procedure( neighborhood_function_calculate ), public, deferred :: calculate","tags":"","loc":"module\\neighborhood_function_base_utilities.html"},{"title":"kohonen_map_base_utilities – KohonenF08","text":"This module defines an abstract class for kohonen maps Uses kohonen_pattern_utilities precision_utilities kohonen_layer_parameters_utilities module~~kohonen_map_base_utilities~~UsesGraph module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~precision_utilities precision_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~constants_utilities->module~precision_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~distance_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_map_base_utilities~~UsedByGraph module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine kohonen_map_constructor(kohonen_map, training_parameters) Template function for the constructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object abstract interface public  subroutine kohonen_map_destructor(kohonen_map) Template function for the destructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object abstract interface public  subroutine kohonen_map_function1(kohonen_map, input_data) Template function for the training function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects abstract interface public  subroutine kohonen_map_function2(kohonen_map, input_data, map_output) Template function for the prediction function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects integer, intent(out), dimension(:,:) :: map_output An integer array Derived Types type, public, abstract :: kohonen_map_base Abstract Class to represent a template for a kohonen map Type-Bound Procedures procedure( kohonen_map_constructor ), public, deferred :: create procedure( kohonen_map_destructor ), public, deferred :: destroy procedure( kohonen_map_function1 ), public, deferred :: train procedure( kohonen_map_function2 ), public, deferred :: predict","tags":"","loc":"module\\kohonen_map_base_utilities.html"},{"title":"kohonen_prototype_utilities – KohonenF08","text":"** f kohonen_prototype_utilities/kohonen_prototype_constructor\n  NAME\n    kohonen_prototype_constructor\n  PURPOSE\n Class Constructor Uses distance_base_utilities precision_utilities error_handling constants_utilities module~~kohonen_prototype_utilities~~UsesGraph module~kohonen_prototype_utilities kohonen_prototype_utilities error_handling error_handling module~kohonen_prototype_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_prototype_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~kohonen_prototype_utilities->module~precision_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_prototype_utilities~~UsedByGraph module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~self_organizing_map_utilities module~som_train_variables->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kohonen_prototype Class to store a prototype inside a Kohonen map Type-Bound Procedures procedure, public :: create => kohonen_prototype_constructor procedure, public :: destroy => kohonen_prototype_destructor procedure, public :: get_prototype => kohonen_prototype_accessor procedure, public :: set_prototype => kohonen_prototype_mutator procedure, public :: print => kohonen_prototype_print procedure, public :: distance => kohonen_prototype_distance procedure, public :: get_nrow => kohonen_prototype_nrow procedure, public :: get_ncol => kohonen_prototype_ncol","tags":"","loc":"module\\kohonen_prototype_utilities.html"},{"title":"kohonen_layer_base_utilities – KohonenF08","text":"","tags":"","loc":"module\\kohonen_layer_base_utilities.html"},{"title":"random_number_generator_utilities – KohonenF08","text":"This module defines the random_number_generator class that is used to generate random numbers \nin several procedures across ATALIB. Uses mt19937_64 precision_utilities module~~random_number_generator_utilities~~UsesGraph module~random_number_generator_utilities random_number_generator_utilities module~mt19937_64 mt19937_64 module~random_number_generator_utilities->module~mt19937_64 module~precision_utilities precision_utilities module~random_number_generator_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~mt19937_64->iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: random_number_generator The random_number_generator class is used to encapsulate a generator or random numbers\nAn object of this class is defined through the specification of the random seed or seeds Type-Bound Procedures generic, public :: create => create_random_number_grator_single, create_random_number_grator_array procedure, public :: destroy => destroy_random_number_grator procedure, public :: generate","tags":"","loc":"module\\random_number_generator_utilities.html"},{"title":"constants_utilities – KohonenF08","text":"Uses precision_utilities module~~constants_utilities~~UsesGraph module~constants_utilities constants_utilities module~precision_utilities precision_utilities module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~constants_utilities~~UsedByGraph module~constants_utilities constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~constants_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_prototype_utilities->module~constants_utilities module~logger_utilities logger_utilities module~logger_utilities->module~constants_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~constants_utilities module~som_train_variables->module~kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~logger_utilities module~som_train_variables->module~self_organizing_map_utilities module~som_train_variables->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: PI = 4.0_wp*atan(1.0_wp) real(kind=wp), public, parameter :: LN2 = log(2.0_wp) real(kind=wp), public, parameter :: PIEP = 4.0_EP*atan(1.0_EP) real(kind=wp), public, parameter :: INVPIEP = 0.25_EP/atan(1.0_EP) real(kind=wp), public, parameter :: TWOPIEP = 8.0_EP*atan(1.0_EP) real(kind=wp), public, parameter :: PIOV2EP = 2.0_EP*atan(1.0_EP) real(kind=EP), public, parameter :: PIOV4EP = atan(1.0_EP) complex(kind=wp), public, parameter :: EYE = (0.0_wp, 1.0_wp) complex(kind=wp), public, parameter :: I_ = (0.0_wp, 1.0_wp) real(kind=wp), public, parameter :: E = exp(1.0_EP) real(kind=wp), public, parameter :: SQRT2 = sqrt(2.0_EP) real(kind=wp), public, parameter :: UNEST = -999.999999_EP real(kind=wp), public, parameter :: EPSILON = 1.0d-10 real(kind=wp), public, parameter :: TOLERANCE = 1.0d-6 real(kind=wp), public, parameter :: DEG2RAD = PI/180.0_wp integer, public, parameter :: NUMCHAR = 128 integer, public, parameter :: MAXNST = 10","tags":"","loc":"module\\constants_utilities.html"},{"title":"factory_distance_utilities – KohonenF08","text":"This module defines a factory to create distance objects Uses distance_base_utilities euclidean_distance_utilities manhattan_distance_utilities module~~factory_distance_utilities~~UsesGraph module~factory_distance_utilities factory_distance_utilities module~distance_base_utilities distance_base_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~precision_utilities precision_utilities module~distance_base_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~factory_distance_utilities~~UsedByGraph module~factory_distance_utilities factory_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: factory_distance Class to represent a distance factory Type-Bound Procedures procedure, public :: create_distance Subroutines public  subroutine create_distance (factory, type_, dist) Class constructor Arguments Type Intent Optional Attributes Name class( factory_distance ) :: factory A factory_distance object character(len=*) :: type_ A character string with the type of distance to be instantiated class( distance_base ), allocatable :: dist An allocatable distance_base object","tags":"","loc":"module\\factory_distance_utilities.html"},{"title":"distance_base_utilities – KohonenF08","text":"This module defines an abstract class to represent an abstract function to calculate distance Uses precision_utilities module~~distance_base_utilities~~UsesGraph module~distance_base_utilities distance_base_utilities module~precision_utilities precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~distance_base_utilities~~UsedByGraph module~distance_base_utilities distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~distance_base_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~distance_base_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~self_organizing_map_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  function distance_function1(distance, vector1, vector2) result(d) Template for the calculate function\nImport section Arguments Type Intent Optional Attributes Name class( distance_base ) :: distance A distance_base object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Derived Types type, public, abstract :: distance_base Abstract class distance_base Type-Bound Procedures procedure( distance_function1 ), public, deferred :: calculate","tags":"","loc":"module\\distance_base_utilities.html"},{"title":"logger_utilities – KohonenF08","text":"Uses constants_utilities module~~logger_utilities~~UsesGraph module~logger_utilities logger_utilities module~constants_utilities constants_utilities module~logger_utilities->module~constants_utilities module~precision_utilities precision_utilities module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~logger_utilities~~UsedByGraph module~logger_utilities logger_utilities module~som_train_variables som_train_variables module~som_train_variables->module~logger_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( logger ), public :: global_logger Derived Types type, public :: logger The Logger class is used to store all the variables related to the units of \nfiles used to store or print messages during the development (debugging ) or \nrunning Type-Bound Procedures procedure, public :: create => create_logger procedure, public :: destroy => destroy_logger procedure, public :: startup procedure, public :: shutdown procedure, public :: is_initialized procedure, public :: message procedure, public :: write generic, public :: configure => configure_logical, configure_integer, configure_character procedure, public :: get_unit procedure, public :: delimiter procedure, public :: get_delimiter procedure, public :: reset procedure, public :: error","tags":"","loc":"module\\logger_utilities.html"},{"title":"precision_utilities – KohonenF08","text":"Uses iso_fortran_env module~~precision_utilities~~UsesGraph module~precision_utilities precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~precision_utilities~~UsedByGraph module~precision_utilities precision_utilities module~constants_utilities constants_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities distance_base_utilities module~distance_base_utilities->module~precision_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~general_utilities general_utilities module~general_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~precision_utilities module~kohonen_layer_utilities->module~constants_utilities module~kohonen_layer_utilities->module~distance_base_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~quicksort_utilities quicksort_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~kohonen_layer_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~factory_distance_utilities factory_distance_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~neighborhood_function_base_utilities->module~precision_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~random_number_generator_utilities random_number_generator_utilities module~random_number_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~precision_utilities module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~som_train_variables som_train_variables module~som_train_variables->module~precision_utilities module~som_train_variables->module~constants_utilities module~som_train_variables->module~kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~self_organizing_map_utilities module~logger_utilities logger_utilities module~som_train_variables->module~logger_utilities module~sort_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~logger_utilities->module~constants_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = real32 Single precision integer, public, parameter :: dp = wp Double precision integer, public, parameter :: ep = wp Extended precision integer, public, parameter :: i8 = int8 Integer (short) integer, public, parameter :: i16 = int16 Integer (short) integer, public, parameter :: i32 = int32 Integer (long) integer, public, parameter :: i64 = int64 Integer (long)","tags":"","loc":"module\\precision_utilities.html"},{"title":"rkiss05_generator_utilities – KohonenF08","text":"Define the class rkiss05_generator that represents a random number generator\n  based on the rkiss method Uses random_generator_base_utilities precision_utilities module~~rkiss05_generator_utilities~~UsesGraph module~rkiss05_generator_utilities rkiss05_generator_utilities module~precision_utilities precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~random_generator_base_utilities random_generator_base_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~random_generator_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~rkiss05_generator_utilities~~UsedByGraph module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( random_generator_base ) :: rkiss05_generator Class to represent a random number generator that implements the rkiss method Type-Bound Procedures procedure, public :: create => create_rkiss05_generator procedure, public :: destroy => destroy_rkiss05_generator procedure, public :: generate => generate_rkiss05_generator","tags":"","loc":"module\\rkiss05_generator_utilities.html"},{"title":"kohonen_layer_utilities – KohonenF08","text":"This module defines a class that represents a layer in a self-organizing map Uses precision_utilities kohonen_prototype_utilities kohonen_map_base_utilities distance_base_utilities factory_distance_utilities rkiss05_generator_utilities kohonen_pattern_utilities kohonen_layer_parameters_utilities quicksort_utilities random_generator_base_utilities error_handling constants_utilities module~~kohonen_layer_utilities~~UsesGraph module~kohonen_layer_utilities kohonen_layer_utilities error_handling error_handling module~kohonen_layer_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~kohonen_layer_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~kohonen_layer_utilities->module~precision_utilities module~quicksort_utilities quicksort_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~kohonen_layer_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~kohonen_prototype_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module\\kohonen_layer_utilities.html"},{"title":"som_train_variables – KohonenF08","text":"Uses precision_utilities kohonen_prototype_utilities kohonen_map_base_utilities logger_utilities kohonen_pattern_utilities self_organizing_map_utilities kohonen_layer_parameters_utilities error_handling constants_utilities module~~som_train_variables~~UsesGraph module~som_train_variables som_train_variables error_handling error_handling module~som_train_variables->error_handling module~constants_utilities constants_utilities module~som_train_variables->module~constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~som_train_variables->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~som_train_variables->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~som_train_variables->module~kohonen_prototype_utilities module~logger_utilities logger_utilities module~som_train_variables->module~logger_utilities module~precision_utilities precision_utilities module~som_train_variables->module~precision_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~som_train_variables->module~self_organizing_map_utilities module~constants_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~logger_utilities->module~constants_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~self_organizing_map_utilities->error_handling module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~precision_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~quicksort_utilities quicksort_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( self_organizing_map ), public, save :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: som_parameters type( kohonen_pattern ), public, allocatable :: input_patterns (:) real(kind=wp), public, allocatable :: distance_matrix (:,:) integer, public :: ipattern character(len=NUMCHAR), public :: parfl Subroutines public  subroutine initialize_variables (par_file) Arguments Type Intent Optional Attributes Name character(len=*) :: par_file public  subroutine release_variables () Arguments None","tags":"","loc":"module\\som_train_variables.html"},{"title":"quicksort_utilities – KohonenF08","text":"Uses sort_base_utilities precision_utilities module~~quicksort_utilities~~UsesGraph module~quicksort_utilities quicksort_utilities module~precision_utilities precision_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~quicksort_utilities~~UsedByGraph module~quicksort_utilities quicksort_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( sort_base ) :: quicksort class that encapsulates the quicksort algorithm Type-Bound Procedures procedure, public, pass :: sort => quick_sort","tags":"","loc":"module\\quicksort_utilities.html"},{"title":"sort_base_utilities – KohonenF08","text":"Uses precision_utilities module~~sort_base_utilities~~UsesGraph module~sort_base_utilities sort_base_utilities module~precision_utilities precision_utilities module~sort_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~sort_base_utilities~~UsedByGraph module~sort_base_utilities sort_base_utilities module~quicksort_utilities quicksort_utilities module~quicksort_utilities->module~sort_base_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine sort_procedure(my_sort, list, order) Subroutine to sort an array\nimport sort_base Arguments Type Intent Optional Attributes Name class( sort_base ), intent(inout) :: my_sort my_sort: A sort_base object real(kind=wp), intent(inout), dimension(:) :: list list: A real vector integer, intent(inout), dimension(:) :: order order: An integer vector Derived Types type, public, abstract :: sort_base Abstract class to represent a generic sort algoritm Type-Bound Procedures procedure( sort_procedure ), public, deferred, pass :: sort","tags":"","loc":"module\\sort_base_utilities.html"},{"title":"mt19937_64 – KohonenF08","text":"NOTE: genrand64_int64 is kept private, as it generates different numbers\n      compared to the original C code. This is because the original C code\n      uses unsigned integers, while Fortran relies on signed integers.\n      This, however, has no impact on the generation of real numbers\n      (they are identical to those produced by the original C code). Uses iso_fortran_env module~~mt19937_64~~UsesGraph module~mt19937_64 mt19937_64 iso_fortran_env iso_fortran_env module~mt19937_64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mt19937_64~~UsedByGraph module~mt19937_64 mt19937_64 module~random_number_generator_utilities random_number_generator_utilities module~random_number_generator_utilities->module~mt19937_64 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function genrand64_real1 () Generates a random number on [0,1]-real-interval Arguments None Return Value real(kind=r64) public  function genrand64_real2 () Generates a random number on [0,1)-real-interval Arguments None Return Value real(kind=r64) public  function genrand64_real3 () Generates a random number on (0,1)-real-interval Arguments None Return Value real(kind=r64) Subroutines public  subroutine init_genrand64 (seed) Initializes mt(nn) with a seed Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: seed public  subroutine init_by_array64 (init_key) Initializes by an array with array-length\n  init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: init_key (:)","tags":"","loc":"module\\mt19937_64.html"},{"title":"kohonen_layer_parameters_utilities – KohonenF08","text":"Uses tomlf precision_utilities error_handling constants_utilities module~~kohonen_layer_parameters_utilities~~UsesGraph module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~precision_utilities precision_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_layer_parameters_utilities~~UsedByGraph module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kohonen_layer_parameters Components Type Visibility Attributes Name Initial integer, public :: train_option integer, public :: number_nodes_nx integer, public :: number_nodes_ny integer, public :: number_nodes_nz integer, public :: number_patterns integer, public :: number_variables1 integer, public :: number_variables2 integer, public :: number_variables integer, public, allocatable :: column_var (:) integer, public :: number_epochs integer, public :: debug_level integer, public, dimension(1) :: random_seed_ real(kind=wp), public :: learning_rate character(len=NUMCHAR), public :: node_type character(len=NUMCHAR), public :: debug_file character(len=NUMCHAR), public :: pattern_file character(len=NUMCHAR), public :: output_file character(len=NUMCHAR), public :: distance_type character(len=NUMCHAR), public :: neighborhood_type character(len=NUMCHAR), public :: som_type character(len=NUMCHAR), public :: m_estimator logical, public :: toroidal_grid integer, public :: idbg integer, public :: iout integer, public :: iindex integer, public :: iprot integer, public :: ihit integer, public :: idist integer, public :: iumat integer, public :: ipar integer, public :: isam integer, public :: iclus integer, public :: icen integer, public :: iclus1 integer, public :: idisto integer, public :: iout1 integer, public :: imeas logical, public :: view_flag integer, public :: ireal Type-Bound Procedures procedure, public :: print => print_parameters procedure, public :: read_parameters procedure, public :: read_parameters_toml","tags":"","loc":"module\\kohonen_layer_parameters_utilities.html"},{"title":"euclidean_distance_utilities – KohonenF08","text":"This module defines a class to calculate the Euclidean distance between kohonen prototypes Uses distance_base_utilities precision_utilities module~~euclidean_distance_utilities~~UsesGraph module~euclidean_distance_utilities euclidean_distance_utilities module~distance_base_utilities distance_base_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~euclidean_distance_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~euclidean_distance_utilities~~UsedByGraph module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( distance_base ) :: euclidean_distance Class to calculate the euclidean distance Type-Bound Procedures procedure, public :: calculate => calculate_euclidean_distance Functions public  function calculate_euclidean_distance (distance, vector1, vector2) result(d) Function to calculate euclidean distance between vectors Arguments Type Intent Optional Attributes Name class( euclidean_distance ) :: distance A euclidean_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance","tags":"","loc":"module\\euclidean_distance_utilities.html"},{"title":"kohonen_pattern_utilities – KohonenF08","text":"This module defines a class called kohonen_pattern to store the input patterns Uses kohonen_prototype_utilities precision_utilities error_handling constants_utilities module~~kohonen_pattern_utilities~~UsesGraph module~kohonen_pattern_utilities kohonen_pattern_utilities error_handling error_handling module~kohonen_pattern_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~kohonen_pattern_utilities->module~precision_utilities module~constants_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~distance_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_pattern_utilities~~UsedByGraph module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kohonen_pattern Class to represent a container for input data to  a kohonen map Type-Bound Procedures procedure, public :: create => kohonen_pattern_create procedure, public :: destroy => kohonen_pattern_destroy procedure, public :: get => kohonen_pattern_accessor procedure, public :: set => kohonen_pattern_mutator procedure, public :: print => kohonen_pattern_print procedure, public :: get_nrow => kohonen_pattern_nrow procedure, public :: get_ncol => kohonen_pattern_ncol Functions public  function kohonen_pattern_nrow (current_pattern) result(nr) Function to calculate the number of rows (samples) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of rows (samples) in a pattern public  function kohonen_pattern_ncol (current_pattern) result(nc) Function to calculate the number of columns (variables) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of columns (variables) in a pattern Subroutines public  subroutine kohonen_pattern_create (current_pattern, input, name) Kohonen pattern constructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object real(kind=wp), intent(inout), dimension(:,:) :: input A real array character(len=*), optional :: name A character string with the name of the pattern public  subroutine kohonen_pattern_destroy (current_pattern) Kohonen pattern destructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object public  subroutine kohonen_pattern_accessor (current_pattern, pattern_value) Kohonen pattern accessor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value public  subroutine kohonen_pattern_mutator (current_pattern, pattern_value) kohonen_pattern_mutator Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value public  subroutine kohonen_pattern_print (current_pattern, unit_) Subroutine to print a Kohonen pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit where the patterns will be printed","tags":"","loc":"module\\kohonen_pattern_utilities.html"},{"title":"random_generator_base_utilities – KohonenF08","text":"Uses precision_utilities module~~random_generator_base_utilities~~UsesGraph module~random_generator_base_utilities random_generator_base_utilities module~precision_utilities precision_utilities module~random_generator_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~random_generator_base_utilities~~UsedByGraph module~random_generator_base_utilities random_generator_base_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  function random_generator_generate(generator) result(r) Template of the function used to generate realizations of the random numbers in the \nclasses derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Return Value real(kind=wp) r: A real number abstract interface public  subroutine random_generator_constructor(generator, iseed) Template of the constructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random generator. abstract interface public  subroutine random_generator_destructor(generator) Template of the destructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Derived Types type, public, abstract :: random_generator_base Abstract class to derive random number generator classes Type-Bound Procedures procedure( random_generator_constructor ), public, deferred :: create procedure( random_generator_destructor ), public, deferred :: destroy procedure( random_generator_generate ), public, deferred :: generate","tags":"","loc":"module\\random_generator_base_utilities.html"},{"title":"general_utilities – KohonenF08","text":"This module includes general purpose functions used in several parts of the library Uses precision_utilities module~~general_utilities~~UsesGraph module~general_utilities general_utilities module~precision_utilities precision_utilities module~general_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface maximum private  subroutine maximum_only(a, mx) Subroutine to calculate the maximum of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a real(kind=wp) :: mx private  subroutine maximum_position(a, mx, p) Subroutine to find the position of the maximum value of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a A real array real(kind=wp) :: mx A real value with the maximum integer :: p An integer value with the position of the maximum Functions public  function minimum (a) result(mn) Function to calculate the minimum of an array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a Real array Return Value real(kind=wp) Real value with the minimum public  function mean (a) result(mn) Function to calculate the mean of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real value with the calculated mean public  function variance (a) result(v) Function to calculate the variance of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated variance public  function std (a) result(s) Function to calculate the standard deviation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated standard deviation public  function coefficient_of_variation (a) result(cov) Function to calculate the coefficient of variation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated coefficient of variation","tags":"","loc":"module\\general_utilities.html"},{"title":"manhattan_distance_utilities – KohonenF08","text":"This module defines a class to calculate the Manhattan distance between kohonen prototypes Uses distance_base_utilities precision_utilities module~~manhattan_distance_utilities~~UsesGraph module~manhattan_distance_utilities manhattan_distance_utilities module~distance_base_utilities distance_base_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~manhattan_distance_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~manhattan_distance_utilities~~UsedByGraph module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( distance_base ) :: manhattan_distance Class to calculate the Manhattan distance Type-Bound Procedures procedure, public :: calculate => calculate_manhattan_distance","tags":"","loc":"module\\manhattan_distance_utilities.html"},{"title":"self_organizing_map_utilities – KohonenF08","text":"This module defines a class for simple self_organizing_map (one kohonen layer) f self_organizing_map_utilities/calculate_u_matrix\n NAME\n   calculate_u_matrix\n PURPOSE\n    Subroutine to calculate  the u_matrix\n SYNOPSIS\n======================================================================================== f self_organizing_map_utilities/external_train_map\n NAME\n   external_train_map\n PURPOSE\n SYNOPSIS\n======================================================================================== Uses precision_utilities kohonen_prototype_utilities kohonen_map_base_utilities distance_base_utilities factory_distance_utilities rkiss05_generator_utilities kohonen_pattern_utilities kohonen_layer_parameters_utilities quicksort_utilities random_generator_base_utilities error_handling constants_utilities module~~self_organizing_map_utilities~~UsesGraph module~self_organizing_map_utilities self_organizing_map_utilities error_handling error_handling module~self_organizing_map_utilities->error_handling module~constants_utilities constants_utilities module~self_organizing_map_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~self_organizing_map_utilities->module~precision_utilities module~quicksort_utilities quicksort_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~kohonen_prototype_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~self_organizing_map_utilities~~UsedByGraph module~self_organizing_map_utilities self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( kohonen_map_base ) :: self_organizing_map Class to represent a self_organizing_map Type-Bound Procedures procedure, public :: create => create_som procedure, public :: destroy => destroy_som procedure, public :: train => train_som_data procedure, public :: predict => predict_som procedure, public :: print => print_som procedure, public :: read => read_som procedure, public :: get_count => get_count_som procedure, public :: query => query_som procedure, public :: get_prototypes procedure, public :: get_u_matrix => get_u_matrix_som procedure, public, nopass :: external_train_map procedure, public, nopass :: external_predict_map Functions public  function position2index (ix, iy, iz, nx, ny) result(index_) Function to calculate the index inside a rectangular grid from position ix,iy,iz Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix Integer variables integer, intent(in) :: iy Integer variables integer, intent(in) :: iz Integer variables integer, intent(in) :: nx Integer variables integer, intent(in) :: ny Integer variables Return Value integer Integer variable with the required index public  function calculate_sigma (kohonen_map, input_data, seed) result(sigma) Function to calculate the scaling factor sigma Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_data A real array with the input data integer, intent(inout), optional :: seed An integer with the random seed Return Value real(kind=wp) A real variable with the value of sigma Subroutines public  subroutine create_som (kohonen_map, training_parameters) Constructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object public  subroutine destroy_som (kohonen_map) Destructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine create_random_sample (kohonen_map, input) Subroutine to generate random values that serve as inputs to the SOM Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: input A real array with the initial values of the prototypes public  subroutine train_som_data (kohonen_map, input_data) Training function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data public  subroutine predict_som (kohonen_map, input_data, map_output) Function for Prediction of a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data integer, intent(out), dimension(:,:) :: map_output An integer array with the map output public  subroutine print_som (kohonen_map, unit_) Print function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), optional :: unit_ public  subroutine get_count_som (kohonen_map, count_) Function to get count matrix for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), dimension(:,:,:) :: count_ public  subroutine query_som (kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map real(kind=wp), intent(inout), dimension(:,:) :: input_pattern integer, allocatable :: sample_index (:) public  subroutine read_som (kohonen_map, som_fl) Subroutine to read the prototypes to define a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object character(len=*) :: som_fl A character variable with the name of the file public  subroutine index2position (index_, nx, ny, nz, cx, cy, cz) Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index Arguments Type Intent Optional Attributes Name integer, intent(in) :: index_ Integer variable representing the index integer, intent(in) :: nx Integer variables representing the dimensions of the kohonen map integer, intent(in) :: ny Integer variables representing the dimensions of the kohonen map integer, intent(in) :: nz Integer variables representing the dimensions of the kohonen map integer, intent(inout) :: cx Integer variables representing the position of the node integer, intent(inout) :: cy Integer variables representing the position of the node integer, intent(inout) :: cz Integer variables representing the position of the node public  subroutine calculate_distance_matrix (coordinates, distance_matrix, grid_type, toroidal) Subroutine to calculate the distance between the units inside a kohonen layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: coordinates Real array with the coordinates real(kind=wp), intent(inout), dimension(:,:) :: distance_matrix Real array with the distance_matrix character(len=*) :: grid_type Character variable with the grid type logical :: toroidal Logical variable for toroidal grid public  subroutine calculate_coordinates (current_index, ix, iy, iz, nx, ny, nz, coordinates, node_type) Subroutine to calculate the coordinates of the units inside a kohonen layer Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_index integer, intent(in) :: ix integer, intent(in) :: iy integer, intent(in) :: iz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz real(kind=wp), intent(out), dimension(:,:) :: coordinates character(len=*), intent(in) :: node_type public  subroutine find_best_match_unit (kohonen_map, current_prototype, ihit, jhit, khit, dist_hit) Subroutine to calculate the best match unit Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_prototype ), intent(inout) :: current_prototype A kohonen_prototype object integer, intent(out) :: ihit Integer variables for the coordinates of the BMU integer, intent(out) :: jhit Integer variables for the coordinates of the BMU integer, intent(out) :: khit Integer variables for the coordinates of the BMU real(kind=wp), intent(out) :: dist_hit Real variable with the distance to the BMU public  subroutine update_weights (kohonen_map, current_values, ihit, jhit, khit, maximum_radius, iteration) Subroutine to update the weights Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: current_values A real array with the values of the current unit integer, intent(inout) :: ihit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: jhit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: khit Integer variables with the coordinates of the unit (neuron) to be modified real(kind=wp), intent(inout) :: maximum_radius Real variable with the maximum radius of the neighborhood integer, intent(inout) :: iteration Integer variables with the coordinates of the unit (neuron) to be modified public  subroutine calculate_distance_between_prototypes (kohonen_map) Subroutine to calculate the distance between the prototypes Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine find_bmu_grid (kohonen_map, input_data) Subroutine to calculate the best match unit over the grid Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data public  subroutine calculate_u_matrix (kohonen_map) Subroutine to calculate  the u_matrix Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine calculate_u_matrix_hexagonal (kohonen_map) Subroutine to calculate the u_matrix for an hexagonal grid Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine calculate_u_matrix_rectangular (kohonen_map) Subroutine to calculate the u_matix for a rectangular grid Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine get_u_matrix_som (kohonen_map, u_matrix) Subroutine to get the u_matrix from a SOM Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:,:) :: u_matrix A real array to return the u_matrix public  subroutine get_prototypes (kohonen_map, prototypes) Subroutine to get SOM prototypes Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: prototypes A real array to return the values of the SOM prototypes public  subroutine external_train_map (x, nvar, npat, nx, ny, nepoch, alpha, grid_type, distance_type, neigh_type, toroidal, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_som_\") Subroutine to connect the self_organizing_map module to R o C\nImport section Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real array with the input patterns integer(kind=c_int), intent(in) :: nvar Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: npat Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: nx Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: ny Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: nepoch Integer variables to indicate the number of epochs for training real(kind=c_double), intent(in) :: alpha Real value with the initial learning rate integer(kind=c_int), intent(in) :: grid_type Integer variable to indicate the type of grid integer(kind=c_int), intent(in) :: distance_type Integer variable to indicate the distance type integer(kind=c_int), intent(in) :: neigh_type Integer variable to indicate the neighborhood type integer(kind=c_int), intent(in) :: toroidal Integer variable to indicate if a toroidal grid is used real(kind=c_double), intent(out) :: prot (nx*ny,nvar) Real array for the prototypes real(kind=c_double), intent(out) :: distortion (nepoch) Real array for the distortion measure (error during training) real(kind=c_double), intent(out) :: u_matrix (2*nx-1,2*ny-1) Real array for the u_matrix real(kind=c_double), intent(out) :: coords (nx*ny,3) Real array for the grid coordinates of the SOM integer(kind=c_int), intent(out) :: number_patterns (nx,ny) Integer array with the number of hits for each neuron integer(kind=c_int), intent(out) :: node_index (npat,3) Integer array with the index node for all the neurons of the SOM public  subroutine external_predict_map (prot, nx, ny, new_pat, npat, nvar, node_index) bind(C, name=\"predict_som_\") Subroutine to connect this module to R Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: prot (nx*ny,nvar) integer(kind=c_int), intent(in) :: nx integer(kind=c_int), intent(in) :: ny real(kind=c_double), intent(in) :: new_pat (npat,nvar) integer(kind=c_int), intent(in) :: npat integer(kind=c_int), intent(in) :: nvar integer(kind=c_int), intent(out) :: node_index (npat,3)","tags":"","loc":"module\\self_organizing_map_utilities.html"},{"title":"neighborhood_function_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class to define neighborhood functions This file depends on sourcefile~~neighborhood_function_base_utilities.f90~~EfferentGraph sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/08/2025 !! version: 0.1 !! This module defines an abstract class to define neighborhood functions module neighborhood_function_base_utilities !! This module defines an abstract class to define neighborhood functions use precision_utilities , only : wp ; implicit none ; ! type , abstract :: neighborhood_function_base !! Abstract class used to derive classes that calculates the effect of the input on the !! units of a SOM (neighborhood function) contains procedure ( neighborhood_function_calculate ), deferred :: calculate end type neighborhood_function_base ! abstract interface subroutine neighborhood_function_calculate ( my_neigh_fn , geometric_distance ) !! Subroutine template to calculate function import :: neighborhood_function_base import :: wp !! Import section class ( neighborhood_function_base ) :: my_neigh_fn !! A `neighborhood_function_base` object real ( kind = wp ), intent ( inout ) :: geometric_distance !! A real variable with the geometric or grid distance of a SOM unit end subroutine neighborhood_function_calculate ! end interface ! end module neighborhood_function_base_utilities","tags":"","loc":"sourcefile\\neighborhood_function_base_utilities.f90.html"},{"title":"kohonen_map_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class for kohonen maps This file depends on sourcefile~~kohonen_map_base_utilities.f90~~EfferentGraph sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_map_base_utilities.f90~~AfferentGraph sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines an abstract class for kohonen maps module kohonen_map_base_utilities !! This module defines an abstract class for kohonen maps use precision_utilities , only : wp ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_pattern_utilities , only : kohonen_pattern ; ! implicit none ! type , abstract :: kohonen_map_base !! Abstract Class to represent a template for a kohonen map contains procedure ( kohonen_map_constructor ), public , deferred :: create procedure ( kohonen_map_destructor ), public , deferred :: destroy procedure ( kohonen_map_function1 ), public , deferred :: train procedure ( kohonen_map_function2 ), public , deferred :: predict end type kohonen_map_base !! abstract interface !======================================================================================== subroutine kohonen_map_constructor ( kohonen_map , training_parameters ) !======================================================================================== !! Template function for the constructor of a kohonen map import :: kohonen_map_base import :: kohonen_layer_parameters !! Import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` object end subroutine kohonen_map_constructor !======================================================================================== subroutine kohonen_map_destructor ( kohonen_map ) !======================================================================================== !! Template function for the destructor of a kohonen map import :: kohonen_map_base !! Import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object end subroutine kohonen_map_destructor !======================================================================================== subroutine kohonen_map_function1 ( kohonen_map , input_data ) !======================================================================================== !!   Template function for the training function of a kohonen map import :: kohonen_map_base import :: kohonen_pattern !! import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! An array of `kohonen_pottern` objects end subroutine kohonen_map_function1 !======================================================================================== subroutine kohonen_map_function2 ( kohonen_map , input_data , map_output ) !======================================================================================== !!   Template function for the prediction function of a kohonen map import :: kohonen_map_base import :: kohonen_pattern !! import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! An array of `kohonen_pottern` objects integer , dimension (:,:), intent ( out ) :: map_output !! An integer array end subroutine kohonen_map_function2 ! end interface ! end module kohonen_map_base_utilities","tags":"","loc":"sourcefile\\kohonen_map_base_utilities.f90.html"},{"title":"multilayer_self_organizing_map_utilities.f – KohonenF08","text":"This module defines a class that represents a multilayer self_organized_map \ndefined using several kohonen layers \nThis module defines a class that represents a multilayer self_organized_map Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/05/2025 !! version: 0.1 !! This module defines a class that represents a multilayer self_organized_map !! defined using several kohonen layers modul e multilayer_self_organizing_map_utilities !! This module defines a class that represents a multilayer self_organized_map use e r ror_handling , only : error_stop , error_t ; use p r ecision_utilities , only : wp ; use c o nstants_utilities , only : NUMCHAR ; use r a ndom_generator_base_utilities , only : random_generator_base ; use r k iss05_generator_utilities , only : rkiss05_generator ; use k o honen_layer_parameters_utilities , only : kohonen_layer_parameters ; use k o honen_map_base_utilities , only : kohonen_map_base ; use k o honen_prototype_utilities , only : kohonen_prototype ; use k o honen_pattern_utilities , only : kohonen_pattern ; use d i stance_base_utilities , only : distance_base ; use f a ctory_distance_utilities , only : factory_distance ; !use influence_function_utilities; end m o dule multilayer_self_organizing_map_utilities","tags":"","loc":"sourcefile\\multilayer_self_organizing_map_utilities.f.html"},{"title":"kohonen_prototype_utilities.f90 – KohonenF08","text":"This module defines a class for kohonen prototype (units inside kohonen layers) This file depends on sourcefile~~kohonen_prototype_utilities.f90~~EfferentGraph sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_prototype_utilities.f90~~AfferentGraph sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !!  This module defines a class for kohonen prototype (units inside kohonen layers) module kohonen_prototype_utilities ! use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use distance_base_utilities , only : distance_base ; ! implicit none ! private ; ! type kohonen_prototype !!   Class to store a prototype inside a Kohonen map private real ( kind = wp ), allocatable :: data_ (:,:) integer :: number_rows , number_columns contains ! procedure :: create => kohonen_prototype_constructor procedure :: destroy => kohonen_prototype_destructor procedure :: get_prototype => kohonen_prototype_accessor procedure :: set_prototype => kohonen_prototype_mutator procedure :: print => kohonen_prototype_print procedure :: distance => kohonen_prototype_distance procedure :: get_nrow => kohonen_prototype_nrow procedure :: get_ncol => kohonen_prototype_ncol ! end type kohonen_prototype ! public :: kohonen_prototype ; ! contains !****f* kohonen_prototype_utilities/kohonen_prototype_constructor !  NAME !    kohonen_prototype_constructor !  PURPOSE !! Class Constructor !  SYNOPSIS !======================================================================================== subroutine kohonen_prototype_constructor ( prototype , input_data ) !======================================================================================== !! Class Constructor class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object real ( kind = wp ), dimension (:,:) :: input_data !! A real array integer :: ierr character ( len = NUMCHAR ) :: message ! prototype % number_rows = size ( input_data , 1 ); prototype % number_columns = size ( input_data , 2 ); allocate ( prototype % data_ ( prototype % number_rows , prototype % number_columns ), stat = ierr ); prototype % data_ = input_data ; ! end subroutine kohonen_prototype_constructor !======================================================================================== subroutine kohonen_prototype_destructor ( prototype ) !======================================================================================== !! Class Destructor class ( kohonen_prototype ), intent ( inout ) :: prototype !! A `kohonen_prototype` object if ( allocated ( prototype % data_ )) then !           write(*,*) 'Prototype, ',allocated(prototype%data_),size(prototype%data_,1),size(prototype%data_,2) deallocate ( prototype % data_ ); !           write(*,*) 'Prototype release' endif end subroutine kohonen_prototype_destructor !======================================================================================== subroutine kohonen_prototype_accessor ( prototype , d ) !======================================================================================== !! Acccessor class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object real ( kind = wp ), dimension ( prototype % number_rows , prototype % number_columns ) :: d !! A real variable with the value of the prototype if ( allocated ( prototype % data_ )) then !           write(*,*) 'ACCESOR' d = prototype % data_ ; else stop endif ! end subroutine kohonen_prototype_accessor !======================================================================================== subroutine kohonen_prototype_mutator ( prototype , new_data ) !======================================================================================== !! Mutator class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: new_data ! if ( ( size ( new_data , 1 ) == prototype % number_rows ) . and . & ( size ( new_data , 2 ) == prototype % number_columns ) ) then prototype % data_ = new_data ; endif ! end subroutine kohonen_prototype_mutator !======================================================================================== subroutine kohonen_prototype_print ( prototype , unit_ ) !======================================================================================== !!  Function to print a kohonen prototype class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object integer , intent ( inout ), optional :: unit_ !! An integer variable with the number of the unit integer :: ix , iy ! if ( present ( unit_ )) then write ( unit_ , * ) 'Prototype' if ( size ( prototype % data_ , 2 ) /= 1 ) then do ix = 1 , size ( prototype % data_ , 1 ) write ( unit_ , * ) ( prototype % data_ ( ix , iy ), iy = 1 , size ( prototype % data_ , 2 )); enddo !ix else write ( unit_ , * ) ( prototype % data_ ( ix , 1 ), ix = 1 , size ( prototype % data_ , 1 )); endif else write ( * , * ) 'Prototype' , size ( prototype % data_ , 1 ), size ( prototype % data_ , 2 ); do ix = 1 , size ( prototype % data_ , 1 ) write ( * , * ) ( prototype % data_ ( ix , iy ), iy = 1 , size ( prototype % data_ , 2 )); enddo !ix endif ! end subroutine kohonen_prototype_print !======================================================================================== function kohonen_prototype_distance ( prototype , prototype1 , f ) result ( d ) !======================================================================================== !! Function to calculate the distance between two prototypes class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object type ( kohonen_prototype ) :: prototype1 !! A `kohonen_prototype` object class ( distance_base ), allocatable :: f !! real ( kind = wp ) :: d !! A real variable with the distance between prototypes real ( kind = wp ), dimension ( prototype % number_rows , prototype % number_columns ) :: prot1 , prot2 d = 0.0_wp ; call prototype % get_prototype ( prot1 ); call prototype1 % get_prototype ( prot2 ); d = f % calculate ( prot1 , prot2 ); ! end function kohonen_prototype_distance !======================================================================================== function kohonen_prototype_nrow ( prototype ) result ( nr ) !======================================================================================== !! Function to get the number of rows of the prototype class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object integer :: nr !! Integer variable with the number of rows nr = size ( prototype % data_ , 1 ); ! end function kohonen_prototype_nrow !======================================================================================== function kohonen_prototype_ncol ( prototype ) result ( nc ) !======================================================================================== !! Function to get the number of columns of the prototype class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object integer :: nc !! Integer variable with the number of columns nc = size ( prototype % data_ , 2 ); ! end function kohonen_prototype_ncol ! end module kohonen_prototype_utilities","tags":"","loc":"sourcefile\\kohonen_prototype_utilities.f90.html"},{"title":"kohonen_layer_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class that represents a layer in a self-organizing map Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/05/2025 !! version: 0.1 !! This module defines an abstract class that represents a layer in a self-organizing map module kohonen_layer_base_utilities end module kohonen_layer_base_utilities","tags":"","loc":"sourcefile\\kohonen_layer_base_utilities.f90.html"},{"title":"random_number_generator_utilities.f90 – KohonenF08","text":"This module defines the random_number_generator class that is used to generate random numbers \nin several procedures across ATALIB. This file depends on sourcefile~~random_number_generator_utilities.f90~~EfferentGraph sourcefile~random_number_generator_utilities.f90 random_number_generator_utilities.f90 sourcefile~mt19937_64.f90 mt19937_64.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~mt19937_64.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 05/01/2021 !! version: 0.1 !! This module defines the random_number_generator class that is used to generate random numbers !! in several procedures across ATALIB. module random_number_generator_utilities !! This module defines the random_number_generator class that is used to generate random numbers !! in several procedures across ATALIB. use precision_utilities , only : wp , i64 ; use mt19937_64 , only : init_genrand64 , init_by_array64 , genrand64_real3 ; ! implicit none ; ! private ; ! type random_number_generator private !! The random_number_generator class is used to encapsulate a generator or random numbers !! An object of this class is defined through the specification of the random seed or seeds integer ( i64 ) :: seed integer ( i64 ), allocatable :: seed_array (:) contains procedure , private :: create_random_number_grator_single procedure , private :: create_random_number_grator_array generic , public :: create => create_random_number_grator_single , create_random_number_grator_array procedure , public :: destroy => destroy_random_number_grator procedure , public :: generate end type random_number_generator ! public :: random_number_generator ! contains !======================================================================================== subroutine create_random_number_grator_single ( grator , iseed ) !======================================================================================== !! Class Constructor 1 class ( random_number_generator ) :: grator !! A `random_number_generator` object to be defined integer ( i64 ) :: iseed !! An integer value with the seed of the random_number_generator !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: iseed !!        type(random_number_generator) :: my_grator !!        ... !!        iseed=12345; !!        call my_grator%create(iseed); !!        ... !!    end program main grator % seed = iseed ; call init_genrand64 ( grator % seed ); ! end subroutine create_random_number_grator_single !======================================================================================== subroutine create_random_number_grator_array ( grator , iseed ) !======================================================================================== !! Class Destructor 2 class ( random_number_generator ) :: grator !! A `random_number_generator` object to be defined integer ( i64 ), dimension (:), intent ( inout ) :: iseed !! An integer array with the seeds of the random_number_generator !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: i !!        integer,dimension(5) :: iseed !!        type(random_number_generator) :: my_grator !!        ... !!        do i=1,5 !!            iseed(i)=12345+i; !!        enddo !!        call my_grator%create(iseed); !!        ... !!    end program main allocate ( grator % seed_array , source = iseed ); call init_by_array64 ( grator % seed_array ); ! end subroutine create_random_number_grator_array !======================================================================================== subroutine destroy_random_number_grator ( grator ) !======================================================================================== !! Class Destructor class ( random_number_generator ) :: grator !! A `random_number_generator` object to be destroyed !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: iseed !!        type(random_number_generator) :: my_grator !!        ... !!        iseed=12345; !!        call my_grator%create(iseed); !!        ... !!        call my_grator%destroy(); !!        ... !!    end program main grator % seed = 0 ; if ( allocated ( grator % seed_array )) then deallocate ( grator % seed_array ); endif ! end subroutine destroy_random_number_grator !======================================================================================== function generate ( grator ) result ( rn ) !======================================================================================== !! Function used to generate random numbers class ( random_number_generator ) :: grator !! A `random_number_generator` object real ( wp ) :: rn !! A real value with the random number generated !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: iseed !!        real(wp) :: rnum !!        type(random_number_generator) :: my_grator !!        ... !!        iseed=12345; !!        call my_grator%create(iseed); !!        rnum=my_grator%generate(); !!        write(*,*) 'Random number= ',rnum; !!        ... !!    end program main rn = genrand64_real3 (); ! end function generate ! end module random_number_generator_utilities","tags":"","loc":"sourcefile\\random_number_generator_utilities.f90.html"},{"title":"constants_utilities.f90 – KohonenF08","text":"This module defines several numerical constants used in the ATALIB library. These constants \ncan be imported in any module of the library. This module is in constant evolution and new \nconstants are being added to the library. This file depends on sourcefile~~constants_utilities.f90~~EfferentGraph sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~constants_utilities.f90~~AfferentGraph sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 01/24/2020 !! version: 0.1 !! This module defines several numerical constants used in the ATALIB library. These constants !! can be imported in any module of the library. This module is in constant evolution and new !! constants are being added to the library. module constants_utilities ! use precision_utilities , only : wp , EP ; ! implicit none ; ! public ; ! real ( wp ), parameter :: PI = 4.0_wp * atan ( 1.0_wp ); real ( wp ), parameter :: LN2 = log ( 2.0_wp ); ! real ( wp ), parameter :: PIEP = 4.0_EP * atan ( 1.0_EP ) real ( wp ), parameter :: INVPIEP = 0.25_EP / atan ( 1.0_EP ) real ( wp ), parameter :: TWOPIEP = 8.0_EP * atan ( 1.0_EP ) real ( wp ), parameter :: PIOV2EP = 2.0_EP * atan ( 1.0_EP ) real ( EP ), parameter :: PIOV4EP = atan ( 1.0_EP ) complex ( wp ), parameter :: EYE = ( 0.0_wp , 1.0_wp ) complex ( wp ), parameter :: I_ = ( 0.0_wp , 1.0_wp ) real ( wp ), parameter :: E = exp ( 1.0_EP ) real ( wp ), parameter :: SQRT2 = sqrt ( 2.0_EP ) real ( wp ), parameter :: UNEST =- 99 9.999999_EP real ( wp ), parameter :: EPSILON = 1.0d-10 real ( wp ), parameter :: TOLERANCE = 1.0d-6 real ( wp ), parameter :: DEG2RAD = PI / 18 0.0_wp ! ! length of filenames ! integer , parameter :: NUMCHAR = 128 ; integer , parameter :: MAXNST = 10 ; end module constants_utilities","tags":"","loc":"sourcefile\\constants_utilities.f90.html"},{"title":"factory_distance_utilities.f90 – KohonenF08","text":"This module defines a factory to create distance objects This file depends on sourcefile~~factory_distance_utilities.f90~~EfferentGraph sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~factory_distance_utilities.f90~~AfferentGraph sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a factory to create distance objects module factory_distance_utilities !! This module defines a factory to create distance objects use distance_base_utilities , only : distance_base ; use euclidean_distance_utilities , only : euclidean_distance ; use manhattan_distance_utilities , only : manhattan_distance ; ! implicit none ; ! type factory_distance !!  Class to represent a distance factory contains procedure , public :: create_distance end type factory_distance ! contains !======================================================================================== subroutine create_distance ( factory , type_ , dist ) !======================================================================================== !! Class constructor class ( factory_distance ) :: factory !! A `factory_distance` object character ( len =* ) :: type_ !! A character string with the type of distance to be instantiated class ( distance_base ), allocatable :: dist !! An allocatable `distance_base` object select case ( trim ( type_ )) case ( 'euclidean' ) !write(*,*) 'Euclidean distance'; if ( allocated ( dist )) deallocate ( dist ); allocate ( euclidean_distance :: dist ); case ( 'manhattan' ) !         !write(*,*) 'Manhattan distance allocated'; if ( allocated ( dist )) deallocate ( dist ); allocate ( manhattan_distance :: dist ); case default write ( * , * ) 'ERROR: the requested distance is not defined' stop end select ! end subroutine create_distance ! end module factory_distance_utilities","tags":"","loc":"sourcefile\\factory_distance_utilities.f90.html"},{"title":"distance_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class called distance_base used as a template to \nderive classes used in the calculation of distances between input patterns This file depends on sourcefile~~distance_base_utilities.f90~~EfferentGraph sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~distance_base_utilities.f90~~AfferentGraph sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines an abstract class called `distance_base` used as a template to !! derive classes used in the calculation of distances between input patterns module distance_base_utilities ! use precision_utilities , only : wp ; !!   This module defines an abstract class to represent an abstract function to calculate distance implicit none ! type , abstract :: distance_base !! Abstract class `distance_base` contains procedure ( distance_function1 ), deferred :: calculate end type distance_base !***** abstract interface !======================================================================================== function distance_function1 ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Template for the calculate function import :: distance_base import :: wp !! Import section class ( distance_base ) :: distance !! A `distance_base` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 !! A real vector real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector2 !! A real vector real ( kind = wp ) :: d !! A real variable with the distance end function distance_function1 ! end interface end module distance_base_utilities","tags":"","loc":"sourcefile\\distance_base_utilities.f90.html"},{"title":"logger_utilities.f90 – KohonenF08","text":"This module includes the definition of a class called logger that is used \nto log messages on the screen during the development or running of a given \napplication This file depends on sourcefile~~logger_utilities.f90~~EfferentGraph sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~logger_utilities.f90~~AfferentGraph sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Arjen Markus, Oscar Garcia-Cabrejo !! date: 06/09/2023 !! version: 0.1 !! This module includes the definition of a class called logger that is used !! to log messages on the screen during the development or running of a given !! application module logger_utilities ! use constants_utilities , only : NUMCHAR ; ! implicit none ; ! private ; ! type logger private !! The Logger class is used to store all the variables related to the units of !! files used to store or print messages during the development (debugging ) or !! running integer :: fileunit , stdout logical :: activate_screen , activate_file , timestamp logical :: initialized , stoponerror character ( len = NUMCHAR ) :: level_string_volume , level_string_chapter , level_string_section character ( len = NUMCHAR ) :: level_string_subsection contains procedure , public :: create => create_logger procedure , public :: destroy => destroy_logger procedure , public :: startup procedure , public :: shutdown procedure , public :: is_initialized procedure , public :: message procedure , public :: write procedure , private :: get_available_unit procedure , private :: configure_logical procedure , private :: configure_integer procedure , private :: configure_character generic , public :: configure => configure_logical , configure_integer , configure_character !        generic,public :: get procedure , public :: get_unit procedure , public :: delimiter procedure , public :: get_delimiter procedure , public :: reset procedure , public :: error end type logger ! type ( logger ) :: global_logger ; ! public :: logger , global_logger ! contains !======================================================================================== subroutine create_logger ( current_log ) !======================================================================================== !! logger constructor class ( logger ) :: current_log !! a logger object current_log % initialized = . FALSE .; current_log % activate_screen = . TRUE .; current_log % activate_file = . TRUE .; current_log % timestamp = . FALSE .; current_log % fileunit = 10 ; current_log % stdout =- 1 ; current_log % stoponerror = . TRUE .; ! end subroutine create_logger !======================================================================================== subroutine destroy_logger ( current_log ) !======================================================================================== !! Logger destructor class ( logger ) :: current_log !! A logger object current_log % level_string_volume = '' current_log % level_string_chapter = '' current_log % level_string_section = '' ! end subroutine destroy_logger !======================================================================================== subroutine startup ( current_log , log_file , append_ ) !======================================================================================== !! Subroutine to initialize a logger object class ( logger ) :: current_log !! A logger object character ( len =* ) :: log_file !! A character variable with the name of the file associated to the logger logical , intent ( in ), optional :: append_ !! A logical (optional) variable to indicate if appending to an existing file !!          is desired ! logical :: append_real ! if ( present ( append_ )) then append_real = append_ ; else append_real = . TRUE .; endif if ( current_log % initialized ) then call current_log % error ( 'Logger not initialized' ); else current_log % fileunit = current_log % get_available_unit (); if ( append_real ) then open ( current_log % fileunit , file = log_file , status = 'unknown' , action = 'write' , position = 'append' ); else open ( current_log % fileunit , file = log_file , status = 'unknown' , action = 'write' ); endif current_log % initialized = . TRUE .; endif ! end subroutine startup !======================================================================================== subroutine shutdown ( current_log ) !======================================================================================== !! Subroutine to turn-off the logger class ( logger ) :: current_log !! A logger object ! current_log % initialized = . FALSE .; ! end subroutine shutdown !======================================================================================== function is_initialized ( current_log ) result ( initialized ) !======================================================================================== !! Function to check if a logger is initialized class ( logger ) :: current_log !! A logger object logical :: initialized !!  A logical variable initialized = current_log % initialized ; ! end function is_initialized !======================================================================================== subroutine reset ( current_log ) !======================================================================================== !! Subroutine to reset the logger class ( logger ) :: current_log !! A logger object current_log % activate_screen = . TRUE .; current_log % activate_file = . TRUE .; current_log % timestamp = . FALSE .; ! end subroutine reset !======================================================================================== subroutine message ( current_log , msg ) !======================================================================================== !! Subroutine to send a message to the logger class ( logger ) :: current_log !! A logger object character ( len =* ) :: msg !! A character variable with the message to send to the logger ! character ( len = NUMCHAR ) :: date_string character ( len = NUMCHAR ) :: time_string character ( len = NUMCHAR ) :: stamp ! if ( current_log % timestamp ) then call date_and_time ( date = date_string , time = time_string ); write ( stamp , '(11A)' ) date_string ( 1 : 4 ), '-' , date_string ( 5 : 6 ), '-' , date_string ( 7 : 8 ), ' ' ,& time_string ( 1 : 2 ), ':' , time_string ( 3 : 4 ), ':' , time_string ( 5 : 6 ); else stamp = ' ' ; endif if ( current_log % activate_screen ) then if ( current_log % timestamp ) then call current_log % write ( current_log % stdout , trim ( stamp ) // ' ' // trim ( msg )); else call current_log % write ( current_log % stdout , trim ( msg )); endif endif if ( current_log % activate_file ) then if ( current_log % timestamp ) then call current_log % write ( current_log % fileunit , trim ( stamp ) // ' ' // trim ( msg )); else call current_log % write ( current_log % fileunit , trim ( msg )); endif endif ! end subroutine message !======================================================================================== subroutine write ( current_log , unit_ , msg ) !======================================================================================== !! Subroutine to write a message in a file associated with the logger class ( logger ) :: current_log !! A logger object integer , intent ( in ) :: unit_ !! An integer variable with the value of the output unit character ( len =* ) :: msg !! A character variable with the message to be written in the output unit character ( len = NUMCHAR ) :: filename integer :: unit1 ! unit1 = unit_ ; if ( unit1 == - 1 ) then write ( * , '(A)' ) trim ( msg ); else write ( unit1 , '(A)' ) trim ( msg ); inquire ( unit1 , name = filename ); close ( unit1 ); open ( unit1 , file = trim ( filename ), action = 'write' , status = 'unknown' , position = 'append' ); endif ! end subroutine write !======================================================================================== function get_available_unit ( current_log ) result ( un ) !======================================================================================== !! Function to get the next available unit class ( logger ) :: current_log !! A logger object integer :: un !! An integer variable with the number of the next available unit ! logical :: check_unit integer :: iunit ! if ( current_log % fileunit /= 10 ) then inquire ( unit = un , opened = check_unit ); if (. not . check_unit ) then un = current_log % fileunit ; return ; endif else do iunit = 10 , 99 inquire ( unit = iunit , opened = check_unit ) if (. not . check_unit ) then un = iunit ; current_log % fileunit = un ; return ; endif enddo endif ! end function get_available_unit !======================================================================================== subroutine configure_logical ( current_log , option , value ) !======================================================================================== !! Subroutine to define the logger state class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: option !! A character variable with the name of the state to be defined logical , intent ( in ) :: value !! A logical variable ! character ( len = NUMCHAR ) :: message ! select case ( option ) case ( \"timestamp\" ) current_log % timestamp = value ; case ( \"writeonstdout\" ) current_log % activate_screen = value ; case ( \"writeonlogfile\" ) current_log % activate_file = value ; case ( \"stoponerror\" ) current_log % stoponerror = value ; case default write ( message , \"(A,A,A,l5,A)\" ) \"Unknown option \" , option , & \" for value \" , value , \" in log_configure_logical\" call current_log % error ( message ); end select ! end subroutine configure_logical !======================================================================================== subroutine configure_integer ( current_log , option , value ) !======================================================================================== !! Subroutine to define a logger integer state class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: option !! A character variable with the name of the state to be defined integer , intent ( in ) :: value !! An integer variable character ( len = NUMCHAR ) :: message ! select case ( option ) case ( \"logfileunit\" ) current_log % fileunit = value case default write ( message , \"(A,A,A,I5,A)\" ) \"Unknown option \" , option , & \" for value \" , value , \" in log_configure_integer\" call current_log % error ( message ); end select ! end subroutine configure_integer !======================================================================================== subroutine configure_character ( current_log , option , value ) !======================================================================================== !! Subroutine to define a logger character state class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: option !! A character variable with the name of the state to be defined character ( len =* ), intent ( in ) :: value !! A character variable character ( len = NUMCHAR ) :: message ! select case ( option ) case ( \"volume\" ) current_log % level_string_volume = value ; case ( \"chapter\" ) current_log % level_string_chapter = value ; case ( \"section\" ) current_log % level_string_section = value ; case ( \"subsection\" ) current_log % level_string_subsection = value ; case default write ( message , \"(A,A,A,A,A)\" ) \"Unknown option \" , option , & \" for value \" , value , \" in log_configure_character\" ; call current_log % error ( message ); end select ! end subroutine configure_character !======================================================================================== subroutine delimiter ( current_log , level ) !======================================================================================== !! Subroutine that defines the delimiter in a logger repport class ( logger ) :: current_log !! A logger object character ( len =* ), optional :: level !! A character variable with the definition of the delimiter ! character ( len = NUMCHAR ) :: used_level character ( len = NUMCHAR ) :: msg ! if ( present ( level )) then used_level = level ; else used_level = 'volume' ; endif call current_log % get_delimiter ( used_level , msg ); call current_log % message ( msg ); ! end subroutine delimiter !======================================================================================== subroutine get_delimiter ( current_log , level , msg ) !======================================================================================== !! Subroutine to get the delimiter text integer , parameter :: LOG_LEVEL_DELIMITER_LENGTH = 50 character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_volume = \"==============================\" ; character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_chapter = \"------------------------------\" ; character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_section = \"******************************\" ; character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_subsection = \"++++++++++++++++++++++++++++++\" ; class ( logger ) :: current_log !! A logger object character ( len =* ) :: level !! A character variable character ( len = 100 ) :: msg !! A character variable select case ( level ) case ( 'volume' ) write ( msg , * ) trim ( log_level_string_volume ); case ( 'chapter' ) write ( msg , * ) trim ( log_level_string_chapter ); case ( 'section' ) write ( msg , * ) trim ( log_level_string_section ); case ( 'subsection' ) write ( msg , * ) trim ( log_level_string_subsection ); case default ! NOTE : ! We do not use m_exception here to limit the dependencies of ! such a low level utility. write ( * , * ) \"Bad value for the message level:\" , level write ( * , * ) stop end select ! end subroutine get_delimiter !======================================================================================== function get_unit ( current_log ) result ( logger_unit ) !======================================================================================== !! Function to get the logger unit class ( logger ) :: current_log !! A logger object integer :: logger_unit !! An integer variable with the logger unit logger_unit = current_log % fileunit ! end function get_unit !======================================================================================== subroutine error ( current_log , message ) !======================================================================================== !! Subroutine to print an error message class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: message !! A character varaible with the error message write ( 6 , \"(A)\" ) \"Error in m_logger.\" write ( 6 , \"(A)\" ) trim ( message ) stop ; ! end subroutine error ! end module logger_utilities","tags":"","loc":"sourcefile\\logger_utilities.f90.html"},{"title":"precision_utilities.f90 – KohonenF08","text":"This module defines the precision constants used in all modules of the library. Files dependent on this one sourcefile~~precision_utilities.f90~~AfferentGraph sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~general_utilities.f90 general_utilities.f90 sourcefile~general_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~random_number_generator_utilities.f90 random_number_generator_utilities.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~precision_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/23/2020 !! version: 0.1 !! This module defines the precision constants used in all modules of the library. module precision_utilities ! i8=>int8, i16=>int16, i32=>int32, i64=>int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , int8 , int16 , int32 , int64 , wp => real64 ! implicit none ; ! integer , parameter :: sp = real32 ; !! Single precision integer , parameter :: dp = wp ; !! Double precision integer , parameter :: ep = wp ; !! Extended precision integer , parameter :: i8 = int8 !! Integer (short) integer , parameter :: i16 = int16 !! Integer (short) integer , parameter :: i32 = int32 !! Integer (long) integer , parameter :: i64 = int64 !! Integer (long) end module precision_utilities","tags":"","loc":"sourcefile\\precision_utilities.f90.html"},{"title":"rkiss05_generator_utilities.f90 – KohonenF08","text":"This module includes the definition of a class called rkiss05_generator \nthat is used to generate random numbers with an uniform disitribution\nusing the rkiss approach This file depends on sourcefile~~rkiss05_generator_utilities.f90~~EfferentGraph sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~rkiss05_generator_utilities.f90~~AfferentGraph sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/06/2023 !! version: 0.1 !!  This module includes the definition of a class called rkiss05_generator !!  that is used to generate random numbers with an uniform disitribution !!  using the rkiss approach !! module rkiss05_generator_utilities !!  Define the class rkiss05_generator that represents a random number generator !!  based on the rkiss method use precision_utilities , only : wp ; use random_generator_base_utilities , only : random_generator_base ; ! implicit none ; ! private ; type , extends ( random_generator_base ) :: rkiss05_generator private !! Class to represent a random number generator that implements the rkiss method integer :: seed integer :: x , y , w , z contains !  * constructor procedure , public :: create => create_rkiss05_generator !  * destructor procedure , public :: destroy => destroy_rkiss05_generator !  * generate procedure , public :: generate => generate_rkiss05_generator ! end type rkiss05_generator !***** public :: rkiss05_generator ; ! contains !======================================================================================== subroutine create_rkiss05_generator ( generator , iseed ) !======================================================================================== !! Constructor of the rkiss05_generator class. In this class random seed is assigned to the !! random number generator and the internal state of the corresponding generator  is !! initialized. class ( rkiss05_generator ) :: generator !!  generator: A rkiss05_generator object integer , intent ( in ), optional :: iseed !! iseed: An integer with the seed of the random number generator if ( present ( iseed )) then generator % seed = iseed ; else generator % seed = 12345 ; endif generator % x = iseed ; generator % y = iseed + 1 ; generator % z = iseed + 2 ; generator % w = iseed + 3 ; ! end subroutine create_rkiss05_generator !======================================================================================== subroutine destroy_rkiss05_generator ( generator ) !======================================================================================== !! Destructor of the rkiss05_generator class. In this class, the random seed is set to 0 class ( rkiss05_generator ) :: generator !! generator: A rkiss05_generator object if ( generator % seed > 0 ) then generator % seed = 0 ; endif ! end subroutine destroy_rkiss05_generator !======================================================================================== function generate_rkiss05_generator ( generator ) result ( r ) !======================================================================================== !!  Function used to generate realizations of the random numbers with the rkiss05_generator class. class ( rkiss05_generator ) :: generator !! generator: A rkiss05_generator object real ( kind = wp ), parameter :: am = 4.656612873077392578d-10 ! multiplier 1/2&#94;31 !! Multiplier real ( kind = wp ) :: r !! r: A real variable with the generated random number real ( kind = wp ) :: rkiss05 integer :: kiss !          integer          :: x,y,z,w              ! working variables for the four generators !common /kisscom/x,y,z,w ! generator % x = 69069 * generator % x + 1327217885 generator % y = ieor ( generator % y , ishft ( generator % y , 13 )); generator % y = ieor ( generator % y , ishft ( generator % y , - 17 )); generator % y = ieor ( generator % y , ishft ( generator % y , 5 )) generator % z = 18000 * iand ( generator % z , 65535 ) + ishft ( generator % z , - 16 ) generator % w = 30903 * iand ( generator % w , 65535 ) + ishft ( generator % w , - 16 ) kiss = ishft ( generator % x + generator % y + ishft ( generator % z , 16 ) + generator % w , - 1 ) rkiss05 = kiss * am r = rkiss05 end function generate_rkiss05_generator ! end module rkiss05_generator_utilities","tags":"","loc":"sourcefile\\rkiss05_generator_utilities.f90.html"},{"title":"kohonen_layer_utilities.f90 – KohonenF08","text":"This module defines a class that represents a layer in a self-organizing map This file depends on sourcefile~~kohonen_layer_utilities.f90~~EfferentGraph sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/05/2025 !! version: 0.1 !! This module defines a class that represents a layer in a self-organizing map module kohonen_layer_utilities !! This module defines a class that represents a layer in a self-organizing map use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use random_generator_base_utilities , only : random_generator_base ; use rkiss05_generator_utilities , only : rkiss05_generator ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use kohonen_pattern_utilities , only : kohonen_pattern ; use distance_base_utilities , only : distance_base ; use factory_distance_utilities , only : factory_distance ; !use influence_function_utilities; use quicksort_utilities , only : quicksort ; ! implicit none ; ! end module kohonen_layer_utilities","tags":"","loc":"sourcefile\\kohonen_layer_utilities.f90.html"},{"title":"som_train_variables.f90 – KohonenF08","text":"This file depends on sourcefile~~som_train_variables.f90~~EfferentGraph sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module som_train_variables ! use error_handling , only : error_stop , error_t ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use logger_utilities , only : global_logger ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use self_organizing_map_utilities , only : self_organizing_map ; use kohonen_pattern_utilities , only : kohonen_pattern ; ! implicit none ! type ( self_organizing_map ), save :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: som_parameters type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), allocatable :: distance_matrix (:,:) integer :: ipattern character ( len = NUMCHAR ) :: parfl ! contains ! ! Outputs: !  - neuron indices for each input pattern !  - neuron prototypes !  - neuron hit count !  - distance matrix between neuron prototypes (for clustering) !  - u-matrix ! !============================================================================== subroutine initialize_variables ( par_file ) !============================================================================== character ( len =* ) :: par_file ! integer :: idata , ipattern , ivar , ierr , number_variables , i , j , ipar , toroidal integer :: layer_ind , ferr real ( kind = wp ), allocatable :: var (:,:) logical :: testfl , testop character ( len = NUMCHAR ) :: current_line character ( len = NUMCHAR ) :: current_file !integer,allocatable :: column_var(:) character ( len = NUMCHAR ), allocatable :: pattern_files (:) character ( len = NUMCHAR ) :: base_message , message ! idata = 1 ; ipar = 2 ; base_message = \"SOM_TRAIN_VARIABLES ERROR\" ; call global_logger % create (); call global_logger % startup ( 'som_train.log' ); call global_logger % configure ( 'timestamp' ,. true .); call global_logger % delimiter ( 'volume' ); ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then message = trim ( base_message ) // \"The parameter file does not exist\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif open ( ipar , file = trim ( par_file ), status = 'unknown' , access = 'sequential' ,& action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \"while opening \" // trim ( par_file ) // \" file\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'SOM_TRAIN_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo read ( ipar , * ) som_parameters ( 1 )% train_option write ( * , * ) 'Train option= ' , som_parameters ( 1 )% train_option read ( ipar , '(A40)' ) som_parameters ( 1 )% pattern_file write ( * , * ) 'Pattern file= ' , trim ( som_parameters ( 1 )% pattern_file ) read ( ipar , * ) som_parameters ( 1 )% number_patterns ; write ( * , * ) 'Number patterns= ' , som_parameters ( 1 )% number_patterns ; read ( ipar , * ) som_parameters ( 1 )% number_variables1 som_parameters ( 1 )% number_variables2 = 1 ; number_variables = som_parameters ( 1 )% number_variables1 * & som_parameters ( 1 )% number_variables2 ; som_parameters ( 1 )% number_variables = number_variables ; write ( * , * ) 'nvar= ' , som_parameters ( 1 )% number_variables ; allocate ( var ( som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for var array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif allocate ( som_parameters ( 1 )% column_var ( number_variables ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for column_var array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif if ( som_parameters ( 1 )% train_option . eq . 0 ) then if ( number_variables . le . 10 ) then read ( ipar , * ) ( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); write ( * , * ) 'columns= ' ,( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); else read ( ipar , * ) write ( * , * ) 'Columns read' do ivar = 1 , number_variables som_parameters ( 1 )% column_var ( ivar ) = ivar ; enddo write ( * , * ) som_parameters ( 1 )% column_var ( 1 : number_variables ); endif else read ( ipar , * ) endif read ( ipar , '(A40)' ) som_parameters ( 1 )% som_type write ( * , * ) 'SOM type= ' , trim ( som_parameters ( 1 )% som_type ); read ( ipar , * ) som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz read ( ipar , * ) som_parameters ( 1 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 1 )% number_epochs read ( ipar , * ) som_parameters ( 1 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 1 )% learning_rate read ( ipar , * ) som_parameters ( 1 )% random_seed_ write ( * , * ) 'random seed= ' , som_parameters ( 1 )% random_seed_ read ( ipar , '(A40)' ) som_parameters ( 1 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 1 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 1 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 1 )% neighborhood_type ) read ( ipar , * ) som_parameters ( 1 )% debug_level write ( * , * ) 'debug level= ' , som_parameters ( 1 )% debug_level read ( ipar , '(A40)' ) som_parameters ( 1 )% debug_file write ( * , * ) 'debug file= ' , trim ( som_parameters ( 1 )% debug_file ); read ( ipar , '(A40)' ) som_parameters ( 1 )% output_file write ( * , * ) 'output file base= ' , trim ( som_parameters ( 1 )% output_file ) read ( ipar , * ) toroidal write ( * , * ) 'Toroidal grid= ' , toroidal if ( toroidal . eq . 1 ) then som_parameters ( 1 )% toroidal_grid = . true .; else som_parameters ( 1 )% toroidal_grid = . false .; endif write ( * , * ) 'Reading parameter file...finished' close ( ipar ) ! inquire ( file = trim ( som_parameters ( 1 )% pattern_file ), exist = testfl ) if (. not . testfl ) then message = trim ( base_message ) // 'the file ' // trim ( som_parameters ( 1 )% pattern_file ) // ' does not exist' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif ! som_parameters ( 1 )% idbg = 10 ; !debugging som_parameters ( 1 )% iout = 11 ; !output som_parameters ( 1 )% iindex = 12 ; !SOM output by index som_parameters ( 1 )% iprot = 13 ; !SOM prototpyes som_parameters ( 1 )% ihit = 14 ; !SOM neuron_hit som_parameters ( 1 )% idist = 15 ; !neuron_distances som_parameters ( 1 )% iumat = 16 ; ! umatrix som_parameters ( 1 )% ipar = 17 ; som_parameters ( 1 )% isam = 18 ; ! som_parameters ( 1 )% idisto = 19 ; !save distortion ! !   call random_seed ! allocate ( input_patterns ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for input_patterns array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif if ( som_parameters ( 1 )% train_option . eq . 0 ) then ! write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // \" file\" ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' elseif ( som_parameters ( 1 )% train_option . eq . 1 ) then allocate ( pattern_files ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for pattern_files array\" ; call error_stop ( message ); endif write ( * , * ) 'Reading pattern files...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // \" file\" ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , '(A)' , err = 90 ) pattern_files ( ipattern ); enddo !ipattern write ( * , * ) 'Reading pattern files...finished!' ; ! write ( * , * ) 'Reading patterns...' ; do ipattern = 1 , som_parameters ( 1 )% number_patterns inquire ( file = trim ( pattern_files ( ipattern )), exist = testfl ); if (. not . testfl ) then message = trim ( base_message ) // \"the file \" // trim ( pattern_files ( ipattern )) // ' does not exist' ; call error_stop ( message ); endif write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )); open ( idata , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' ,& access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( pattern_files ( ipattern )) // ' file' ; call error_stop ( message ); endif do i = 1 , size ( var , 1 ) read ( idata , * , err = 91 ) ( var ( i , j ), j = 1 , size ( var , 2 )); enddo !ix close ( idata ); write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )), ' finished' ; call input_patterns ( ipattern )% create ( var ); enddo !ipattern write ( * , * ) 'Reading patterns...finished!' ; ! elseif ( som_parameters ( 1 )% train_option . eq . 2 ) then write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // ' file' ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' ! write ( * , * ) 'Reading distance matrix....' ; allocate ( distance_matrix ( som_parameters ( 1 )% number_patterns , som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for distance_matrix array\" ; call error_stop ( message ); endif open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // ' file' ; call error_stop ( message ); endif do i = 1 , som_parameters ( 1 )% number_patterns read ( idata , * ) ( distance_matrix ( i , j ), j = 1 , som_parameters ( 1 )% number_patterns ); enddo write ( * , * ) 'Reading distance matrix....finished!' ; endif ! if ( som_parameters ( 1 )% debug_level . gt . 0 ) then open ( som_parameters ( 1 )% idbg , file = trim ( som_parameters ( 1 )% debug_file ),& status = 'unknown' , access = 'sequential' , action = 'write' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% debug_file ) // ' file' ; call error_stop ( message ); endif endif ! if ( som_parameters ( 1 )% train_option < 3 ) then write ( * , * ) 'Opening output files...' ; ! parameter file current_file = trim ( som_parameters ( 1 )% output_file ) // '_parameters.som' ; open ( som_parameters ( 1 )% ipar , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_parameter.som file' ; call error_stop ( message ); endif layer_ind = 1 ; call som_parameters ( 1 )% print ( layer_ind , som_parameters ( 1 )% ipar ); close ( som_parameters ( 1 )% ipar ) ! neuron indices current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out' ; open ( som_parameters ( 1 )% iindex , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out file' ; call error_stop ( message ); endif !   write(som_parameters(1)%iindex,'(A)') 'KOHONEN MAP PATTERN INDICES' !   write(som_parameters(1)%iindex,'(A17,1X,2I6)') 'Number Patterns= ',& !         som_parameters(1)%number_patterns,3; write ( som_parameters ( 1 )% iindex , '(A22)' ) 'PatternNumber ix iy iz' ! neuron prototypes current_file = trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out' ; open ( som_parameters ( 1 )% iprot , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% iprot , '(A)' ) 'KOHONEN MAP PROTOTYPES' write ( som_parameters ( 1 )% iprot , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( som_parameters ( 1 )% iprot , '(A21,1X,2I6)' ) 'number of variables= ' ,& som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 !rectangular !hexagonal write ( som_parameters ( 1 )% iprot , '(A25,1X,A11,1X,L4)' ) 'node_type,toroidal_grid= ' ,& trim ( som_parameters ( 1 )% node_type ), som_parameters ( 1 )% toroidal_grid ! neuron hit current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_hit.out' ; open ( som_parameters ( 1 )% ihit , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_hits.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% ihit , '(A)' ) 'KOHONEN MAP NEURON HITS' write ( som_parameters ( 1 )% ihit , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! neuron distances current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out' ; open ( som_parameters ( 1 )% idist , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% idist , '(A)' ) 'KOHONEN MAP DISTANCE MATRIX' write ( som_parameters ( 1 )% idist , '(A17,1X,2I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ! u-matrix current_file = trim ( som_parameters ( 1 )% output_file ) // '_u-matrix.out' ; open ( som_parameters ( 1 )% iumat , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_u_matrix.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% iumat , '(A)' ) 'KOHONEN MAP U-MATRIX' write ( som_parameters ( 1 )% iumat , '(A17,1X,3I6)' ) 'number of nodes= ' ,& 2 * som_parameters ( 1 )% number_nodes_nx - 1 , 2 * som_parameters ( 1 )% number_nodes_ny - 1 ,& 2 * som_parameters ( 1 )% number_nodes_nz - 1 ! map_samples current_file = trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out' ; open ( som_parameters ( 1 )% isam , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% isam , '(A)' ) 'KOHONEN MAP SAMPLE LOCATION' write ( som_parameters ( 1 )% isam , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! SOM distortion current_file = trim ( som_parameters ( 1 )% output_file ) // '_distortion.out' ; open ( som_parameters ( 1 )% idisto , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_distortion.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% idisto , '(A)' ) 'KOHONEN MAP DISTORTION' ! write ( * , * ) 'Opening output files...finished!!!' ; endif ! deallocate ( var ); return ! 90 stop 'ERROR while reading pattern file' 91 stop 'ERROR while reading pattern sample file' ! end subroutine initialize_variables !============================================================================== subroutine release_variables () !============================================================================== integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( distance_matrix )) then deallocate ( distance_matrix ); endif ! if ( allocated ( som_parameters ( 1 )% column_var )) then deallocate ( som_parameters ( 1 )% column_var ) endif ! inquire ( unit = som_parameters ( 1 )% iindex , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iindex ); endif ! inquire ( unit = som_parameters ( 1 )% iprot , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iprot ); endif ! inquire ( unit = som_parameters ( 1 )% ihit , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% ihit ); endif ! inquire ( unit = som_parameters ( 1 )% idist , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idist ); endif ! inquire ( unit = som_parameters ( 1 )% iumat , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iumat ); endif ! inquire ( unit = som_parameters ( 1 )% isam , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% isam ); endif ! inquire ( file = trim ( som_parameters ( 1 )% debug_file ), opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idbg ); endif ! inquire ( unit = som_parameters ( 1 )% idisto , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idisto ); endif ! call global_logger % shutdown (); call global_logger % destroy (); ! end subroutine release_variables ! end module som_train_variables","tags":"","loc":"sourcefile\\som_train_variables.f90.html"},{"title":"quicksort_utilities.f90 – KohonenF08","text":"This module includes the definition of a class called quicksort\nthat is used to encapsulate the quicksorting algorithm. This \nalgorithm is highly efficient. This file depends on sourcefile~~quicksort_utilities.f90~~EfferentGraph sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~quicksort_utilities.f90~~AfferentGraph sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/10/2023 !! version: 0.1 !!  This module includes the definition of a class called quicksort !!  that is used to encapsulate the quicksorting algorithm. This !!  algorithm is highly efficient. module quicksort_utilities ! use precision_utilities , only : wp ; use sort_base_utilities , only : sort_base ; ! implicit none ; ! private ; ! type , extends ( sort_base ) :: quicksort !!  class that encapsulates the quicksort algorithm contains procedure , pass :: sort => quick_sort end type quicksort ! public :: quicksort ; ! contains !=============================================================================================================== recursive subroutine quick_sort ( my_sort , list , order ) !=============================================================================================================== !! main subroutine of the quick sort algorithm. implicit none class ( quicksort ), intent ( inout ) :: my_sort !! A quicksort object real ( kind = wp ), dimension (:), intent ( inout ) :: list !! A real vector with the values to be sorted. integer , dimension (:), intent ( inout ) :: order !! An integer vector with the positions of the ordered samples. !! quick sort routine from: !! brainerd, w.s., goldberg, c.h. & adams, j.c. (1990) \"programmer's guide to !! fortran 90\", mcgraw-hill  isbn 0-07-000248-7, pages 149-150. !! modified by alan miller to include an associated integer array which gives !! the positions of the elements in the original order. ! local variable integer :: i !write(*,*) size(list) do i = 1 , size ( list ) order ( i ) = i end do call quick_sort_1 ( 1 , size ( list )) contains recursive subroutine quick_sort_1 ( left_end , right_end ) integer , intent ( in ) :: left_end , right_end !***** !     local variables integer :: i , j , itemp real ( kind = wp ) :: reference , temp integer , parameter :: max_simple_sort_size = 6 if ( right_end < left_end + max_simple_sort_size ) then ! use interchange sort for small lists call interchange_sort ( left_end , right_end ) else ! use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 do ! scan list from left end until element >= reference is found do i = i + 1 if ( list ( i ) >= reference ) exit end do ! scan list from right end until element <= reference is found do j = j - 1 if ( list ( j ) <= reference ) exit end do if ( i < j ) then ! swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp else if ( i == j ) then i = i + 1 exit else exit end if end do if ( left_end < j ) call quick_sort_1 ( left_end , j ) if ( i < right_end ) call quick_sort_1 ( i , right_end ) end if end subroutine quick_sort_1 !=============================================================================================================== subroutine interchange_sort ( left_end , right_end ) !=============================================================================================================== !! subroutine to interchange elements integer , intent ( in ) :: left_end , right_end !! left_end, right_end: integer variables with the positiions to be interchanged !     local variables integer :: i , j , itemp real ( kind = wp ) :: temp do i = left_end , right_end - 1 do j = i + 1 , right_end if ( list ( i ) > list ( j )) then temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp end if end do end do end subroutine interchange_sort ! end subroutine quick_sort ! end module quicksort_utilities","tags":"","loc":"sourcefile\\quicksort_utilities.f90.html"},{"title":"sort_base_utilities.f90 – KohonenF08","text":"Define an abstract class to represent a generic sort procedure. This file depends on sourcefile~~sort_base_utilities.f90~~EfferentGraph sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~sort_base_utilities.f90~~AfferentGraph sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/10/2023 !! version: 0.1 !!  Define an abstract class to represent a generic sort procedure. module sort_base_utilities ! use precision_utilities , only : wp ; ! implicit none ; ! type , abstract :: sort_base !! Abstract class to represent a generic sort algoritm contains ! METHODS !   * sort procedure ( sort_procedure ), deferred , pass :: sort end type sort_base ! abstract interface !=============================================================================================================== subroutine sort_procedure ( my_sort , list , order ) !=============================================================================================================== !! Subroutine to sort an array import :: sort_base import :: wp !! import sort_base class ( sort_base ), intent ( inout ) :: my_sort !! my_sort: A sort_base object real ( kind = wp ), dimension (:), intent ( inout ) :: list !! list: A real vector integer , dimension (:), intent ( inout ) :: order !! order: An integer vector end subroutine sort_procedure ! end interface ! end module sort_base_utilities","tags":"","loc":"sourcefile\\sort_base_utilities.f90.html"},{"title":"mt19937_64.f90 – KohonenF08","text":"This is a Fortran translation of the 64-bit version of\n   the Mersenne Twister pseudorandom number generator Before using, initialize the state by using\n       call init_genrand64(seed)\n   or\n       call init_by_array64(init_key) Translated from C-program for MT19937-64 (2004/9/29 version)\n   originally coded by Takuji Nishimura and Makoto Matsumoto\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html Fortran translation by Rémi Piatek\n   The University of Copenhagen\n   Department of Economics\n   email: {first}.{last}@econ.ku.dk A C-program for MT19937-64 (2004/9/29 version).\n   Coded by Takuji Nishimura and Makoto Matsumoto. This is a 64-bit version of Mersenne Twister pseudorandom number\n   generator. Before using, initialize the state by using init_genrand64(seed) or init_by_array64(init_key, key_length). Copyright (C) 2004, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved. Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met: 1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n 3. The names of its contributors may not be used to endorse or promote \n    products derived from this software without specific prior written \n    permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER\n   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. References:\n   T. Nishimura, Tables of 64-bit Mersenne Twisters''\n     ACM Transactions on Modeling and \n     Computer Simulation 10. (2000) 348--357.\n   M. Matsumoto and T. Nishimura, Mersenne Twister: a 623-dimensionally equidistributed\n       uniform pseudorandom number generator''\n     ACM Transactions on Modeling and \n     Computer Simulation 8. (Jan. 1998) 3--30. Any feedback is very welcome.\n   http://www.math.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove spaces) Files dependent on this one sourcefile~~mt19937_64.f90~~AfferentGraph sourcefile~mt19937_64.f90 mt19937_64.f90 sourcefile~random_number_generator_utilities.f90 random_number_generator_utilities.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~mt19937_64.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!------------------------------------------------------------------------------- !!   This is a Fortran translation of the 64-bit version of !!   the Mersenne Twister pseudorandom number generator !! !!   Before using, initialize the state by using !!       call init_genrand64(seed) !!   or !!       call init_by_array64(init_key) !! !!   Translated from C-program for MT19937-64 (2004/9/29 version) !!   originally coded by Takuji Nishimura and Makoto Matsumoto !!   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html !! !!   Fortran translation by Rémi Piatek !!   The University of Copenhagen !!   Department of Economics !!   email: {first}.{last}@econ.ku.dk !! !!------------------------------------------------------------------------------- !!   A C-program for MT19937-64 (2004/9/29 version). !!   Coded by Takuji Nishimura and Makoto Matsumoto. !! !!   This is a 64-bit version of Mersenne Twister pseudorandom number !!   generator. !! !!   Before using, initialize the state by using init_genrand64(seed) !!   or init_by_array64(init_key, key_length). !! !!   Copyright (C) 2004, Makoto Matsumoto and Takuji Nishimura, !!   All rights reserved. !! !!   Redistribution and use in source and binary forms, with or without !!   modification, are permitted provided that the following conditions !!   are met: !! !!     1. Redistributions of source code must retain the above copyright !!        notice, this list of conditions and the following disclaimer. !! !!     2. Redistributions in binary form must reproduce the above copyright !!        notice, this list of conditions and the following disclaimer in the !!        documentation and/or other materials provided with the distribution. !! !!     3. The names of its contributors may not be used to endorse or promote !!        products derived from this software without specific prior written !!        permission. !! !!   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS !!   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT !!   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR !!   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER !!   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, !!   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, !!   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR !!   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF !!   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING !!   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !!   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !! !!   References: !!   T. Nishimura, ``Tables of 64-bit Mersenne Twisters'' !!     ACM Transactions on Modeling and !!     Computer Simulation 10. (2000) 348--357. !!   M. Matsumoto and T. Nishimura, !!     ``Mersenne Twister: a 623-dimensionally equidistributed !!       uniform pseudorandom number generator'' !!     ACM Transactions on Modeling and !!     Computer Simulation 8. (Jan. 1998) 3--30. !! !!   Any feedback is very welcome. !!   http://www.math.hiroshima-u.ac.jp/~m-mat/MT/emt.html !!   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove spaces) !------------------------------------------------------------------------------- module mt19937_64 use , intrinsic :: iso_fortran_env implicit none private public :: init_genrand64 public :: init_by_array64 public :: genrand64_real1 public :: genrand64_real2 public :: genrand64_real3 !! NOTE: genrand64_int64 is kept private, as it generates different numbers !!       compared to the original C code. This is because the original C code !!       uses unsigned integers, while Fortran relies on signed integers. !!       This, however, has no impact on the generation of real numbers !!       (they are identical to those produced by the original C code). integer , parameter :: r64 = real64 integer , parameter :: i64 = int64 integer ( i64 ), parameter :: nn = 312_i64 integer ( i64 ), parameter :: mm = 156_i64 integer ( i64 ), parameter :: seed_def = 5489_i64 integer ( i64 ), parameter :: matrix_a = - 5403634167711393303_i64 integer ( i64 ), parameter :: um = - 2147483648_i64 ! most significant 33 bits integer ( i64 ), parameter :: lm = 2147483647_i64 ! least significant 31 bits real ( r64 ), parameter :: pi253_1 = 1._r64 / ( 2._r64 ** 53 - 1._r64 ) real ( r64 ), parameter :: pi253 = 1._r64 / ( 2._r64 ** 53 ) real ( r64 ), parameter :: pi252 = 1._r64 / ( 2._r64 ** 52 ) integer ( i64 ) :: mt ( nn ) ! array for the state vector integer :: mti = nn + 1 ! mti==nn+1 means mt(nn) is not initialized contains !----------------------------------------------------------------------------- ! Initializes mt(nn) with a seed subroutine init_genrand64 ( seed ) !! Initializes mt(nn) with a seed implicit none integer ( i64 ), intent ( in ) :: seed integer :: i mt ( 1 ) = seed do i = 1 , nn - 1 mt ( i + 1 ) = 6364136223846793005_i64 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 )) + i end do mti = nn end subroutine init_genrand64 !----------------------------------------------------------------------------- ! Initializes by an array with array-length !   init_key is the array for initializing keys subroutine init_by_array64 ( init_key ) !! Initializes by an array with array-length !!   init_key is the array for initializing keys implicit none integer ( i64 ), intent ( in ) :: init_key (:) integer ( i64 ), parameter :: c1 = 3935559000370003845_i64 integer ( i64 ), parameter :: c2 = 2862933555777941757_i64 integer ( i64 ) :: i , j , k , kk , key_length call init_genrand64 ( 19650218_i64 ) key_length = size ( init_key ) i = 1_i64 ; j = 0_i64 k = max ( nn , key_length ) do kk = 1 , k mt ( i + 1 ) = ieor ( mt ( i + 1 ), c1 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) & + init_key ( j + 1 ) + j i = i + 1 ; j = j + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if if ( j >= key_length ) j = 0 end do do kk = 1 , nn - 1 mt ( i + 1 ) = ieor ( mt ( i + 1 ), c2 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) - i i = i + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if end do mt ( 1 ) = ishft ( 1_i64 , 63 ) ! MSB is 1; assuring non-zero initial array end subroutine init_by_array64 !----------------------------------------------------------------------------- ! Generates a random number on [-2&#94;63, 2&#94;63-1]-interval integer ( r64 ) function genrand64_int64 () !! Generates a random number on [-2&#94;63, 2&#94;63-1]-interval implicit none integer ( i64 ) :: mag01 ( 0 : 1 ) = ( / 0_i64 , matrix_a / ) integer ( i64 ) :: x integer :: i if ( mti >= nn ) then ! generate nn words at one time ! if init_genrand64() has not been called, a default initial seed is used if ( mti == nn + 1 ) call init_genrand64 ( seed_def ) do i = 1 , nn - mm x = ior ( iand ( mt ( i ), um ), iand ( mt ( i + 1 ), lm )) mt ( i ) = ieor ( ieor ( mt ( i + mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i64 ))) end do do i = nn - mm + 1 , nn - 1 x = ior ( iand ( mt ( i ), um ), iand ( mt ( i + 1 ), lm )) mt ( i ) = ieor ( ieor ( mt ( i + mm - nn ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i64 ))) end do x = ior ( iand ( mt ( nn ), um ), iand ( mt ( 1 ), lm )) mt ( nn ) = ieor ( ieor ( mt ( mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i64 ))) mti = 0 end if mti = mti + 1 x = mt ( mti ) x = ieor ( x , iand ( ishft ( x , - 29 ), 6148914691236517205_i64 )) x = ieor ( x , iand ( ishft ( x , 17 ), 8202884508482404352_i64 )) x = ieor ( x , iand ( ishft ( x , 37 ), - 2270628950310912_i64 )) x = ieor ( x , ishft ( x , - 43 )) genrand64_int64 = x end function genrand64_int64 !----------------------------------------------------------------------------- ! Generates a random number on [0,1]-real-interval real ( r64 ) function genrand64_real1 () !! Generates a random number on [0,1]-real-interval implicit none genrand64_real1 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253_1 end function genrand64_real1 !----------------------------------------------------------------------------- ! Generates a random number on [0,1)-real-interval real ( r64 ) function genrand64_real2 () !! Generates a random number on [0,1)-real-interval implicit none genrand64_real2 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253 end function genrand64_real2 !----------------------------------------------------------------------------- ! Generates a random number on (0,1)-real-interval real ( r64 ) function genrand64_real3 () !! Generates a random number on (0,1)-real-interval implicit none genrand64_real3 = real ( ishft ( genrand64_int64 (), - 12 ), kind = r64 ) genrand64_real3 = ( genrand64_real3 + 0.5_r64 ) * pi252 end function genrand64_real3 end module mt19937_64","tags":"","loc":"sourcefile\\mt19937_64.f90.html"},{"title":"kohonen_layer_parameters_utilities.f90 – KohonenF08","text":"This file depends on sourcefile~~kohonen_layer_parameters_utilities.f90~~EfferentGraph sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_layer_parameters_utilities.f90~~AfferentGraph sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module kohonen_layer_parameters_utilities ! use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use tomlf , only : toml_table ; implicit none ! private ! type kohonen_layer_parameters integer :: train_option ! integer :: number_nodes_nx , number_nodes_ny , number_nodes_nz , number_patterns integer :: number_variables1 , number_variables2 , number_variables integer , allocatable :: column_var (:) integer :: number_epochs , debug_level !number_clusters, integer , dimension ( 1 ) :: random_seed_ real ( kind = wp ) :: learning_rate character ( len = NUMCHAR ) :: node_type !rectangular, hexagonal character ( len = NUMCHAR ) :: debug_file , pattern_file , output_file character ( len = NUMCHAR ) :: distance_type !euclidean, manhattan, correlation, correlation2 character ( len = NUMCHAR ) :: neighborhood_type !gaussian,bubble character ( len = NUMCHAR ) :: som_type !normal_som,visom,robust_som character ( len = NUMCHAR ) :: m_estimator !name of the M-estimator to be used logical :: toroidal_grid ! UNITS FOR TRAINING OUTPUT integer :: idbg , iout , iindex , iprot , ihit , idist , iumat , ipar , isam , iclus , icen , iclus1 , idisto ! UNITS FOR ESTIMATION OUTPUT integer :: iout1 , imeas logical :: view_flag ! FLAG FOR DEBUGGING REALIZATION integer :: ireal ! contains procedure , public :: print => print_parameters procedure , public :: read_parameters procedure , public :: read_parameters_toml !generic,public :: read => read_parameters, read_parameters_toml end type kohonen_layer_parameters public :: kohonen_layer_parameters ! contains !============================================================================== subroutine print_parameters ( parameters , layer_ind , unit_ ) !============================================================================== class ( kohonen_layer_parameters ) :: parameters integer , intent ( inout ) :: layer_ind integer , intent ( inout ), optional :: unit_ ! integer :: unit1 , j , toroidal character ( len = NUMCHAR ) :: current_line ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif write ( unit1 , '(A)' ) adjustl ( 'Kohonen Map Parameters' ); write ( unit1 , '(A)' ) adjustl ( 'SOM_TRAIN_PARAMETERS' ) write ( current_line , '(I5)' ) parameters % train_option write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Train option' ; if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % pattern_file ), '!Pattern file' ; endif write ( current_line , '(I5)' ) parameters % number_patterns write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number Patterns' ; write ( current_line , '(2I5)' ) parameters % number_variables1 , parameters % number_variables2 write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number Variables1,Number Variables2' ; if ( parameters % number_variables . le . 10 ) then write ( current_line , '(10I4)' ) ( parameters % column_var ( j ), j = 1 , parameters % number_variables ) else write ( current_line , '(4I4)' ) - 1 , - 1 , - 1 , - 1 endif write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Columns' if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % som_type ), '!SOM type' endif write ( current_line , '(3I5)' ) parameters % number_nodes_nx ,& parameters % number_nodes_ny ,& parameters % number_nodes_nz write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number nodes x, Number nodes y, Number nodes z' write ( current_line , '(I6)' ) parameters % number_epochs write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number epochs' ; write ( current_line , '(f10.5)' ) parameters % learning_rate write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Learning rate' ; write ( current_line , '(I10)' ) parameters % random_seed_ write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Random seed' ; write ( unit1 , '(A40,A)' ) adjustl ( parameters % distance_type ), '!Distance type' ; write ( unit1 , '(A40,A)' ) adjustl ( parameters % node_type ), '!Node type' ; write ( unit1 , '(A40,A)' ) adjustl ( parameters % neighborhood_type ), '!Neigh type' ; write ( current_line , '(I5)' ) parameters % debug_level ; write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Debug level' ; if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % debug_file ), '!Debug file' ; endif if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % output_file ), '!Output file' ; endif if ( parameters % toroidal_grid ) then toroidal = 1 ; else toroidal = 0 ; endif write ( current_line , '(I2)' ) toroidal write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Toroidal grid' ! return ! end subroutine print_parameters !============================================================================== subroutine read_parameters ( parameters , unit_ ) !============================================================================== class ( kohonen_layer_parameters ) :: parameters integer , intent ( inout ), optional :: unit_ ! integer :: unit1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif read ( unit1 , * ) !'Kohonen Map Parameters' read ( unit1 , '(A40)' ) parameters % pattern_file !,'!Pattern file'; read ( unit1 , '(I40)' ) parameters % number_patterns !,'!Number Patterns'; read ( unit1 , '(I40)' ) parameters % number_variables1 !,'!Number Variables1'; read ( unit1 , '(I40)' ) parameters % number_variables2 !,'!Number Variables2'; parameters % number_variables = parameters % number_variables1 * & parameters % number_variables2 !    read(unit1,'(A40)') parameters%output_file!,'!Output file'; !    read(unit1,'(A40)') parameters%debug_file!,'!Debug file'; !    read(unit1,'(I40)') parameters%debug_level!,'!Debug level'; read ( unit1 , '(I40)' ) parameters % number_nodes_nx !,'!Number nodes x'; read ( unit1 , '(I40)' ) parameters % number_nodes_ny !,'!Number nodes y'; read ( unit1 , '(I40)' ) parameters % number_nodes_nz !,'!Number nodes z'; read ( unit1 , '(I40)' ) parameters % number_epochs !,'!Number epochs'; read ( unit1 , * ) parameters % learning_rate !,'!Learning rate'; read ( unit1 , '(I40)' ) parameters % random_seed_ !,'!Random seed'; read ( unit1 , '(A40)' ) parameters % distance_type !,'!Distance type'; read ( unit1 , '(A40)' ) parameters % node_type !,'!Node type'; read ( unit1 , '(A40)' ) parameters % neighborhood_type !,'!Neigh type'; read ( unit1 , '(I40)' ) parameters % debug_level !,'!Debug level'; read ( unit1 , '(A40)' ) parameters % debug_file !,'!Debug file'; read ( unit1 , '(A40)' ) parameters % output_file !,'!Output file'; ! end subroutine read_parameters !======================================================================================== subroutine read_parameters_toml ( parameters , unit_ ) !======================================================================================== class ( kohonen_layer_parameters ) :: parameters integer , intent ( inout ), optional :: unit_ ! Create a subroutine to read a toml file end subroutine read_parameters_toml ! end module kohonen_layer_parameters_utilities","tags":"","loc":"sourcefile\\kohonen_layer_parameters_utilities.f90.html"},{"title":"euclidean_distance_utilities.f90 – KohonenF08","text":"This module defines a class to calculate the Euclidean distance between kohonen prototypes This file depends on sourcefile~~euclidean_distance_utilities.f90~~EfferentGraph sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~euclidean_distance_utilities.f90~~AfferentGraph sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a class to calculate the Euclidean distance between kohonen prototypes module euclidean_distance_utilities !! This module defines a class to calculate the Euclidean distance between kohonen prototypes use precision_utilities , only : wp ; use distance_base_utilities , only : distance_base ; ! implicit none ! type , extends ( distance_base ) :: euclidean_distance !! Class to calculate the euclidean distance contains procedure , public :: calculate => calculate_euclidean_distance ! end type euclidean_distance ! contains !======================================================================================== function calculate_euclidean_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate euclidean distance between vectors class ( euclidean_distance ) :: distance !! A `euclidean_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 !! A real vector real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector2 !! A real vector real ( kind = wp ) :: d !! A real variable with the distance d = sum (( vector1 - vector2 ) ** 2 ); ! end function calculate_euclidean_distance ! end module euclidean_distance_utilities","tags":"","loc":"sourcefile\\euclidean_distance_utilities.f90.html"},{"title":"kohonen_pattern_utilities.f90 – KohonenF08","text":"This module defines a class called kohonen_pattern to store the input patterns This file depends on sourcefile~~kohonen_pattern_utilities.f90~~EfferentGraph sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_pattern_utilities.f90~~AfferentGraph sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a class called `kohonen_pattern` to store the input patterns module kohonen_pattern_utilities !! This module defines a class called `kohonen_pattern` to store the input patterns use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use kohonen_prototype_utilities , only : kohonen_prototype ; ! implicit none ! type kohonen_pattern !!  Class to represent a container for input data to  a kohonen map private type ( kohonen_prototype ) :: pattern character ( len = NUMCHAR ) :: pattern_name contains procedure , public :: create => kohonen_pattern_create procedure , public :: destroy => kohonen_pattern_destroy procedure , public :: get => kohonen_pattern_accessor procedure , public :: set => kohonen_pattern_mutator procedure , public :: print => kohonen_pattern_print procedure , public :: get_nrow => kohonen_pattern_nrow procedure , public :: get_ncol => kohonen_pattern_ncol ! end type kohonen_pattern ! contains !======================================================================================== subroutine kohonen_pattern_create ( current_pattern , input , name ) !======================================================================================== !!   Kohonen pattern constructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input !! A real array character ( len =* ), optional :: name !! A character string with the name of the pattern call current_pattern % pattern % create ( input ); if ( present ( name )) then current_pattern % pattern_name = trim ( name ); else current_pattern % pattern_name = \"\" ; endif ! end subroutine kohonen_pattern_create !======================================================================================== subroutine kohonen_pattern_destroy ( current_pattern ) !======================================================================================== !!   Kohonen pattern destructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object call current_pattern % pattern % destroy (); ! end subroutine kohonen_pattern_destroy !======================================================================================== subroutine kohonen_pattern_accessor ( current_pattern , pattern_value ) !======================================================================================== !! Kohonen pattern accessor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! pattern_value = current_pattern % pattern ; ! end subroutine kohonen_pattern_accessor !======================================================================================== subroutine kohonen_pattern_mutator ( current_pattern , pattern_value ) !======================================================================================== !!   kohonen_pattern_mutator class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! current_pattern % pattern = pattern_value ; ! end subroutine kohonen_pattern_mutator !======================================================================================== subroutine kohonen_pattern_print ( current_pattern , unit_ ) !======================================================================================== !! Subroutine to print a Kohonen pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer , intent ( inout ), optional :: unit_ !! An integer variable with the number of the unit where the patterns will be printed if ( present ( unit_ )) then write ( unit_ , * ) write ( unit_ , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( unit_ , * ) call current_pattern % pattern % print ( unit_ ); else write ( * , * ) write ( * , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( * , * ) call current_pattern % pattern % print (); endif ! end subroutine kohonen_pattern_print !======================================================================================== function kohonen_pattern_nrow ( current_pattern ) result ( nr ) !======================================================================================== !! Function to calculate the number of rows (samples) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nr !! An integer with the number of rows (samples) in a pattern nr = current_pattern % pattern % get_nrow (); ! end function kohonen_pattern_nrow !======================================================================================== function kohonen_pattern_ncol ( current_pattern ) result ( nc ) !======================================================================================== !! Function to calculate the number of columns (variables) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nc !! An integer with the number of columns (variables) in a pattern nc = current_pattern % pattern % get_ncol (); ! end function kohonen_pattern_ncol ! end module kohonen_pattern_utilities","tags":"","loc":"sourcefile\\kohonen_pattern_utilities.f90.html"},{"title":"random_generator_base_utilities.f90 – KohonenF08","text":"Define an abstract class random_generator_base to be used to derive different types of \n random number generators to be use with ATALIB03 This file depends on sourcefile~~random_generator_base_utilities.f90~~EfferentGraph sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~random_generator_base_utilities.f90~~AfferentGraph sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/06/2023 !! version: 0.1 !! Define an abstract class random_generator_base to be used to derive different types of !!  random number generators to be use with ATALIB03 module random_generator_base_utilities ! use precision_utilities , only : wp ; ! implicit none ; ! type , abstract :: random_generator_base !! Abstract class to derive random number generator classes contains !  * constructor procedure ( random_generator_constructor ), deferred :: create !  * destructor procedure ( random_generator_destructor ), deferred :: destroy !  * generate procedure ( random_generator_generate ), deferred :: generate !     procedure(random_generator_initialize),deferred :: initialize end type random_generator_base ! abstract interface !======================================================================================== subroutine random_generator_constructor ( generator , iseed ) !======================================================================================== !! Template of the constructor of the classes derived from the random_generator class. import :: random_generator_base !! random_generator_base class ( random_generator_base ) :: generator !! generator: A random_generator_base object integer , intent ( in ), optional :: iseed !! iseed: An integer with the seed of the random generator. end subroutine random_generator_constructor !======================================================================================== subroutine random_generator_destructor ( generator ) !======================================================================================== !! Template of the destructor of the classes derived from the random_generator class. import :: random_generator_base !! random_generator_base class ( random_generator_base ) :: generator !! generator: A random_generator_base object end subroutine random_generator_destructor !======================================================================================== function random_generator_generate ( generator ) result ( r ) !======================================================================================== !! Template of the function used to generate realizations of the random numbers in the !! classes derived from the random_generator class. import :: random_generator_base import :: wp !! random_generator_base class ( random_generator_base ) :: generator !! generator: A random_generator_base object real ( kind = wp ) :: r !! r: A real number end function random_generator_generate end interface !    ! end module random_generator_base_utilities","tags":"","loc":"sourcefile\\random_generator_base_utilities.f90.html"},{"title":"general_utilities.f90 – KohonenF08","text":"This module includes general purpose functions used in several parts of the library This file depends on sourcefile~~general_utilities.f90~~EfferentGraph sourcefile~general_utilities.f90 general_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~general_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module includes general purpose functions used in several parts of the library module general_utilities !! This module includes general purpose functions used in several parts of the library use precision_utilities , only : wp ; ! implicit none ; ! private ! interface maximum module procedure maximum_only , maximum_position end interface ! public :: minimum , maximum , mean , variance , std public :: coefficient_of_variation ! contains !=================================================================================================== function minimum ( a ) result ( mn ) !=================================================================================================== !! Function to calculate the minimum of an array real ( kind = wp ), dimension (:) :: a !! Real array real ( kind = wp ) :: mn !! Real value with the minimum integer :: i , number_elements mn = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . lt . mn ) then mn = a ( i ) endif enddo ! end function minimum !=================================================================================================== subroutine maximum_only ( a , mx ) !=================================================================================================== !! Subroutine to calculate the maximum of a real array real ( kind = wp ), dimension (:) :: a !! real ( kind = wp ) :: mx !! integer :: i , number_elements mx = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . gt . mx ) then mx = a ( i ) endif enddo ! end subroutine maximum_only !============================================================================================= subroutine maximum_position ( a , mx , p ) !============================================================================================= !! Subroutine to find the position of the maximum value of a real array real ( kind = wp ), dimension (:) :: a !! A real array real ( kind = wp ) :: mx !! A real value with the maximum integer :: p !! An integer value with the position of the maximum integer :: i , number_elements mx = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . gt . mx ) then mx = a ( i ); p = i ; endif enddo ! end subroutine maximum_position !============================================================================================= function mean ( a ) result ( mn ) !============================================================================================= !! Function to calculate the mean of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: mn !! A real value with the calculated mean mn = sum ( a ) / float ( size ( a )); ! end function mean !============================================================================================= function variance ( a ) result ( v ) !============================================================================================= !! Function to calculate the variance of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: v !! A real variable with the calculated variance real ( kind = wp ), dimension ( size ( a )) :: a2 ! a2 = a ** 2 ; v = mean ( a2 ) - ( mean ( a )) ** 2 ; ! end function variance !============================================================================================= function std ( a ) result ( s ) !============================================================================================= !! Function to calculate the standard deviation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: s !! A real variable with the calculated standard deviation real ( kind = wp ) :: v ! v = variance ( a ); s = sqrt ( v ); ! end function std !============================================================================================ function coefficient_of_variation ( a ) result ( cov ) !============================================================================================ !! Function to calculate the coefficient of variation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: cov !! A real variable with the calculated coefficient of variation cov = std ( a ) / mean ( a ); end function coefficient_of_variation ! end module general_utilities","tags":"","loc":"sourcefile\\general_utilities.f90.html"},{"title":"manhattan_distance_utilities.f90 – KohonenF08","text":"This module defines a class to calculate the Manhattan distance between kohonen prototypes This file depends on sourcefile~~manhattan_distance_utilities.f90~~EfferentGraph sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~manhattan_distance_utilities.f90~~AfferentGraph sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a class to calculate the Manhattan distance between kohonen prototypes module manhattan_distance_utilities !! This module defines a class to calculate the Manhattan distance between kohonen prototypes use precision_utilities , only : wp ; use distance_base_utilities , only : distance_base ; ! implicit none ; ! private ; ! type , extends ( distance_base ) :: manhattan_distance !! Class to calculate the Manhattan distance contains procedure , public :: calculate => calculate_manhattan_distance end type manhattan_distance ! public :: manhattan_distance ; ! contains !======================================================================================== function calculate_manhattan_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate the Manhattan distance between vectors class ( manhattan_distance ) :: distance !! A `Manhattan_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 , vector2 !! A real vector real ( kind = wp ) :: d !! A real vector d = sum ( dabs ( vector1 - vector2 )); !! A real variable with the distance end function calculate_manhattan_distance ! end module manhattan_distance_utilities","tags":"","loc":"sourcefile\\manhattan_distance_utilities.f90.html"},{"title":"self_organizing_map_utilities.f90 – KohonenF08","text":"This module defines a class for simple self_organizing_map (one kohonen layer) This file depends on sourcefile~~self_organizing_map_utilities.f90~~EfferentGraph sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~self_organizing_map_utilities.f90~~AfferentGraph sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !!  This module defines a class for simple self_organizing_map (one kohonen layer) module self_organizing_map_utilities !!  This module defines a class for simple self_organizing_map (one kohonen layer) use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use random_generator_base_utilities , only : random_generator_base ; use rkiss05_generator_utilities , only : rkiss05_generator ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use kohonen_pattern_utilities , only : kohonen_pattern ; use distance_base_utilities , only : distance_base ; use factory_distance_utilities , only : factory_distance ; !use influence_function_utilities; use quicksort_utilities , only : quicksort ; ! implicit none ; ! type , extends ( kohonen_map_base ) :: self_organizing_map !!   Class to represent a self_organizing_map private character ( len = NUMCHAR ) :: class_name = 'self_organizing_map' ; type ( kohonen_prototype ), allocatable :: grid (:,:,:) integer , allocatable :: number_patterns (:,:,:), cells_index (:,:) real ( kind = wp ), allocatable :: u_matrix (:,:,:), distance (:,:) real ( kind = wp ), allocatable :: cells_distances (:,:), coordinates (:,:) type ( kohonen_layer_parameters ) :: parameters type ( factory_distance ) :: factory class ( distance_base ), allocatable :: distance_function real ( kind = wp ), allocatable :: distortion (:) type ( rkiss05_generator ) :: rnumber_grator integer :: seed integer , allocatable :: grid_pattern_index (:,:,:), list_node_grid (:,:,:,:) contains procedure , public :: create => create_som procedure , public :: destroy => destroy_som procedure , private :: create_random_sample procedure , private :: train_som_data procedure , public :: train => train_som_data procedure , public :: predict => predict_som procedure , public :: print => print_som procedure , public :: read => read_som procedure , public :: get_count => get_count_som procedure , public :: query => query_som procedure , public :: get_prototypes !procedure,public :: get_index => get_index_som procedure , public :: get_u_matrix => get_u_matrix_som procedure , private :: find_best_match_unit procedure , private :: update_weights !procedure,private :: update_weights1 procedure , private :: find_bmu_grid procedure , private :: calculate_u_matrix procedure , private :: calculate_u_matrix_hexagonal procedure , private :: calculate_u_matrix_rectangular procedure , private :: calculate_sigma procedure , nopass , private :: position2index procedure , nopass , private :: index2position procedure , nopass , private :: calculate_distance_matrix procedure , nopass , private :: calculate_coordinates procedure , private :: calculate_distance_between_prototypes procedure , nopass , public :: external_train_map procedure , nopass , public :: external_predict_map ! end type self_organizing_map ! contains !======================================================================================== subroutine create_som ( kohonen_map , training_parameters ) !======================================================================================== !!   Constructor for self_organizing_map character ( len = NUMCHAR ), parameter :: fname = 'create_som' !! A character variable with the name of the function class ( self_organizing_map ) :: kohonen_map !! A  `self_organizing_map` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` object integer :: ierr , nx , ny , nz , ix , iy , iz , nvar1 , nvar2 , seed , current_index , nepoch integer :: i , j real ( kind = wp ), allocatable :: input (:,:) character ( len = NUMCHAR ) :: base_message , message ! base_message = trim ( kohonen_map % class_name ) // '_' // trim ( fname ) // '_ERROR' ; ! kohonen_map % parameters = training_parameters ( 1 ); nx = training_parameters ( 1 )% number_nodes_nx ; ny = training_parameters ( 1 )% number_nodes_ny ; nz = training_parameters ( 1 )% number_nodes_nz ; nvar1 = training_parameters ( 1 )% number_variables1 ; nvar2 = training_parameters ( 1 )% number_variables2 ; nepoch = training_parameters ( 1 )% number_epochs ; write ( * , * ) 'Create= ' , nx , ny , nz , nvar1 , nvar2 , nepoch ; allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % grid_pattern_index ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid_pattern_index array' ; call error_stop ( message ); endif ! allocate ( input ( nvar1 , nvar2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for input array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % number_patterns ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for number_patterns array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % cells_index ( training_parameters ( 1 )% number_patterns , 3 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for cell_index array' ; call error_stop ( message ); endif ! kohonen_map % number_patterns = 0 ; kohonen_map % cells_index = 0 ; allocate ( kohonen_map % u_matrix ( 2 * nx - 1 , 2 * ny - 1 , 2 * nz - 1 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for u_matrix array' ; call error_stop ( message ); endif kohonen_map % u_matrix = 0.0_wp ; ! allocate ( kohonen_map % distance ( nx * ny , nx * ny ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for distance array' ; call error_stop ( message ); endif kohonen_map % distance = 0.0_wp ; ! allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); kohonen_map % cells_distances = 0.0d0 ; allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); kohonen_map % coordinates = 0.0d0 ; allocate ( kohonen_map % distortion ( nepoch ), stat = ierr ); kohonen_map % distortion = 0.0d0 ; ! call kohonen_map % factory % create_distance ( training_parameters ( 1 )% distance_type ,& kohonen_map % distance_function ); ! kohonen_map % seed = training_parameters ( 1 )% random_seed_ ( 1 ); call kohonen_map % rnumber_grator % create ( kohonen_map % seed ); ! do i=1,nvar1; !     do j=1,nvar2; !         input(i,j)=kohonen_map%rnumber_grator%generate(); !         !write(*,*) 'input= ',input(i,j); !     enddo ! enddo ! write ( * , * ) 'SOM: Initializing grid...' , kohonen_map % seed ; do iz = 1 , nz ; do iy = 1 , ny ; do ix = 1 , nx ; !write(*,*) 'creating ',ix,iy,iz call kohonen_map % create_random_sample ( input ); call kohonen_map % grid ( ix , iy , iz )% create ( input ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , training_parameters ( 1 )% node_type ); enddo !ix enddo !iy enddo !iz deallocate ( input ); ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& training_parameters ( 1 )% node_type , training_parameters ( 1 )% toroidal_grid ); write ( * , * ) 'SOM: Initializing grid...OK' ; ! end subroutine create_som !======================================================================================== subroutine destroy_som ( kohonen_map ) !======================================================================================== !!   Destructor for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: ix , iy , iz ! !       write(*,*) 'SOM: Releasing memory...' if ( allocated ( kohonen_map % grid )) then do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif ! if ( allocated ( kohonen_map % number_patterns )) then deallocate ( kohonen_map % number_patterns ); endif ! if ( allocated ( kohonen_map % cells_index )) then deallocate ( kohonen_map % cells_index ); endif ! if ( allocated ( kohonen_map % u_matrix )) then deallocate ( kohonen_map % u_matrix ); endif ! if ( allocated ( kohonen_map % distance_function )) then deallocate ( kohonen_map % distance_function ); endif ! if ( allocated ( kohonen_map % distance )) then deallocate ( kohonen_map % distance ); endif ! if ( allocated ( kohonen_map % cells_distances )) then deallocate ( kohonen_map % cells_distances ); endif ! if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif ! if ( allocated ( kohonen_map % distortion )) then deallocate ( kohonen_map % distortion ) endif ! if ( allocated ( kohonen_map % grid_pattern_index )) then deallocate ( kohonen_map % grid_pattern_index ); endif ! if ( allocated ( kohonen_map % list_node_grid )) then deallocate ( kohonen_map % list_node_grid ); endif call kohonen_map % rnumber_grator % destroy (); ! !        write(*,*) 'SOM: Releasing memory...OK!' ! end subroutine destroy_som !======================================================================================== subroutine create_random_sample ( kohonen_map , input ) !======================================================================================== !! Subroutine to generate random values that serve as inputs to the SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: input !! A real array with the initial values of the prototypes integer :: nvar1 , nvar2 , i , j ! nvar1 = size ( input , 1 ); nvar2 = size ( input , 2 ); do i = 1 , nvar1 ; do j = 1 , nvar2 ; input ( i , j ) = kohonen_map % rnumber_grator % generate (); end do end do ! end subroutine create_random_sample !======================================================================================== subroutine train_som_data ( kohonen_map , input_data ) !======================================================================================== !!   Training function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: iteration , iepoch , ipattern , ix , iy , iz , jhit , ihit , khit , ineigh , jneigh integer :: kneigh , idbg , number_variables , idisto !neff, integer :: cx , cy , cz , i , j , k , number_nodes , debug_option , ix1 , iy1 , iz1 , pos , pos1 , max_pattern integer :: ierr , nx , ny , nz , ipos integer :: current_pos , ic , itemp real ( kind = wp ) :: distortion , dist , dist_hit , maximum_radius , minimum_radius real ( kind = wp ) :: current_radius , alpha , u_temp type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values integer , allocatable :: pattern_index (:,:,:,:), positions (:) ! ! ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; allocate ( positions ( nx * ny * nz ), stat = ierr ); idbg = kohonen_map % parameters % idbg ; idisto = kohonen_map % parameters % idisto ; debug_option = kohonen_map % parameters % debug_level ; if ( debug_option > 0 ) then open ( idbg , file = trim ( kohonen_map % parameters % debug_file ), status = 'unknown' ); endif iteration = 0 ; distortion = 0.0_wp ; number_variables = kohonen_map % parameters % number_variables1 * kohonen_map % parameters % number_variables2 ; maximum_radius = dble ( max ( kohonen_map % parameters % number_nodes_nx , kohonen_map % parameters % number_nodes_ny )); minimum_radius = 1.0_wp ; write ( * , * ) 'SOM: Training starting...' do iepoch = 1 , kohonen_map % parameters % number_epochs ; kohonen_map % distortion ( iepoch ) = distortion ; write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion ; if ( iepoch > 1 ) write ( idisto , * ) iepoch , distortion distortion = 0.0_wp ; do ipattern = 1 , kohonen_map % parameters % number_patterns ; iteration = iteration + 1 ; ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); call current_prototype % get_prototype ( current_values ); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); !write(*,*) 'Test= ',ipattern,ihit,jhit,khit,dist_hit if ( debug_option > 0 ) then write ( idbg , * ) 'Epoch,Current Pattern' , iepoch , ipattern ; call current_prototype % print ( idbg ); endif distortion = distortion + dist_hit ; if ( debug_option > 0 ) then write ( idbg , * ) 'Neighborhood,alpha= ' , alpha ; endif call kohonen_map % update_weights ( current_values , ihit , jhit , khit , maximum_radius , iteration ); ! enddo !ipattern enddo !iepoch !       write(*,*) 'SOM: Training finished' !       write(*,*) 'Total number of iterations= ',iteration !     print prototypes ! if(kohonen_map%parameters%train_option < 3) then ! do iz=1,size(kohonen_map%grid,3) !    !write(kohonen_map%parameters%iprot,'(A,I4)') 'Layer ',iz !    do iy=1,size(kohonen_map%grid,2); !       do ix=1,size(kohonen_map%grid,1); !          !write(kohonen_map%parameters%iprot,'(A6,1X,3I4)') 'node= ',ix,iy,iz !          call kohonen_map%grid(ix,iy,iz)%print(kohonen_map%parameters%iprot); !       enddo !    enddo ! enddo!ix ! endif !     calculate and print distance matrix call kohonen_map % calculate_distance_between_prototypes (); !     final best match !      call kohonen_map%find_bmu_grid(input_data); max_pattern = 0 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); kohonen_map % number_patterns ( ihit , jhit , khit ) = kohonen_map % number_patterns ( ihit , jhit , khit ) + 1 ; if ( kohonen_map % number_patterns ( ihit , jhit , khit ) > max_pattern ) then max_pattern = kohonen_map % number_patterns ( ihit , jhit , khit ); endif kohonen_map % cells_index ( ipattern , 1 ) = ihit ; kohonen_map % cells_index ( ipattern , 2 ) = jhit ; kohonen_map % cells_index ( ipattern , 3 ) = khit ; if ( debug_option > 0 ) then write ( idbg , * ) ipattern , ihit , jhit , khit ; endif !if(kohonen_map%parameters%train_option < 3) then !   write(kohonen_map%parameters%iindex,*) ipattern,ihit,jhit,khit !endif !         write(*,*) 'BMU= ',ipattern,ihit,jhit,khit,dist_hit ! enddo !ipattern ! allocate ( pattern_index ( size ( kohonen_map % grid , 1 ),& size ( kohonen_map % grid , 2 ), size ( kohonen_map % grid , 3 ),& max_pattern ), stat = ierr ); pattern_index =- 1 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); do i = 1 , max_pattern ; if ( pattern_index ( ix , iy , iz , i ) < 0 ) then pattern_index ( ix , iy , iz , i ) = ipattern ; exit ; endif enddo enddo !ipattern if ( kohonen_map % parameters % train_option < 3 ) then do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % isam , '(A,3I4)' ) 'Node= ' , ix1 , iy1 , iz1 if ( kohonen_map % number_patterns ( ix1 , iy1 , iz1 ) > 0 ) then write ( kohonen_map % parameters % isam , '(A,10000I5)' ) 'Sample ID= ' ,& pattern_index ( ix1 , iy1 , iz1 , 1 : kohonen_map % number_patterns ( ix1 , iy1 , iz1 )); else write ( kohonen_map % parameters % isam , '(A,I4)' ) 'Sample ID= ' , 0 endif enddo enddo enddo deallocate ( pattern_index ); endif ! if ( debug_option . gt . 0 ) then close ( idbg ); endif close ( idisto ); !     print hit counter if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % grid , 3 ) do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % ihit , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % grid , 2 )); enddo !ix enddo endif call kohonen_map % calculate_u_matrix (); ! end subroutine train_som_data !======================================================================================== subroutine predict_som ( kohonen_map , input_data , map_output ) !======================================================================================== !! Function for Prediction of a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer , dimension (:,:), intent ( out ) :: map_output !! An integer array with the map output integer :: ipattern , ihit , jhit , khit , ix , iy , iz , number_variables , i , j , k real ( kind = wp ) :: dist_hit , dist type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values ! number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ; ! !       write(*,*) 'SOM: Prediction starting...'; !       write(*,*) number_variables do ipattern = 1 , size ( input_data , 1 ) ihit = 0 ; jhit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%print(); !write(*,*) ihit,jhit,dist_hit !call current_prototype%get_prototype(current_values); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; !write(*,*) ix,iy,dist !call kohonen_map%grid(ix,iy)%print(); dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo ! !$OMP end parallel do ! call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( current_values ); ! if(size(current_values,2) .eq. 1) then !   write(kohonen_map%parameters%iout,*) (current_values(i,1),& !         i=1,size(current_values,1)); ! else !   do i=1,size(current_values,1) !      write(kohonen_map%parameters%iout,*) (current_values(i,j),j=1,& !            size(current_values,2)) !   enddo ! endif !call map_output(ipattern)%create(current_values); map_output ( ipattern , 1 ) = ihit ; map_output ( ipattern , 2 ) = jhit ; map_output ( ipattern , 3 ) = khit ; !size(current_values,1),size(current_values,2) !write(*,*) current_values enddo !ipattern !       write(*,*) 'SOM: Prediction finished'; ! end subroutine predict_som !======================================================================================== subroutine print_som ( kohonen_map , unit_ ) !======================================================================================== !!   Print function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , intent ( inout ), optional :: unit_ !! integer :: ix , iy , iz , unit1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif write ( unit1 , * ) 'SOM: Results' ; write ( unit1 , * ) call kohonen_map % parameters % print ( unit1 ); ! write(unit1,*) 'After' write ( unit1 , * ) write ( unit1 , * ) 'SOM: Grid nodes' ; write ( unit1 , * ) do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% print ( unit1 ); enddo enddo !iy enddo !ix write ( unit1 , * ) write ( unit1 , * ) 'SOM: Hit count' ; write ( unit1 , * ) write ( unit1 , * ) 'Pattern Numbers' ; do iz = 1 , size ( kohonen_map % number_patterns , 3 ); do ix = 1 , size ( kohonen_map % number_patterns , 1 ); write ( unit1 , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 ,& size ( kohonen_map % number_patterns , 2 )); enddo enddo write ( unit1 , * ) write ( * , * ) 'SOM: Pattern index' write ( unit1 , * ) write ( unit1 , * ) write ( unit1 , * ) 'Pattern #, ix   ,iy' ; do ix = 1 , size ( kohonen_map % cells_index , 1 ); write ( unit1 , '(100I5)' ) ix , ( kohonen_map % cells_index ( ix , iy ),& iy = 1 , size ( kohonen_map % cells_index , 2 )); enddo ! end subroutine print_som !======================================================================================== subroutine get_count_som ( kohonen_map , count_ ) !======================================================================================== !!   Function to get count matrix for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , dimension (:,:,:), intent ( inout ) :: count_ !! count_ = kohonen_map % number_patterns ; ! end subroutine get_count_som !======================================================================================== subroutine query_som ( kohonen_map , input_pattern , sample_index ) !,output_patterns) !======================================================================================== !!   Function to find the input samples associated with specific vector class ( self_organizing_map ) :: kohonen_map !! real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_pattern !! integer , allocatable :: sample_index (:) !! integer :: ix , iy , iz , ihit , jhit , khit , ivar1 , ivar2 , nvar1 , nvar2 , number_patterns , ipat , ierr integer :: number_selected , i , pos real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values real ( kind = wp ) :: dist , dist_min integer , dimension ( size ( kohonen_map % cells_index , 1 )) :: position , real_position ! !(real_position(ix)=ix,ix=1,size(real_position)) do ix = 1 , size ( real_position ) real_position ( ix ) = ix ; enddo nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; dist_min = 1.0d10 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; call kohonen_map % grid ( ix , iy , iz )% get_prototype ( current_values ); do ivar1 = 1 , nvar1 ; do ivar2 = 1 , nvar2 ; if ( input_pattern ( ivar1 , ivar2 ) > 0.0_wp ) then dist = dist + ( input_pattern ( ivar1 , ivar2 ) - current_values ( ivar1 , ivar2 )) ** 2 ; endif enddo enddo if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo !$OMP end parallel do !         write(*,*) 'BMU' !         write(*,*) ihit,jhit,khit,dist_min ! position = 0 ; number_patterns = kohonen_map % number_patterns ( ihit , jhit , khit ); if ( number_patterns > 0 ) then where ( kohonen_map % cells_index (:, 1 ) == ihit . and . & kohonen_map % cells_index (:, 2 ) == jhit . and . & kohonen_map % cells_index (:, 3 ) == khit ) position = 1 ; !real_position; end where number_selected = sum ( position ); pos = 0 if ( number_selected > 0 ) then allocate ( sample_index ( number_selected ), stat = ierr ); do i = 1 , size ( real_position ) if ( position ( i ) == 1 ) then pos = pos + 1 ; sample_index ( pos ) = real_position ( i ); !write(*,*) 'Inside= ',i,real_position(i) endif enddo endif !write(*,*) kohonen_map%cells_index(118,1:3) else write ( * , * ) 'WARNING: Query has returned an empty result' return endif ! end subroutine query_som !======================================================================================== subroutine read_som ( kohonen_map , som_fl ) !======================================================================================== !! Subroutine to read the prototypes to define a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len =* ) :: som_fl !! A character variable with the name of the file logical :: testfl , toroidal_grid integer :: isom , nx , ny , nz , nvar1 , nvar2 , ierr , ix , iy , iz , ivar , current_index character ( len = 40 ) :: current_line , node_type real ( kind = wp ), allocatable :: Prototype_value (:,:) ! isom = 20 ; inquire ( file = trim ( som_fl ), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the som file does not exist' stop endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...' write ( * , * ) open ( isom , file = trim ( som_fl ), status = 'unknown' , action = 'read' , access = 'sequential' ); read ( isom , '(A)' ) current_line write ( * , * ) trim ( current_line ) read ( isom , '(A17,1X,3I6)' ) current_line , nx , ny , nz write ( * , * ) current_line , nx , ny , nz read ( isom , '(A21,1X,2I6)' ) current_line , nvar1 , nvar2 write ( * , * ) current_line , nvar1 , nvar2 read ( isom , '(A25,1X,A11,1X,L4)' ) current_line , node_type , toroidal_grid write ( * , * ) current_line , node_type , toroidal_grid allocate ( Prototype_value ( nvar1 * nvar2 , 1 ), stat = ierr ); ! if ( allocated ( kohonen_map % grid )) then do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); do iz = 1 , nz read ( isom , '(A)' ) current_line ; write ( * , * ) 'Reading ' , trim ( current_line ); do iy = 1 , ny do ix = 1 , nx ; read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , * ) ( Prototype_value ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ); !write(*,*) ix,iy,(Prototype_value(ivar,1),ivar=1,nvar1*nvar2) call kohonen_map % grid ( ix , iy , iz )% set_prototype ( Prototype_value ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , node_type ); enddo enddo enddo close ( isom ) !write(*,*) 'Reading done' ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& node_type , toroidal_grid ); ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...finished' write ( * , * ) ! end subroutine read_som !======================================================================================== function position2index ( ix , iy , iz , nx , ny ) result ( index_ ) !======================================================================================== !! Function to calculate the index inside a rectangular grid from position ix,iy,iz integer , intent ( in ) :: ix , iy , iz , nx , ny !! Integer variables integer :: index_ !! Integer variable with the required index index_ = ix + ( iy - 1 ) * nx + ( iz - 1 ) * nx * ny ; ! end function position2index !======================================================================================== subroutine index2position ( index_ , nx , ny , nz , cx , cy , cz ) !======================================================================================== !! Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index integer , intent ( in ) :: index_ !! Integer variable representing the index integer , intent ( in ) :: nx , ny , nz !! Integer variables representing the dimensions of the kohonen map integer , intent ( inout ) :: cx , cy , cz !! Integer variables representing the position of the node !  write(*,*) index_,nx,ny,1+int((index_-1)/(nx*ny)) cz = min ( 1 + int (( index_ - 1 ) / ( nx * ny )), nz ); cy = min ( 1 + int (( index_ - 1 - ( cz - 1 ) * nx * ny ) / nx ), ny ); cx = min ( index_ - ( cz - 1 ) * nx * ny - ( cy - 1 ) * nx , nx ); ! end subroutine index2position !======================================================================================== subroutine calculate_distance_matrix ( coordinates , distance_matrix , grid_type , toroidal ) !======================================================================================== !! Subroutine to calculate the distance between the units inside a kohonen layer real ( kind = wp ), dimension (:,:), intent ( inout ) :: coordinates !! Real array with the coordinates real ( kind = wp ), dimension (:,:), intent ( inout ) :: distance_matrix !! Real array with the distance_matrix character ( len =* ) :: grid_type !! Character variable with the grid type logical :: toroidal !! Logical variable for toroidal grid integer :: i , j real ( kind = wp ) :: maxdiffx , maxdiffy , maxdiffz real ( kind = wp ), dimension ( 3 ) :: diffs ! maxdiffx = maxval ( coordinates (:, 1 )) / 2.0_wp ; maxdiffy = maxval ( coordinates (:, 2 )) / 2.0_wp ; maxdiffz = maxval ( coordinates (:, 3 )) / 2.0_wp ; ! distance_matrix = 0.0d0 ; ! if ( toroidal ) then do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); if ( diffs ( 1 ) > maxdiffx ) diffs ( 1 ) = 2.0_wp * maxdiffx - diffs ( 1 ); if ( diffs ( 2 ) > maxdiffy ) diffs ( 2 ) = 2.0_wp * maxdiffy - diffs ( 2 ); !if (diffs(3) > maxdiffy) diffs(3)=2*maxdiffz - diffs(3); if ( trim ( grid_type ) == 'hexagonal' ) then distance_matrix ( i , j ) = sum ( diffs ** 2 ); elseif ( trim ( grid_type ) == 'rectangular' ) then !rectangular distance_matrix ( i , j ) = maxval ( diffs ); endif !write(*,*) 'd= ',i,j,diffs(1:3),trim(grid_type)!distance_matrix(i,j) enddo enddo else do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); distance_matrix ( i , j ) = dsqrt ( sum ( diffs ** 2 )); enddo enddo endif ! distance_matrix = distance_matrix + transpose ( distance_matrix ); ! end subroutine calculate_distance_matrix !======================================================================================== subroutine calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , coordinates , node_type ) !======================================================================================== !!  Subroutine to calculate the coordinates of the units inside a kohonen layer integer , intent ( in ) :: current_index , ix , iy , iz , nx , ny , nz !! real ( kind = wp ), dimension (:,:), intent ( out ) :: coordinates !! character ( len =* ), intent ( in ) :: node_type !! coordinates ( current_index , 1 ) = dble ( ix ); coordinates ( current_index , 2 ) = dble ( iy ); coordinates ( current_index , 3 ) = dble ( iz ); !write(*,*) coordinates(current_index,1:3); if ( trim ( node_type ) == 'hexagonal' ) then coordinates ( current_index , 1 ) = coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( coordinates ( current_index , 2 ), 2.0_wp )); coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2.0_wp ) * coordinates ( current_index , 2 ); endif ! end subroutine calculate_coordinates !======================================================================================== subroutine find_best_match_unit ( kohonen_map , current_prototype , ihit , jhit , khit , dist_hit ) !======================================================================================== !! Subroutine to calculate the best match unit class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_prototype ), intent ( inout ) :: current_prototype !! A `kohonen_prototype` object integer , intent ( out ) :: ihit , jhit , khit !! Integer variables for the coordinates of the BMU real ( kind = wp ), intent ( out ) :: dist_hit !! Real variable with the distance to the BMU integer :: debug_option , idbg , ix , iy , iz , number_variables real ( kind = wp ) :: dist ! idbg = kohonen_map % parameters % idbg ; debug_option = kohonen_map % parameters % debug_level ; number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e7 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); !write(*,*) 'dist= ',dist if ( debug_option > 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ); write ( idbg , * ) ix , iy , iz , dist ; endif dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! !        write(*,*) 'find= ',ihit,jhit,khit,dist_hit return ! end subroutine find_best_match_unit !======================================================================================== subroutine update_weights ( kohonen_map , current_values , ihit , jhit , khit ,& maximum_radius , iteration ) !======================================================================================== !!    Subroutine to update the weights class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: current_values !! A real array with the values of the current unit integer , intent ( inout ) :: ihit , jhit , khit , iteration !! Integer variables with the coordinates of the unit (neuron) to be modified real ( kind = wp ), intent ( inout ) :: maximum_radius !! Real variable with the maximum radius of the neighborhood real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: prototype_values real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: winner_values , term1 , term2 integer :: nx , ny , nz , debug_option , ic , current_pos , ineigh , jneigh , kneigh , idbg real ( kind = wp ) :: time_factor , current_radius , alpha , sigma2 , h_neighborhood , real_distance , term3 real ( kind = wp ) :: distance_ratio , geometric_distance2 , eps , current_distance , lambda !type(influence_function) :: influence_func real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: v_vector real ( kind = wp ) :: v_vector_norm , r , Psi character ( len = NUMCHAR ) :: m_estimator ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; debug_option = kohonen_map % parameters % debug_level ; idbg = kohonen_map % parameters % idbg ; lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); time_factor = 1.0_wp - dble ( iteration ) / & dble ( kohonen_map % parameters % number_epochs * kohonen_map % parameters % number_patterns ); !current_radius = max(maximum_radius*real(1001-iteration)/1000.0 + 0.9999999999,4.0d0); current_radius = max ( maximum_radius * time_factor , 4.0_wp ); !alpha = max(kohonen_map%parameters%learning_rate*(1.0d0-real(iteration)/1000.0),0.01d0); alpha = max ( kohonen_map % parameters % learning_rate * time_factor , 0.01_wp ); sigma2 = current_radius ** 2 ; ! m_estimator = trim ( kohonen_map % parameters % m_estimator ); ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance < current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters % neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * dexp ( - 0.5_wp * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option > 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters % som_type )) case ( 'normal_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); !v_vector=(current_values-prototype_values); !v_vector_norm=dsqrt(sum(v_vector**2)); !r=v_vector_norm/sigma; !Psi=influence_func%calculate(m_estimator,r); !prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'visom' ) !write(*,*) trim(kohonen_map%parameters%som_type) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh == ihit ) . and . ( jneigh == jhit ) . and . ( kneigh == khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); eps = max ( 1.0_wp * time_factor , 0.0_wp ); term3 = 1.0_wp ; !((1.0d0-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * & ( distance_ratio - 1.0_wp ) * term3 ); endif !write(*,*) iteration,dsqrt(real_distance),dsqrt(geometric_distance2)*lambda,distance_ratio call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'robust_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); ! v_vector=(current_values-prototype_values); ! v_vector_norm=dsqrt(sum(v_vector**2)); ! r=v_vector_norm/sigma; ! Psi=influence_func%calculate(m_estimator,r); ! prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo !ic ! end subroutine update_weights !======================================================================================== subroutine calculate_distance_between_prototypes ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the distance between the prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: nx , ny , ix , iy , iz , ix1 , iy1 , iz1 , pos , pos1 ! type ( kohonen_prototype ) :: current_prototype , current_prototype1 !! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_prototype = kohonen_map % grid ( ix , iy , iz ); pos = position2index ( ix , iy , iz , nx , ny ); do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); pos1 = position2index ( ix1 , iy1 , iz1 , nx , ny ) current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); kohonen_map % distance ( pos , pos1 ) = current_prototype1 % distance ( current_prototype ,& kohonen_map % distance_function ); enddo !ix1 enddo !iy1 enddo !iz1 enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! if ( kohonen_map % parameters % train_option < 3 ) then do ix = 1 , size ( kohonen_map % distance , 1 ) write ( kohonen_map % parameters % idist , * ) ( kohonen_map % distance ( ix , iy ), iy = 1 , size ( kohonen_map % distance , 2 )); enddo !ix endif ! end subroutine calculate_distance_between_prototypes !======================================================================================== subroutine find_bmu_grid ( kohonen_map , input_data ) !======================================================================================== !! Subroutine to calculate the best match unit over the grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: nx , ny , nz , ix , iy , iz , ihit , jhit , khit , idat , pat_hit type ( kohonen_prototype ) :: current_prototype real ( kind = wp ) :: dist , dist_min ! do idat = 1 , size ( input_data ) dist_min = 1.0e7 ; ihit = 0 ; jhit = 0 ; khit = 0 ; call input_data ( idat )% get ( current_prototype ); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( kohonen_map % parameters % number_variables ) if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; pat_hit = idat ; endif enddo enddo enddo !$OMP end parallel do kohonen_map % grid_pattern_index ( ihit , jhit , khit ) = pat_hit ; kohonen_map % cells_index ( idat , 1 ) = ihit ; kohonen_map % cells_index ( idat , 2 ) = jhit ; kohonen_map % cells_index ( idat , 3 ) = khit ; !    write(*,*) 'BMU= ',idat,ihit,jhit,khit,dist_min enddo ! ! end subroutine find_bmu_grid !****f* self_organizing_map_utilities/calculate_u_matrix ! NAME !   calculate_u_matrix ! PURPOSE !    Subroutine to calculate  the u_matrix ! SYNOPSIS !======================================================================================== subroutine calculate_u_matrix ( kohonen_map ) !======================================================================================== !! Subroutine to calculate  the u_matrix class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len = NUMCHAR ) :: type_ integer :: nx , ny , nz , nt , ierr , ix , iy , iz , cx , cy , cz , nxu , nyu , nzu real ( kind = wp ) :: dist , u_temp ! type_ = trim ( kohonen_map % parameters % node_type ); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; ! nxu = size ( kohonen_map % u_matrix , 1 ); nyu = size ( kohonen_map % u_matrix , 2 ); nzu = size ( kohonen_map % u_matrix , 3 ); ! select case ( trim ( type_ )) ! case ( 'rectangular' ) !call kohonen_map%calculate_u_matrix_rectangular(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); ! horizontal if ( ix < nx ) then cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif !vertical if ( iy < ny ) then cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; endif ! if ( iz < nz ) then cx = ix ; cy = iy ; cz = iz + 1 ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! Diagonal if ( ix < nx . and . iy < ny ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = dist + kohonen_map % grid ( ix , cy , iz )% distance ( kohonen_map % grid ( cx , iy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; endif enddo enddo enddo ! do iz = 1 , size ( kohonen_map % u_matrix , 3 ), 2 do iy = 1 , size ( kohonen_map % u_matrix , 2 ), 2 do ix = 1 , size ( kohonen_map % u_matrix , 1 ), 2 u_temp = 0.0d0 ; if ( ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 ) . and . & iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == 1 . and . ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( iy == size ( kohonen_map % u_matrix , 2 ) . and . ix > 1 . and .& ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == 1 . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = 0.0_wp ; endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! case ( 'hexagonal' ) !call kohonen_map%calculate_u_matrix_hexagonal(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); if ( ix < nx ) then !horizontal cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! if ( iy < ny ) then !diagonals cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; if ( mod ( iy , 2 ) == 0 . and . ix < nx ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; elseif ( mod ( iy , 2 ) == 1 . and . ix > 1 ) then cx = ix - 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 2 , 2 * iy , 2 * iz - 1 ) = dist ; endif endif enddo enddo enddo ! do iz = 1 , nzu , 2 ; do iy = 1 , nyu , 2 ; do ix = 1 , nxu , 2 ; u_temp = 0.0d0 ; if ( ix > 1 . and . iy > 1 . and . ix < nxu . and . iy < nyu ) then !middle part of the map u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); endif nt = 6 ; elseif ( iy == 1 . and . ix > 1 . and . ix < nxu ) then ! upper edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == nyu . and . ix > 1 . and . ix < nxu ) then ! lower edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); endif nt = 4 ; elseif ( ix == 1 . and . iy > 1 . and . iy < nyu ) then ! left edge u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); nt = 5 ; endif elseif ( ix == nxu . and . iy > 1 . and . iy < nyu ) then ! right edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ); nt = 5 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; endif elseif ( ix == 1 . and . iy == 1 ) then ! top left corner u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == nxu . and . iy == 1 ) then ! top right corner u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == nyu ) then ! bottom left corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); nt = 3 ; endif ; elseif ( ix == nxu . and . iy == nyu ) then ! bottom right corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ); nt = 3 ; else u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; endif endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! end select ! if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % u_matrix , 3 ); write ( kohonen_map % parameters % iumat , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % u_matrix , 1 ); write ( kohonen_map % parameters % iumat , '(100f10.5)' ) ( kohonen_map % u_matrix ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % u_matrix , 2 )); enddo enddo endif ! end subroutine calculate_u_matrix !======================================================================================== subroutine calculate_u_matrix_hexagonal ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matrix for an hexagonal grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_hexagonal !======================================================================================== subroutine calculate_u_matrix_rectangular ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matix for a rectangular grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_rectangular !======================================================================================== subroutine get_u_matrix_som ( kohonen_map , u_matrix ) !======================================================================================== !! Subroutine to get the u_matrix from a SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:,:), intent ( out ) :: u_matrix !! A real array to return the u_matrix u_matrix = kohonen_map % u_matrix ; ! end subroutine get_u_matrix_som !======================================================================================== subroutine get_prototypes ( kohonen_map , prototypes ) !======================================================================================== !! Subroutine to get SOM prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: prototypes !! A real array to return the values of the SOM prototypes integer :: i , j , k , pos , nvar1 , nvar2 integer , dimension ( 1 ) :: nvar real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ) :: current_prototype1 ! nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; nvar ( 1 ) = nvar1 * nvar2 pos = 0 ; do k = 1 , size ( kohonen_map % grid , 3 ) do j = 1 , size ( kohonen_map % grid , 2 ); do i = 1 , size ( kohonen_map % grid , 1 ); pos = pos + 1 ; call kohonen_map % grid ( i , j , k )% get_prototype ( current_prototype ); current_prototype1 ( 1 : nvar1 * nvar2 ) = reshape ( current_prototype , nvar ) prototypes ( pos ,:) = current_prototype1 ; enddo enddo enddo ! end subroutine get_prototypes !======================================================================================== function calculate_sigma ( kohonen_map , input_data , seed ) result ( sigma ) !======================================================================================== !!    Function to calculate the scaling factor sigma class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_data !! A real array with the input data integer , intent ( inout ), optional :: seed !! An integer with the random seed real ( kind = wp ) :: sigma !! A real variable with the value of sigma integer :: ndat , nvar , seed1 , nx , ny , nz , nxyz , ierr , i , j real ( kind = wp ), allocatable :: sample_pos (:), p_vector (:,:), sigma_table (:,:) real ( kind = wp ), allocatable :: current_sigma (:) integer , allocatable :: sample_index (:) type ( quicksort ) :: qsort ! if (. not . present ( seed )) then seed1 = 12345 ; else seed1 = seed ; endif ! ndat = size ( input_data , 1 ); nvar = size ( input_data , 2 ); ! !kohonen_map%parameters=training_parameters(1); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; nxyz = nx * ny * nz ; allocate ( sample_pos ( ndat ), stat = ierr ); allocate ( sample_index ( ndat ), stat = ierr ); allocate ( p_vector ( nxyz , nvar ), stat = ierr ); allocate ( sigma_table ( ndat , nxyz ), stat = ierr ); allocate ( current_sigma ( ndat ), stat = ierr ); !call sgrnd(seed1); do i = 1 , size ( sample_pos ); sample_pos ( i ) = kohonen_map % rnumber_grator % generate (); enddo !call grnd_array(sample_pos); do i = 1 , nxyz sample_index ( i ) = i ; enddo ! call qsort % sort ( sample_pos , sample_index ); ! !  define p vector (See Lopez-Rubio et al, 2015) ! p_vector ( 1 : nxyz , 1 : nvar ) = input_data ( sample_index ( 1 : nxyz ), 1 : nvar ); ! !  Calculate the distance between the input data and the selected prototypes ! do i = 1 , ndat do j = 1 , nxyz sigma_table ( i , j ) = sum (( input_data ( i ,:) - p_vector ( j ,:)) ** 2 ); enddo enddo ! do j = 1 , nxyz current_sigma ( 1 : ndat ) = sigma_table ( 1 : ndat , j ); !(sample_index(i)=i,i=1,ndat) call qsort % sort ( current_sigma , sample_index ); !    if(current_sigma(1) > 1d-10) then !       current_sigma_value() enddo ! deallocate ( sample_pos , sample_index , p_vector , sigma_table , current_sigma ); ! end function calculate_sigma !****f* self_organizing_map_utilities/external_train_map ! NAME !   external_train_map ! PURPOSE ! SYNOPSIS !======================================================================================== subroutine external_train_map ( x , nvar , npat , nx , ny , nepoch , alpha , grid_type ,& distance_type , neigh_type , toroidal , prot , distortion ,& u_matrix , coords , number_patterns , node_index ) bind ( C , name = \"train_som_\" ) !======================================================================================== !!    Subroutine to connect the self_organizing_map module to R o C use , intrinsic :: iso_c_binding , only : c_double , c_int , c_char !! Import section real ( kind = wp ), parameter :: version = 0.1_wp ; !! Parameter version character ( len =* ), parameter :: program_name = \"som_train\" ; !! Parameter name of the function integer ( c_int ), intent ( in ) :: nvar , npat !! Integer variables to indicate the number of variables and patterns integer ( c_int ), intent ( in ) :: nx , ny !! Integer variables to indicate the number of nodes of the SOM integer ( c_int ), intent ( in ) :: nepoch !! Integer variables to indicate the number of epochs for training integer ( c_int ), intent ( in ) :: toroidal !! Integer variable to indicate if a toroidal grid is used real ( c_double ), intent ( out ) :: prot ( nx * ny , nvar ) !! Real array for the prototypes real ( c_double ), intent ( out ) :: distortion ( nepoch ) !! Real array for the distortion measure (error during training) real ( c_double ), intent ( out ) :: u_matrix ( 2 * nx - 1 , 2 * ny - 1 ) !! Real array for the u_matrix real ( c_double ), intent ( out ) :: coords ( nx * ny , 3 ) !! Real array for the grid coordinates of the SOM integer ( c_int ), intent ( out ) :: number_patterns ( nx , ny ) !! Integer array with the number of hits for each neuron integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! Integer array with the index node for all the neurons of the SOM real ( c_double ), intent ( in ) :: x ( npat , nvar ) !! Real array with the input patterns real ( c_double ), intent ( in ) :: alpha !! Real value with the initial learning rate integer ( c_int ), intent ( in ) :: grid_type !! Integer variable to indicate the type of grid integer ( c_int ), intent ( in ) :: distance_type !! Integer variable to indicate the distance type integer ( c_int ), intent ( in ) :: neigh_type !! Integer variable to indicate the neighborhood type type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters real ( kind = wp ), dimension ( nvar , 1 ) :: var integer :: i , j , k , ierr , pos , ihit , jhit , khit , nx1 , ny1 type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), dimension ( nx * ny , nvar ) :: prototypes real ( kind = wp ), dimension ( nvar , 1 ) :: temp ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = nepoch ; parameters ( 1 )% learning_rate = alpha ; parameters ( 1 )% random_seed_ = 12345 ; if ( grid_type == 0 ) then parameters ( 1 )% node_type = \"rectangular\" ; !\"hexagonal\" !rectangular, hexagonal elseif ( grid_type == 1 ) then parameters ( 1 )% node_type = \"hexagonal\" ; endif parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" ; parameters ( 1 )% pattern_file = \"NOFILE\" ; parameters ( 1 )% output_file = \"NOFILE\" ; parameters ( 1 )% distance_type = \"euclidean\" ; !\"euclidean\" !euclidean, manhattan, correlation, correlation2 if ( neigh_type == 0 ) then parameters ( 1 )% neighborhood_type = \"bubble\" ; elseif ( neigh_type == 1 ) then parameters ( 1 )% neighborhood_type = \"gaussian\" ; !gaussian,bubble endif parameters ( 1 )% som_type = \"normal_som\" !,visom if ( toroidal == 1 ) then parameters ( 1 )% toroidal_grid = . TRUE .; else parameters ( 1 )% toroidal_grid = . FALSE .; endif ! ! ADDED TO AVOID PRINTING UNIT INFO (THE CAUSE IS UNKNONW) ! write(*,*) '' ! write(*,'(A,A,f10.5)') trim(program_name),' version: ',version ! write(*,*) '' allocate ( input_patterns ( npat ), stat = ierr ); do i = 1 , npat var ( 1 : nvar , 1 ) = x ( i , 1 : nvar ) !write(*,*) i,var call input_patterns ( i )% create ( var ); !    call input_patterns(i)%print(); enddo ! Create SOM call my_som % create ( parameters ); ! Train SOM call my_som % train ( input_patterns ); ! Extract results pos = 0 k = 1 nx1 = nx ; ny1 = ny ; do j = 1 , ny do i = 1 , nx pos = position2index ( i , j , k , nx1 , ny1 ); !write(*,*) i,j,pos,i+(j-1)*nx call my_som % grid ( i , j , k )% get_prototype ( temp ); !position2index() prototypes ( pos , 1 : nvar ) = temp ( 1 : nvar , 1 ); enddo enddo ! ! Get the results in the arrays ! distortion = my_som % distortion u_matrix ( 1 : 2 * nx - 1 , 1 : 2 * ny - 1 ) = my_som % u_matrix (:,:, 1 ); !do i=1,size(my_som%coordinates,1); !write(*,*) my_som%coordinates(i,1:3); !   coords(i,1:3)=my_som%coordinates(i,1:3); !enddo coords = my_som % coordinates ; !coords(1:nx*nx,1)=my_som%coordinates(:,1); !coords(1:nx*nx,2)=my_som%coordinates(:,2); !coords(1:nx*nx,3)=my_som%coordinates(:,3); number_patterns = my_som % number_patterns (:,:, 1 ); node_index = my_som % cells_index prot = prototypes ; ! call my_som % destroy (); ! do i = 1 , npat call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); ! ! ! write(*,*) ! write(*,'(A,A,f10.5,2X,A)') trim(program_name),' version: ',version,'Finished' ! write(*,*) ! end subroutine external_train_map !======================================================================================== subroutine external_predict_map ( prot , nx , ny , new_pat , npat , nvar , node_index ) & bind ( C , name = \"predict_som_\" ) !======================================================================================== !!    Subroutine to connect this module to R use , intrinsic :: iso_c_binding , only : c_double , c_int integer ( c_int ), intent ( in ) :: nx , ny , npat , nvar real ( c_double ), intent ( in ) :: prot ( nx * ny , nvar ), new_pat ( npat , nvar ) integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters integer :: ipat , inode , i_hit , nx1 , ny1 , nz1 , cx , cy , cz , ix , iy , iz , pos , ierr real ( kind = wp ) :: dist , dist_hit real ( kind = wp ), dimension ( nvar , 1 ) :: temp type ( kohonen_pattern ), dimension ( npat ) :: input_data ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = 1 ; parameters ( 1 )% learning_rate = 0.0d0 ; parameters ( 1 )% random_seed_ = 12345 ; parameters ( 1 )% node_type = \"hexagonal\" parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" parameters ( 1 )% pattern_file = \"NOFILE\" parameters ( 1 )% output_file = \"NOFILE\" parameters ( 1 )% distance_type = \"euclidean\" !\"euclidean\" !euclidean, manhattan, correlation, correlation2 parameters ( 1 )% neighborhood_type = \"gaussian\" !gaussian,bubble parameters ( 1 )% som_type = \"normal_som\" !,visom parameters ( 1 )% toroidal_grid = . TRUE . ! ! call parameters(1)%print(); ! call my_som % create ( parameters ); ! pos = 0 ; iz = 1 ; do iy = 1 , ny do ix = 1 , nx pos = pos + 1 ; temp ( 1 : nvar , 1 ) = prot ( pos , 1 : nvar ) call my_som % grid ( ix , iy , iz )% set_prototype ( temp ) enddo enddo ! do ipat = 1 , npat temp ( 1 : nvar , 1 ) = new_pat ( ipat , 1 : nvar ); call input_data ( ipat )% create ( temp ); enddo ! call my_som % predict ( input_data , node_index ); ! call my_som % destroy (); ! do ipat = 1 , size ( input_data ); call input_data ( ipat )% destroy (); enddo ! end subroutine external_predict_map ! end module self_organizing_map_utilities","tags":"","loc":"sourcefile\\self_organizing_map_utilities.f90.html"}]}