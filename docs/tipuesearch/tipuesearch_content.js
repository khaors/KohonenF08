var tipuesearch = {"pages":[{"title":" KohonenF08 ","text":"KohonenF08 Fortran KohonenF08 API Documentation Goals and Motivation Scope Code of Conduct License Note Use the navigation bar at the top of the screen to browse modules, procedures, source files, etc.\nThe listings near the bottom of the page are incomplete. Fortran KohonenF08 API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Goals and Motivation Self-Organizing Maps or Kohonen Maps are powerful computational tools to cluster multivariate data using a topology preservation approach, that is, the clustering obtained by using this methodology is designed to preserve neighboring relationships between samples (closer samples in the input space remain closer in the output space). Two Level Self-Organizing Maps are important in many applied areas but currently there is not a proper implementation that suited my needs. So I decided to implement this clustering approach in Fortran using the features included in the new standard Fortran2008. This ensures computational efficiency and software extensibility, in addition to having to learn more about Fortran. Scope The goal of the KohonenF08 Library is to achieve the following general scope: Data transformation (normal and uniform standarization) Clustering using Self-Organizing Maps with one a several layers Clustering using VISOM Code of Conduct In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. License The KohonenF08 source code and related files and documentation are distributed under the MIT license . Developer Info Oscar Garcia-Cabrejo Faculty @ UPTC Colombia","tags":"home","loc":"index.html"},{"title":"kohonen_prototype – KohonenF08 ","text":"type, public :: kohonen_prototype Class to store a prototype inside a Kohonen map Inherited by type~~kohonen_prototype~~InheritedByGraph type~kohonen_prototype kohonen_prototype type~kohonen_pattern kohonen_pattern type~kohonen_pattern->type~kohonen_prototype pattern type~self_organizing_map self_organizing_map type~self_organizing_map->type~kohonen_prototype grid type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~kohonen_prototype grid, cluster_layer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => kohonen_prototype_constructor private  subroutine kohonen_prototype_constructor(prototype, input_data) Class Constructor Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object real(kind=wp), dimension(:,:) :: input_data A real array procedure, public :: destroy => kohonen_prototype_destructor private  subroutine kohonen_prototype_destructor(prototype) Class Destructor Arguments Type Intent Optional Attributes Name class( kohonen_prototype ), intent(inout) :: prototype A kohonen_prototype object procedure, public :: get_prototype => kohonen_prototype_accessor private  subroutine kohonen_prototype_accessor(prototype, d) Acccessor Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object real(kind=wp), dimension(prototype%number_rows,prototype%number_columns) :: d A real variable with the value of the prototype procedure, public :: set_prototype => kohonen_prototype_mutator private  subroutine kohonen_prototype_mutator(prototype, new_data) Mutator Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object real(kind=wp), intent(inout), dimension(:,:) :: new_data procedure, public :: print => kohonen_prototype_print private  subroutine kohonen_prototype_print(prototype, unit_) Function to print a kohonen prototype Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit procedure, public :: distance => kohonen_prototype_distance private  function kohonen_prototype_distance(prototype, prototype1, f) result(d) Function to calculate the distance between two prototypes Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object type( kohonen_prototype ) :: prototype1 A kohonen_prototype object class( distance_base ), allocatable :: f Return Value real(kind=wp) A real variable with the distance between prototypes procedure, public :: get_nrow => kohonen_prototype_nrow private  function kohonen_prototype_nrow(prototype) result(nr) Function to get the number of rows of the prototype Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object Return Value integer Integer variable with the number of rows procedure, public :: get_ncol => kohonen_prototype_ncol private  function kohonen_prototype_ncol(prototype) result(nc) Function to get the number of columns of the prototype Arguments Type Intent Optional Attributes Name class( kohonen_prototype ) :: prototype A kohonen_prototype object Return Value integer Integer variable with the number of columns Source Code type kohonen_prototype !!   Class to store a prototype inside a Kohonen map private real ( kind = wp ), allocatable :: data_ (:,:) integer :: number_rows , number_columns contains ! procedure :: create => kohonen_prototype_constructor procedure :: destroy => kohonen_prototype_destructor procedure :: get_prototype => kohonen_prototype_accessor procedure :: set_prototype => kohonen_prototype_mutator procedure :: print => kohonen_prototype_print procedure :: distance => kohonen_prototype_distance procedure :: get_nrow => kohonen_prototype_nrow procedure :: get_ncol => kohonen_prototype_ncol ! end type kohonen_prototype","tags":"","loc":"type\\kohonen_prototype.html"},{"title":"quicksort – KohonenF08 ","text":"type, public, extends( sort_base ) :: quicksort class that encapsulates the quicksort algorithm Inherits type~~quicksort~~InheritsGraph type~quicksort quicksort type~sort_base sort_base type~quicksort->type~sort_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass :: sort => quick_sort private recursive subroutine quick_sort(my_sort, list, order) main subroutine of the quick sort algorithm. Arguments Type Intent Optional Attributes Name class( quicksort ), intent(inout) :: my_sort A quicksort object real(kind=wp), intent(inout), dimension (:) :: list A real vector with the values to be sorted. integer, intent(inout), dimension (:) :: order An integer vector with the positions of the ordered samples.\nquick sort routine from:\nbrainerd, w.s., goldberg, c.h. & adams, j.c. (1990) \"programmer's guide to\nfortran 90\", mcgraw-hill  isbn 0-07-000248-7, pages 149-150.\nmodified by alan miller to include an associated integer array which gives\nthe positions of the elements in the original order. Source Code type , extends ( sort_base ) :: quicksort !!  class that encapsulates the quicksort algorithm contains procedure , pass :: sort => quick_sort end type quicksort","tags":"","loc":"type\\quicksort.html"},{"title":"distance_base – KohonenF08 ","text":"type, public, abstract :: distance_base Abstract class distance_base Inherited by type~~distance_base~~InheritedByGraph type~distance_base distance_base type~euclidean_distance euclidean_distance type~euclidean_distance->type~distance_base type~manhattan_distance manhattan_distance type~manhattan_distance->type~distance_base type~max_distance max_distance type~max_distance->type~distance_base type~self_organizing_map self_organizing_map type~self_organizing_map->type~distance_base distance_function type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~distance_base distance_function Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( distance_function1 ), public, deferred :: calculate function distance_function1(distance, vector1, vector2) result(d) Prototype Template for the calculate function\nImport section Arguments Type Intent Optional Attributes Name class( distance_base ) :: distance A distance_base object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Source Code type , abstract :: distance_base !! Abstract class `distance_base` contains procedure ( distance_function1 ), deferred :: calculate end type distance_base","tags":"","loc":"type\\distance_base.html"},{"title":"dataframe – KohonenF08 ","text":"type, public :: dataframe Inherits type~~dataframe~~InheritsGraph type~dataframe dataframe type~variable variable type~dataframe->type~variable variables Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_dataframe private  subroutine create_dataframe(df, data_, varnames) Class constructor Arguments Type Intent Optional Attributes Name class( dataframe ) :: df A dataframe object real(kind=wp), intent(inout), dimension(:,:) :: data_ character(len=:), intent(inout), dimension(:) :: varnames procedure, public :: destroy => destroy_dataframe private  subroutine destroy_dataframe(df) Class destructor Arguments Type Intent Optional Attributes Name class( dataframe ) :: df A dataframe object procedure, public :: add_variable private  subroutine add_variable(df, data_, varname_) Arguments Type Intent Optional Attributes Name class( dataframe ) :: df class(*) :: data_ character(len=*) :: varname_ Source Code type :: dataframe private character ( len = NUMCHAR ) :: base_message integer :: number_variables type ( variable ), allocatable :: variables (:) character ( len = :), allocatable :: variable_names (:) logical :: initialized , has_variable_names contains procedure , public :: create => create_dataframe procedure , public :: destroy => destroy_dataframe procedure , public :: add_variable ! procedure,public :: remove_variable ! procedure,public :: is_initialized ! procedure,public :: summary ! procedure,public :: nrow ! procedure,public :: ncol ! procedure,public :: size => size_dataframe ! procedure,public :: normalize end type dataframe","tags":"","loc":"type\\dataframe.html"},{"title":"rkiss05_generator – KohonenF08 ","text":"type, public, extends( random_generator_base ) :: rkiss05_generator Class to represent a random number generator that implements the rkiss method Inherits type~~rkiss05_generator~~InheritsGraph type~rkiss05_generator rkiss05_generator type~random_generator_base random_generator_base type~rkiss05_generator->type~random_generator_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~rkiss05_generator~~InheritedByGraph type~rkiss05_generator rkiss05_generator type~self_organizing_map self_organizing_map type~self_organizing_map->type~rkiss05_generator rnumber_grator type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~rkiss05_generator rnumber_grator Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_rkiss05_generator private  subroutine create_rkiss05_generator(generator, iseed) Constructor of the rkiss05_generator class. In this class random seed is assigned to the \nrandom number generator and the internal state of the corresponding generator  is \ninitialized. Arguments Type Intent Optional Attributes Name class( rkiss05_generator ) :: generator generator: A rkiss05_generator object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random number generator procedure, public :: destroy => destroy_rkiss05_generator private  subroutine destroy_rkiss05_generator(generator) Destructor of the rkiss05_generator class. In this class, the random seed is set to 0 Arguments Type Intent Optional Attributes Name class( rkiss05_generator ) :: generator generator: A rkiss05_generator object procedure, public :: generate => generate_rkiss05_generator private  function generate_rkiss05_generator(generator) result(r) Function used to generate realizations of the random numbers with the rkiss05_generator class. Arguments Type Intent Optional Attributes Name class( rkiss05_generator ) :: generator generator: A rkiss05_generator object Return Value real(kind=wp) r: A real variable with the generated random number Source Code type , extends ( random_generator_base ) :: rkiss05_generator private !! Class to represent a random number generator that implements the rkiss method integer :: seed integer :: x , y , w , z contains !  * constructor procedure , public :: create => create_rkiss05_generator !  * destructor procedure , public :: destroy => destroy_rkiss05_generator !  * generate procedure , public :: generate => generate_rkiss05_generator ! end type rkiss05_generator","tags":"","loc":"type\\rkiss05_generator.html"},{"title":"neighborhood_function_base – KohonenF08 ","text":"type, public, abstract :: neighborhood_function_base Abstract class used to derive classes that calculates the effect of the input on the \nunits of a SOM (neighborhood function) Inherited by type~~neighborhood_function_base~~InheritedByGraph type~neighborhood_function_base neighborhood_function_base type~cauchy_neighborhood_function cauchy_neighborhood_function type~cauchy_neighborhood_function->type~neighborhood_function_base type~gaussian_neighborhood_function gaussian_neighborhood_function type~gaussian_neighborhood_function->type~neighborhood_function_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( neighborhood_function_calculate ), public, deferred :: calculate function neighborhood_function_calculate(my_neigh_fn, geometric_distance) result(n) Prototype Subroutine template to calculate function\nImport section Arguments Type Intent Optional Attributes Name class( neighborhood_function_base ) :: my_neigh_fn A neighborhood_function_base object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric or grid distance of a SOM unit Return Value real(kind=wp) A real variable with the value of the neighborhood function Source Code type , abstract :: neighborhood_function_base !! Abstract class used to derive classes that calculates the effect of the input on the !! units of a SOM (neighborhood function) contains procedure ( neighborhood_function_calculate ), deferred :: calculate end type neighborhood_function_base","tags":"","loc":"type\\neighborhood_function_base.html"},{"title":"self_organizing_map – KohonenF08 ","text":"type, public, extends( kohonen_map_base ) :: self_organizing_map Class to represent a self_organizing_map Inherits type~~self_organizing_map~~InheritsGraph type~self_organizing_map self_organizing_map type~distance_base distance_base type~self_organizing_map->type~distance_base distance_function type~factory_distance factory_distance type~self_organizing_map->type~factory_distance factory type~kohonen_layer_parameters kohonen_layer_parameters type~self_organizing_map->type~kohonen_layer_parameters parameters type~kohonen_map_base kohonen_map_base type~self_organizing_map->type~kohonen_map_base type~kohonen_prototype kohonen_prototype type~self_organizing_map->type~kohonen_prototype grid type~rkiss05_generator rkiss05_generator type~self_organizing_map->type~rkiss05_generator rnumber_grator type~random_generator_base random_generator_base type~rkiss05_generator->type~random_generator_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_som public  subroutine create_som (kohonen_map, training_parameters) Constructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object procedure, public :: destroy => destroy_som public  subroutine destroy_som (kohonen_map) Destructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object procedure, public :: train => train_som_data public  subroutine train_som_data (kohonen_map, input_data) Training function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data procedure, public :: predict => predict_som public  subroutine predict_som (kohonen_map, input_data, map_output) Function for Prediction of a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data integer, intent(out), dimension(:,:) :: map_output An integer array with the map output procedure, public :: print => print_som public  subroutine print_som (kohonen_map, unit_) Print function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), optional :: unit_ procedure, public :: read => read_som public  subroutine read_som (kohonen_map, som_fl) Subroutine to read the prototypes to define a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object character(len=*) :: som_fl A character variable with the name of the file procedure, public :: get_count => get_count_som public  subroutine get_count_som (kohonen_map, count_) Function to get count matrix for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), dimension(:,:,:) :: count_ procedure, public :: query => query_som public  subroutine query_som (kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map real(kind=wp), intent(inout), dimension(:,:) :: input_pattern integer, allocatable :: sample_index (:) procedure, public :: get_prototypes public  subroutine get_prototypes (kohonen_map, prototypes) Subroutine to get SOM prototypes Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: prototypes A real array to return the values of the SOM prototypes procedure, public :: get_u_matrix => get_u_matrix_som public  subroutine get_u_matrix_som (kohonen_map, u_matrix) Subroutine to get the u_matrix from a SOM Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:,:) :: u_matrix A real array to return the u_matrix procedure, public, nopass :: external_train_map public  subroutine external_train_map (x, nvar, npat, nx, ny, nepoch, alpha, grid_type, distance_type, neigh_type, toroidal, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_som\") Subroutine to connect the self_organizing_map module to R o C\nImport section Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real array with the input patterns integer(kind=c_int), intent(in) :: nvar Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: npat Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: nx Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: ny Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: nepoch Integer variables to indicate the number of epochs for training real(kind=c_double), intent(in) :: alpha Real value with the initial learning rate integer(kind=c_int), intent(in) :: grid_type Integer variable to indicate the type of grid integer(kind=c_int), intent(in) :: distance_type Integer variable to indicate the distance type integer(kind=c_int), intent(in) :: neigh_type Integer variable to indicate the neighborhood type integer(kind=c_int), intent(in) :: toroidal Integer variable to indicate if a toroidal grid is used real(kind=c_double), intent(out) :: prot (nx*ny,nvar) Real array for the prototypes real(kind=c_double), intent(out) :: distortion (nepoch) Real array for the distortion measure (error during training) real(kind=c_double), intent(out) :: u_matrix (2*nx-1,2*ny-1) Real array for the u_matrix real(kind=c_double), intent(out) :: coords (nx*ny,3) Real array for the grid coordinates of the SOM integer(kind=c_int), intent(out) :: number_patterns (nx,ny) Integer array with the number of hits for each neuron integer(kind=c_int), intent(out) :: node_index (npat,3) Integer array with the index node for all the neurons of the SOM procedure, public, nopass :: external_predict_map public  subroutine external_predict_map (prot, nx, ny, new_pat, npat, nvar, node_index) bind(C, name=\"predict_som\") Subroutine to connect this module to R Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: prot (nx*ny,nvar) integer(kind=c_int), intent(in) :: nx integer(kind=c_int), intent(in) :: ny real(kind=c_double), intent(in) :: new_pat (npat,nvar) integer(kind=c_int), intent(in) :: npat integer(kind=c_int), intent(in) :: nvar integer(kind=c_int), intent(out) :: node_index (npat,3) Source Code type , extends ( kohonen_map_base ) :: self_organizing_map !!   Class to represent a self_organizing_map private character ( len = NUMCHAR ) :: class_name = 'self_organizing_map' ; type ( kohonen_prototype ), allocatable :: grid (:,:,:) integer , allocatable :: number_patterns (:,:,:), cells_index (:,:) real ( kind = wp ), allocatable :: u_matrix (:,:,:), distance (:,:) real ( kind = wp ), allocatable :: cells_distances (:,:), coordinates (:,:) type ( kohonen_layer_parameters ) :: parameters type ( factory_distance ) :: factory class ( distance_base ), allocatable :: distance_function real ( kind = wp ), allocatable :: distortion (:) type ( rkiss05_generator ) :: rnumber_grator integer :: seed integer , allocatable :: grid_pattern_index (:,:,:), list_node_grid (:,:,:,:) contains procedure , public :: create => create_som procedure , public :: destroy => destroy_som procedure , private :: create_random_sample procedure , private :: train_som_data procedure , public :: train => train_som_data procedure , public :: predict => predict_som procedure , public :: print => print_som procedure , public :: read => read_som procedure , public :: get_count => get_count_som procedure , public :: query => query_som procedure , public :: get_prototypes !procedure,public :: get_index => get_index_som procedure , public :: get_u_matrix => get_u_matrix_som procedure , private :: find_best_match_unit procedure , private :: update_weights !procedure,private :: update_weights1 procedure , private :: find_bmu_grid procedure , private :: calculate_u_matrix procedure , private :: calculate_u_matrix_hexagonal procedure , private :: calculate_u_matrix_rectangular procedure , private :: calculate_sigma procedure , nopass , private :: position2index procedure , nopass , private :: index2position procedure , nopass , private :: calculate_distance_matrix procedure , nopass , private :: calculate_coordinates procedure , private :: calculate_distance_between_prototypes procedure , nopass , public :: external_train_map procedure , nopass , public :: external_predict_map ! end type self_organizing_map","tags":"","loc":"type\\self_organizing_map.html"},{"title":"kohonen_map_base – KohonenF08 ","text":"type, public, abstract :: kohonen_map_base Abstract Class to represent a template for a kohonen map Inherited by type~~kohonen_map_base~~InheritedByGraph type~kohonen_map_base kohonen_map_base type~self_organizing_map self_organizing_map type~self_organizing_map->type~kohonen_map_base type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~kohonen_map_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( kohonen_map_constructor ), public, deferred :: create subroutine kohonen_map_constructor(kohonen_map, training_parameters) Prototype Template function for the constructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object procedure( kohonen_map_destructor ), public, deferred :: destroy subroutine kohonen_map_destructor(kohonen_map) Prototype Template function for the destructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object procedure( kohonen_map_function1 ), public, deferred :: train subroutine kohonen_map_function1(kohonen_map, input_data) Prototype Template function for the training function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects procedure( kohonen_map_function2 ), public, deferred :: predict subroutine kohonen_map_function2(kohonen_map, input_data, map_output) Prototype Template function for the prediction function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects integer, intent(out), dimension(:,:) :: map_output An integer array Source Code type , abstract :: kohonen_map_base !! Abstract Class to represent a template for a kohonen map contains procedure ( kohonen_map_constructor ), public , deferred :: create procedure ( kohonen_map_destructor ), public , deferred :: destroy procedure ( kohonen_map_function1 ), public , deferred :: train procedure ( kohonen_map_function2 ), public , deferred :: predict end type kohonen_map_base","tags":"","loc":"type\\kohonen_map_base.html"},{"title":"random_generator_base – KohonenF08 ","text":"type, public, abstract :: random_generator_base Abstract class to derive random number generator classes Inherited by type~~random_generator_base~~InheritedByGraph type~random_generator_base random_generator_base type~rkiss05_generator rkiss05_generator type~rkiss05_generator->type~random_generator_base type~self_organizing_map self_organizing_map type~self_organizing_map->type~rkiss05_generator rnumber_grator type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~rkiss05_generator rnumber_grator Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( random_generator_constructor ), public, deferred :: create subroutine random_generator_constructor(generator, iseed) Prototype Template of the constructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random generator. procedure( random_generator_destructor ), public, deferred :: destroy subroutine random_generator_destructor(generator) Prototype Template of the destructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object procedure( random_generator_generate ), public, deferred :: generate function random_generator_generate(generator) result(r) Prototype Template of the function used to generate realizations of the random numbers in the \nclasses derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Return Value real(kind=wp) r: A real number Source Code type , abstract :: random_generator_base !! Abstract class to derive random number generator classes contains !  * constructor procedure ( random_generator_constructor ), deferred :: create !  * destructor procedure ( random_generator_destructor ), deferred :: destroy !  * generate procedure ( random_generator_generate ), deferred :: generate !     procedure(random_generator_initialize),deferred :: initialize end type random_generator_base","tags":"","loc":"type\\random_generator_base.html"},{"title":"sort_base – KohonenF08 ","text":"type, public, abstract :: sort_base Abstract class to represent a generic sort algoritm Inherited by type~~sort_base~~InheritedByGraph type~sort_base sort_base type~quicksort quicksort type~quicksort->type~sort_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( sort_procedure ), public, deferred, pass :: sort subroutine sort_procedure(my_sort, list, order) Prototype Subroutine to sort an array\nimport sort_base Arguments Type Intent Optional Attributes Name class( sort_base ), intent(inout) :: my_sort my_sort: A sort_base object real(kind=wp), intent(inout), dimension(:) :: list list: A real vector integer, intent(inout), dimension(:) :: order order: An integer vector Source Code type , abstract :: sort_base !! Abstract class to represent a generic sort algoritm contains ! METHODS !   * sort procedure ( sort_procedure ), deferred , pass :: sort end type sort_base","tags":"","loc":"type\\sort_base.html"},{"title":"logger – KohonenF08 ","text":"type, public :: logger The Logger class is used to store all the variables related to the units of \nfiles used to store or print messages during the development (debugging ) or \nrunning Type-Bound Procedures procedure, public :: create => create_logger private  subroutine create_logger(current_log) logger constructor Arguments Type Intent Optional Attributes Name class( logger ) :: current_log a logger object procedure, public :: destroy => destroy_logger private  subroutine destroy_logger(current_log) Logger destructor Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object procedure, public :: startup private  subroutine startup(current_log, log_file, append_) Subroutine to initialize a logger object Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*) :: log_file A character variable with the name of the file associated to the logger logical, intent(in), optional :: append_ A logical (optional) variable to indicate if appending to an existing file \n         is desired procedure, public :: shutdown private  subroutine shutdown(current_log) Subroutine to turn-off the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object procedure, public :: is_initialized private  function is_initialized(current_log) result(initialized) Function to check if a logger is initialized Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object Return Value logical A logical variable procedure, public :: message private  subroutine message(current_log, msg) Subroutine to send a message to the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*) :: msg A character variable with the message to send to the logger procedure, public :: write private  subroutine write(current_log, unit_, msg) Subroutine to write a message in a file associated with the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object integer, intent(in) :: unit_ An integer variable with the value of the output unit character(len=*) :: msg A character variable with the message to be written in the output unit generic, public :: configure => configure_logical, configure_integer, configure_character private  subroutine configure_logical(current_log, option, value) Subroutine to define the logger state Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: option A character variable with the name of the state to be defined logical, intent(in) :: value A logical variable private  subroutine configure_integer(current_log, option, value) Subroutine to define a logger integer state Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: option A character variable with the name of the state to be defined integer, intent(in) :: value An integer variable private  subroutine configure_character(current_log, option, value) Subroutine to define a logger character state Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: option A character variable with the name of the state to be defined character(len=*), intent(in) :: value A character variable procedure, public :: get_unit private  function get_unit(current_log) result(logger_unit) Function to get the logger unit Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object Return Value integer An integer variable with the logger unit procedure, public :: delimiter private  subroutine delimiter(current_log, level) Subroutine that defines the delimiter in a logger repport Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), optional :: level A character variable with the definition of the delimiter procedure, public :: get_delimiter private  subroutine get_delimiter(current_log, level, msg) Subroutine to get the delimiter text Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*) :: level A character variable character(len=100) :: msg A character variable procedure, public :: reset private  subroutine reset(current_log) Subroutine to reset the logger Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object procedure, public :: error private  subroutine error(current_log, message) Subroutine to print an error message Arguments Type Intent Optional Attributes Name class( logger ) :: current_log A logger object character(len=*), intent(in) :: message A character varaible with the error message Source Code type logger private !! The Logger class is used to store all the variables related to the units of !! files used to store or print messages during the development (debugging ) or !! running integer :: fileunit , stdout logical :: activate_screen , activate_file , timestamp logical :: initialized , stoponerror character ( len = NUMCHAR ) :: level_string_volume , level_string_chapter , level_string_section character ( len = NUMCHAR ) :: level_string_subsection contains procedure , public :: create => create_logger procedure , public :: destroy => destroy_logger procedure , public :: startup procedure , public :: shutdown procedure , public :: is_initialized procedure , public :: message procedure , public :: write procedure , private :: get_available_unit procedure , private :: configure_logical procedure , private :: configure_integer procedure , private :: configure_character generic , public :: configure => configure_logical , configure_integer , configure_character !        generic,public :: get procedure , public :: get_unit procedure , public :: delimiter procedure , public :: get_delimiter procedure , public :: reset procedure , public :: error end type logger","tags":"","loc":"type\\logger.html"},{"title":"kohonen_pattern – KohonenF08 ","text":"type, public :: kohonen_pattern Class to represent a container for input data to  a kohonen map Inherits type~~kohonen_pattern~~InheritsGraph type~kohonen_pattern kohonen_pattern type~kohonen_prototype kohonen_prototype type~kohonen_pattern->type~kohonen_prototype pattern Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => kohonen_pattern_create public  subroutine kohonen_pattern_create (current_pattern, input, name) Kohonen pattern constructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object real(kind=wp), intent(inout), dimension(:,:) :: input A real array character(len=*), optional :: name A character string with the name of the pattern procedure, public :: destroy => kohonen_pattern_destroy public  subroutine kohonen_pattern_destroy (current_pattern) Kohonen pattern destructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object procedure, public :: get => kohonen_pattern_accessor public  subroutine kohonen_pattern_accessor (current_pattern, pattern_value) Kohonen pattern accessor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value procedure, public :: set => kohonen_pattern_mutator public  subroutine kohonen_pattern_mutator (current_pattern, pattern_value) kohonen_pattern_mutator Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value procedure, public :: print => kohonen_pattern_print public  subroutine kohonen_pattern_print (current_pattern, unit_) Subroutine to print a Kohonen pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit where the patterns will be printed procedure, public :: get_nrow => kohonen_pattern_nrow public  function kohonen_pattern_nrow (current_pattern) result(nr) Function to calculate the number of rows (samples) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of rows (samples) in a pattern procedure, public :: get_ncol => kohonen_pattern_ncol public  function kohonen_pattern_ncol (current_pattern) result(nc) Function to calculate the number of columns (variables) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of columns (variables) in a pattern Source Code type kohonen_pattern !!  Class to represent a container for input data to  a kohonen map private type ( kohonen_prototype ) :: pattern character ( len = NUMCHAR ) :: pattern_name contains procedure , public :: create => kohonen_pattern_create procedure , public :: destroy => kohonen_pattern_destroy procedure , public :: get => kohonen_pattern_accessor procedure , public :: set => kohonen_pattern_mutator procedure , public :: print => kohonen_pattern_print procedure , public :: get_nrow => kohonen_pattern_nrow procedure , public :: get_ncol => kohonen_pattern_ncol ! end type kohonen_pattern","tags":"","loc":"type\\kohonen_pattern.html"},{"title":"factory_distance – KohonenF08 ","text":"type, public :: factory_distance Class to represent a distance factory Inherited by type~~factory_distance~~InheritedByGraph type~factory_distance factory_distance type~self_organizing_map self_organizing_map type~self_organizing_map->type~factory_distance factory type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~factory_distance factory Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create_distance public  subroutine create_distance (factory, type_, dist) Class constructor Arguments Type Intent Optional Attributes Name class( factory_distance ) :: factory A factory_distance object character(len=*) :: type_ A character string with the type of distance to be instantiated class( distance_base ), allocatable :: dist An allocatable distance_base object Source Code type factory_distance !!  Class to represent a distance factory contains procedure , public :: create_distance end type factory_distance","tags":"","loc":"type\\factory_distance.html"},{"title":"kohonen_layer_parameters – KohonenF08 ","text":"type, public :: kohonen_layer_parameters Inherited by type~~kohonen_layer_parameters~~InheritedByGraph type~kohonen_layer_parameters kohonen_layer_parameters type~self_organizing_map self_organizing_map type~self_organizing_map->type~kohonen_layer_parameters parameters type~two_level_self_organizing_map two_level_self_organizing_map type~two_level_self_organizing_map->type~kohonen_layer_parameters parameters Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: train_option integer, public :: number_nodes_nx integer, public :: number_nodes_ny integer, public :: number_nodes_nz integer, public :: number_patterns integer, public :: number_variables1 integer, public :: number_variables2 integer, public :: number_variables integer, public, allocatable :: column_var (:) integer, public :: number_epochs integer, public :: debug_level integer, public, dimension(1) :: random_seed_ real(kind=wp), public :: learning_rate character(len=NUMCHAR), public :: node_type character(len=NUMCHAR), public :: debug_file character(len=NUMCHAR), public :: pattern_file character(len=NUMCHAR), public :: output_file character(len=NUMCHAR), public :: distance_type character(len=NUMCHAR), public :: neighborhood_type character(len=NUMCHAR), public :: som_type character(len=NUMCHAR), public :: m_estimator logical, public :: toroidal_grid integer, public :: idbg integer, public :: iout integer, public :: iindex integer, public :: iprot integer, public :: ihit integer, public :: idist integer, public :: iumat integer, public :: ipar integer, public :: isam integer, public :: iclus integer, public :: icen integer, public :: iclus1 integer, public :: idisto integer, public :: iout1 integer, public :: imeas logical, public :: view_flag integer, public :: ireal Type-Bound Procedures procedure, public :: print => print_parameters private  subroutine print_parameters(parameters, layer_ind, unit_) Arguments Type Intent Optional Attributes Name class( kohonen_layer_parameters ) :: parameters integer, intent(inout) :: layer_ind integer, intent(inout), optional :: unit_ procedure, public :: read_parameters private  subroutine read_parameters(parameters, unit_) Arguments Type Intent Optional Attributes Name class( kohonen_layer_parameters ) :: parameters integer, intent(inout), optional :: unit_ procedure, public :: read_parameters_toml private  subroutine read_parameters_toml(parameters, unit_) Arguments Type Intent Optional Attributes Name class( kohonen_layer_parameters ) :: parameters integer, intent(inout), optional :: unit_ Source Code type kohonen_layer_parameters integer :: train_option ! integer :: number_nodes_nx , number_nodes_ny , number_nodes_nz , number_patterns integer :: number_variables1 , number_variables2 , number_variables integer , allocatable :: column_var (:) integer :: number_epochs , debug_level !number_clusters, integer , dimension ( 1 ) :: random_seed_ real ( kind = wp ) :: learning_rate character ( len = NUMCHAR ) :: node_type !rectangular, hexagonal character ( len = NUMCHAR ) :: debug_file , pattern_file , output_file character ( len = NUMCHAR ) :: distance_type !euclidean, manhattan, correlation, correlation2 character ( len = NUMCHAR ) :: neighborhood_type !gaussian,bubble character ( len = NUMCHAR ) :: som_type !normal_som,visom,robust_som character ( len = NUMCHAR ) :: m_estimator !name of the M-estimator to be used logical :: toroidal_grid ! UNITS FOR TRAINING OUTPUT integer :: idbg , iout , iindex , iprot , ihit , idist , iumat , ipar , isam , iclus , icen , iclus1 , idisto ! UNITS FOR ESTIMATION OUTPUT integer :: iout1 , imeas logical :: view_flag ! FLAG FOR DEBUGGING REALIZATION integer :: ireal ! contains procedure , public :: print => print_parameters procedure , public :: read_parameters procedure , public :: read_parameters_toml !generic,public :: read => read_parameters, read_parameters_toml end type kohonen_layer_parameters","tags":"","loc":"type\\kohonen_layer_parameters.html"},{"title":"manhattan_distance – KohonenF08 ","text":"type, public, extends( distance_base ) :: manhattan_distance Class to calculate the Manhattan distance Inherits type~~manhattan_distance~~InheritsGraph type~manhattan_distance manhattan_distance type~distance_base distance_base type~manhattan_distance->type~distance_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: calculate => calculate_manhattan_distance private  function calculate_manhattan_distance(distance, vector1, vector2) result(d) Function to calculate the Manhattan distance between vectors\nA real variable with the distance Arguments Type Intent Optional Attributes Name class( manhattan_distance ) :: distance A Manhattan_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real vector Source Code type , extends ( distance_base ) :: manhattan_distance !! Class to calculate the Manhattan distance contains procedure , public :: calculate => calculate_manhattan_distance end type manhattan_distance","tags":"","loc":"type\\manhattan_distance.html"},{"title":"random_number_generator – KohonenF08 ","text":"type, public :: random_number_generator The random_number_generator class is used to encapsulate a generator or random numbers\nAn object of this class is defined through the specification of the random seed or seeds Type-Bound Procedures generic, public :: create => create_random_number_grator_single, create_random_number_grator_array private  subroutine create_random_number_grator_single(grator, iseed) Class Constructor 1 Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object to be defined integer(kind=i64) :: iseed An integer value with the seed of the random_number_generator program main\n       use random_number_generator_utilities;\n       ...\n       integer :: iseed\n       type(random_number_generator) :: my_grator\n       ...\n       iseed=12345;\n       call my_grator%create(iseed);\n       ...\n   end program main private  subroutine create_random_number_grator_array(grator, iseed) Class Destructor 2 Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object to be defined integer(kind=i64), intent(inout), dimension(:) :: iseed An integer array with the seeds of the random_number_generator program main\n       use random_number_generator_utilities;\n       ...\n       integer :: i\n       integer,dimension(5) :: iseed\n       type(random_number_generator) :: my_grator\n       ...\n       do i=1,5\n           iseed(i)=12345+i;\n       enddo\n       call my_grator%create(iseed);\n       ...\n   end program main procedure, public :: destroy => destroy_random_number_grator private  subroutine destroy_random_number_grator(grator) Class Destructor Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object to be destroyed program main\n       use random_number_generator_utilities;\n       ...\n       integer :: iseed\n       type(random_number_generator) :: my_grator\n       ...\n       iseed=12345;\n       call my_grator%create(iseed);\n       ...\n       call my_grator%destroy();\n       ...\n   end program main procedure, public :: generate private  function generate(grator) result(rn) Function used to generate random numbers Arguments Type Intent Optional Attributes Name class( random_number_generator ) :: grator A random_number_generator object Return Value real(kind=wp) A real value with the random number generated program main\n       use random_number_generator_utilities;\n       ...\n       integer :: iseed\n       real(wp) :: rnum\n       type(random_number_generator) :: my_grator\n       ...\n       iseed=12345;\n       call my_grator%create(iseed);\n       rnum=my_grator%generate();\n       write( , ) 'Random number= ',rnum;\n       ...\n   end program main Source Code type random_number_generator private !! The random_number_generator class is used to encapsulate a generator or random numbers !! An object of this class is defined through the specification of the random seed or seeds integer ( i64 ) :: seed integer ( i64 ), allocatable :: seed_array (:) contains procedure , private :: create_random_number_grator_single procedure , private :: create_random_number_grator_array generic , public :: create => create_random_number_grator_single , create_random_number_grator_array procedure , public :: destroy => destroy_random_number_grator procedure , public :: generate end type random_number_generator","tags":"","loc":"type\\random_number_generator.html"},{"title":"max_distance – KohonenF08 ","text":"type, public, extends( distance_base ) :: max_distance Class to calculate the Max distance Inherits type~~max_distance~~InheritsGraph type~max_distance max_distance type~distance_base distance_base type~max_distance->type~distance_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: calculate => calculate_max_distance private  function calculate_max_distance(distance, vector1, vector2) result(d) Function to calculate the Max distance between vectors\nA real variable with the distance Arguments Type Intent Optional Attributes Name class( max_distance ) :: distance A Max_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real vector Source Code type , extends ( distance_base ) :: max_distance !! Class to calculate the Max distance contains procedure , public :: calculate => calculate_max_distance end type max_distance","tags":"","loc":"type\\max_distance.html"},{"title":"cauchy_neighborhood_function – KohonenF08 ","text":"type, public, extends( neighborhood_function_base ) :: cauchy_neighborhood_function Class that implements the Cauchy Neighborhood Function Inherits type~~cauchy_neighborhood_function~~InheritsGraph type~cauchy_neighborhood_function cauchy_neighborhood_function type~neighborhood_function_base neighborhood_function_base type~cauchy_neighborhood_function->type~neighborhood_function_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_cauchy_neighborhood private  subroutine create_cauchy_neighborhood(my_neigh_fn, parameters) Class Constructor Arguments Type Intent Optional Attributes Name class( cauchy_neighborhood_function ) :: my_neigh_fn A cauchy_neighborhood_function object real(kind=wp), intent(in), dimension(:) :: parameters A real array with the paramters sigma and p procedure, public :: calculate => calculate_cauchy_neighborhood private  function calculate_cauchy_neighborhood(my_neigh_fn, geometric_distance) result(n) Function to calculate the value of the cauchy neighborhood Arguments Type Intent Optional Attributes Name class( cauchy_neighborhood_function ) :: my_neigh_fn A cauchy_neighborhood_function object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric distnace Return Value real(kind=wp) A real value Source Code type , extends ( neighborhood_function_base ) :: cauchy_neighborhood_function !! Class that implements the Cauchy Neighborhood Function private real ( kind = wp ) :: sigma , p contains procedure , public :: create => create_cauchy_neighborhood procedure , public :: calculate => calculate_cauchy_neighborhood end type cauchy_neighborhood_function","tags":"","loc":"type\\cauchy_neighborhood_function.html"},{"title":"gaussian_neighborhood_function – KohonenF08 ","text":"type, public, extends( neighborhood_function_base ) :: gaussian_neighborhood_function Class that implements the Gaussian Neighborhood Function Inherits type~~gaussian_neighborhood_function~~InheritsGraph type~gaussian_neighborhood_function gaussian_neighborhood_function type~neighborhood_function_base neighborhood_function_base type~gaussian_neighborhood_function->type~neighborhood_function_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_gaussian_neighborhood private  subroutine create_gaussian_neighborhood(my_neigh_fn, parameters) Class Constructor Arguments Type Intent Optional Attributes Name class( gaussian_neighborhood_function ) :: my_neigh_fn A gaussian_neighborhood_function object real(kind=wp), intent(in), dimension(:) :: parameters A real array with the paramters sigma and p procedure, public :: calculate => calculate_gaussian_neighborhood private  function calculate_gaussian_neighborhood(my_neigh_fn, geometric_distance) result(n) Function to calculate the value of the Gaussian neighborhood Arguments Type Intent Optional Attributes Name class( gaussian_neighborhood_function ) :: my_neigh_fn A gaussian_neighborhood_function object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric distnace Return Value real(kind=wp) A real value Source Code type , extends ( neighborhood_function_base ) :: gaussian_neighborhood_function !! Class that implements the Gaussian Neighborhood Function private real ( kind = wp ) :: sigma , p contains procedure , public :: create => create_gaussian_neighborhood procedure , public :: calculate => calculate_gaussian_neighborhood end type gaussian_neighborhood_function","tags":"","loc":"type\\gaussian_neighborhood_function.html"},{"title":"euclidean_distance – KohonenF08 ","text":"type, public, extends( distance_base ) :: euclidean_distance Class to calculate the euclidean distance Inherits type~~euclidean_distance~~InheritsGraph type~euclidean_distance euclidean_distance type~distance_base distance_base type~euclidean_distance->type~distance_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: calculate => calculate_euclidean_distance public  function calculate_euclidean_distance (distance, vector1, vector2) result(d) Function to calculate euclidean distance between vectors Arguments Type Intent Optional Attributes Name class( euclidean_distance ) :: distance A euclidean_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Source Code type , extends ( distance_base ) :: euclidean_distance !! Class to calculate the euclidean distance contains procedure , public :: calculate => calculate_euclidean_distance ! end type euclidean_distance","tags":"","loc":"type\\euclidean_distance.html"},{"title":"two_level_self_organizing_map – KohonenF08 ","text":"type, public, extends( kohonen_map_base ) :: two_level_self_organizing_map Class to represent a two level self_organized_map Inherits type~~two_level_self_organizing_map~~InheritsGraph type~two_level_self_organizing_map two_level_self_organizing_map type~distance_base distance_base type~two_level_self_organizing_map->type~distance_base distance_function type~factory_distance factory_distance type~two_level_self_organizing_map->type~factory_distance factory type~kohonen_layer_parameters kohonen_layer_parameters type~two_level_self_organizing_map->type~kohonen_layer_parameters parameters type~kohonen_map_base kohonen_map_base type~two_level_self_organizing_map->type~kohonen_map_base type~kohonen_prototype kohonen_prototype type~two_level_self_organizing_map->type~kohonen_prototype grid, cluster_layer type~rkiss05_generator rkiss05_generator type~two_level_self_organizing_map->type~rkiss05_generator rnumber_grator type~random_generator_base random_generator_base type~rkiss05_generator->type~random_generator_base Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: create => create_2lsom public  subroutine create_2lsom (kohonen_map, training_parameters) Constructor of a two_level self_organized_map class Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters structure procedure, public :: destroy => destroy_2lsom public  subroutine destroy_2lsom (kohonen_map) Destructor of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object procedure, public :: train => train_2lsom public  subroutine train_2lsom (kohonen_map, input_data) Subroutine to train a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array procedure, public :: predict => predict_2lsom public  subroutine predict_2lsom (kohonen_map, input_data, map_output) Subroutine to make a prediction from a trained two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array integer, intent(out), dimension(:,:) :: map_output An integer array procedure, public :: train_grid_layer public  subroutine train_grid_layer (kohonen_map, input_data) Subroutine to train the grid layer of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array procedure, public :: train_cluster_layer public  subroutine train_cluster_layer (kohonen_map) Subroutine to train the cluster layer of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object procedure, public :: print => print_2lsom public  subroutine print_2lsom (kohonen_map, unit_) Subroutine to print the layers of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer, optional :: unit_ An integer variable with the unit procedure, public :: query => query_2lsom public  subroutine query_2lsom (kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_pattern A real array integer, allocatable :: sample_index (:) An integer array procedure, public :: set_cluster_layer public  subroutine set_cluster_layer (kohonen_map, seed) Subroutine to initialize the cluster layer of a Two Level Self-Organizing Map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer :: seed An integer variable with the random seed procedure, public :: set_parameters public  subroutine set_parameters (kohonen_map, training_parameters) Subroutine to set parameters Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_layer_parameters ), dimension(2) :: training_parameters procedure, public :: read_som_layer public  subroutine read_som_layer (kohonen_map, som_fl, layer_type) Subroutine to read the prototypes of the first/seconf layer of a two level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object character(len=*) :: som_fl A character variable character(len=*) :: layer_type A character variable procedure, public :: calculate_sum2_clusters_samples => evaluate_2lsom public  subroutine evaluate_2lsom (kohonen_map, input_data, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array real(kind=wp), optional, dimension(:) :: results A real array procedure, public :: get_cluster_samples public  subroutine get_cluster_samples (kohonen_map, clusters) Accessor to cluster results obtained using a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer, intent(inout), dimension(:) :: clusters An integer array procedure, public :: calculate_sum2_clusters_grid public  subroutine calculate_sum2_clusters_grid (kohonen_map, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), optional, dimension(:) :: results A real array procedure, public, nopass :: external_train_map public  subroutine external_train_map (x, nvar, npat, som_type, nx1, ny1, nepoch1, alpha1, grid_type1, distance_type1, neigh_type1, toroidal1, nx2, nepoch2, alpha2, grid_type2, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_2lsom\") Subroutine to connect the two_level_self_organizing_map module to R o C\nUse iso_c_binding module Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real variables integer(kind=c_int), intent(in) :: nvar Integere variables integer(kind=c_int), intent(in) :: npat Integere variables integer(kind=c_int), intent(in) :: som_type Integere variables integer(kind=c_int), intent(in) :: nx1 Integere variables integer(kind=c_int), intent(in) :: ny1 Integere variables integer(kind=c_int), intent(in) :: nepoch1 Integere variables real(kind=c_double), intent(in) :: alpha1 Real variables integer(kind=c_int), intent(in) :: grid_type1 Integer variables integer(kind=c_int), intent(in) :: distance_type1 Integer variables integer(kind=c_int), intent(in) :: neigh_type1 Integer variables integer(kind=c_int), intent(in) :: toroidal1 Integere variables integer(kind=c_int), intent(in) :: nx2 Integer variables integer(kind=c_int), intent(in) :: nepoch2 Integer variables real(kind=c_double), intent(in) :: alpha2 Real variables integer(kind=c_int), intent(in) :: grid_type2 Integer variables real(kind=c_double), intent(out) :: prot (nx1*ny1,nvar) Real variables real(kind=c_double), intent(out) :: distortion (nepoch1) Real variables real(kind=c_double), intent(out) :: u_matrix (2*nx1-1,2*ny1-1) Real variables real(kind=c_double), intent(out) :: coords (nx1*ny1,3) Real variables integer(kind=c_int), intent(out) :: number_patterns (nx1,ny1) Integer variables integer(kind=c_int), intent(out) :: node_index (npat,3) Integer variables Source Code type , extends ( kohonen_map_base ) :: two_level_self_organizing_map private !!   Class to represent a two level self_organized_map type ( kohonen_prototype ), allocatable :: grid (:,:,:), cluster_layer (:) real ( kind = wp ), allocatable :: coordinates (:,:) integer , allocatable :: number_patterns (:,:,:), cells_index (:,:) integer , allocatable :: cluster_number_patterns (:), cluster_cells_index (:,:) integer , allocatable :: grid_cluster (:,:,:), cluster_samples (:) real ( kind = wp ), allocatable :: u_matrix (:,:,:), distance (:,:), cells_distances (:,:) integer , allocatable :: number_cluster_samples (:), index_cluster_samples (:,:) type ( kohonen_layer_parameters ), dimension ( 2 ) :: parameters type ( factory_distance ) :: factory class ( distance_base ), allocatable :: distance_function type ( rkiss05_generator ), dimension ( 2 ) :: rnumber_grator integer :: seed1 , seed2 integer :: number_variables , number_variables1 , number_variables2 , number_clusters integer :: number_nodes contains procedure , public :: create => create_2lsom procedure , public :: destroy => destroy_2lsom procedure , private :: create_random_sample procedure , public :: train => train_2lsom procedure , public :: predict => predict_2lsom procedure , public :: train_grid_layer procedure , public :: train_cluster_layer procedure , public :: print => print_2lsom procedure , public :: query => query_2lsom procedure , public :: set_cluster_layer procedure , public :: set_parameters !    procedure,public :: read => read_som procedure , private :: query_2lsom procedure , public :: read_som_layer procedure , private :: calculate_u_matrix procedure , private :: find_best_match_unit procedure , private :: update_weights procedure , private :: calculate_distance_between_prototypes procedure , private :: assign_input_to_clusters !procedure,public :: get_count => get_count_2lsom !procedure,public :: get_index => get_index_som !procedure,public :: get_u_matrix => get_u_matrix_som procedure , public :: calculate_sum2_clusters_samples => evaluate_2lsom procedure , public :: get_cluster_samples procedure , public :: calculate_sum2_clusters_grid procedure , nopass , private :: calculate_distance_matrix procedure , nopass , private :: calculate_coordinates ! procedure , nopass , public :: external_train_map !    procedure,nopass,public :: external_predict_map !***** end type two_level_self_organizing_map","tags":"","loc":"type\\two_level_self_organizing_map.html"},{"title":"distance_function1 – KohonenF08","text":"interface public  function distance_function1(distance, vector1, vector2) result(d) Arguments Type Intent Optional Attributes Name class( distance_base ) :: distance A distance_base object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Description Template for the calculate function\nImport section","tags":"","loc":"interface\\distance_function1.html"},{"title":"neighborhood_function_calculate – KohonenF08","text":"interface public  function neighborhood_function_calculate(my_neigh_fn, geometric_distance) result(n) Arguments Type Intent Optional Attributes Name class( neighborhood_function_base ) :: my_neigh_fn A neighborhood_function_base object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric or grid distance of a SOM unit Return Value real(kind=wp) A real variable with the value of the neighborhood function Description Subroutine template to calculate function\nImport section","tags":"","loc":"interface\\neighborhood_function_calculate.html"},{"title":"kohonen_map_constructor – KohonenF08","text":"interface public  subroutine kohonen_map_constructor(kohonen_map, training_parameters) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object Description Template function for the constructor of a kohonen map\nImport section","tags":"","loc":"interface\\kohonen_map_constructor.html"},{"title":"kohonen_map_destructor – KohonenF08","text":"interface public  subroutine kohonen_map_destructor(kohonen_map) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object Description Template function for the destructor of a kohonen map\nImport section","tags":"","loc":"interface\\kohonen_map_destructor.html"},{"title":"kohonen_map_function1 – KohonenF08","text":"interface public  subroutine kohonen_map_function1(kohonen_map, input_data) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects Description Template function for the training function of a kohonen map\nimport section","tags":"","loc":"interface\\kohonen_map_function1.html"},{"title":"kohonen_map_function2 – KohonenF08","text":"interface public  subroutine kohonen_map_function2(kohonen_map, input_data, map_output) Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects integer, intent(out), dimension(:,:) :: map_output An integer array Description Template function for the prediction function of a kohonen map\nimport section","tags":"","loc":"interface\\kohonen_map_function2.html"},{"title":"random_generator_generate – KohonenF08","text":"interface public  function random_generator_generate(generator) result(r) Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Return Value real(kind=wp) r: A real number Description Template of the function used to generate realizations of the random numbers in the \nclasses derived from the random_generator class.\nrandom_generator_base","tags":"","loc":"interface\\random_generator_generate.html"},{"title":"random_generator_constructor – KohonenF08","text":"interface public  subroutine random_generator_constructor(generator, iseed) Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random generator. Description Template of the constructor of the classes derived from the random_generator class.\nrandom_generator_base","tags":"","loc":"interface\\random_generator_constructor.html"},{"title":"random_generator_destructor – KohonenF08","text":"interface public  subroutine random_generator_destructor(generator) Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Description Template of the destructor of the classes derived from the random_generator class.\nrandom_generator_base","tags":"","loc":"interface\\random_generator_destructor.html"},{"title":"sort_procedure – KohonenF08","text":"interface public  subroutine sort_procedure(my_sort, list, order) Arguments Type Intent Optional Attributes Name class( sort_base ), intent(inout) :: my_sort my_sort: A sort_base object real(kind=wp), intent(inout), dimension(:) :: list list: A real vector integer, intent(inout), dimension(:) :: order order: An integer vector Description Subroutine to sort an array\nimport sort_base","tags":"","loc":"interface\\sort_procedure.html"},{"title":"genrand64_real1 – KohonenF08","text":"public  function genrand64_real1() Generates a random number on [0,1]-real-interval Arguments None Return Value real(kind=r64) Calls proc~~genrand64_real1~~CallsGraph proc~genrand64_real1 genrand64_real1 proc~init_genrand64 init_genrand64 proc~genrand64_real1->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r64 ) function genrand64_real1 () !! Generates a random number on [0,1]-real-interval implicit none genrand64_real1 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253_1 end function genrand64_real1","tags":"","loc":"proc\\genrand64_real1.html"},{"title":"genrand64_real2 – KohonenF08","text":"public  function genrand64_real2() Generates a random number on [0,1)-real-interval Arguments None Return Value real(kind=r64) Calls proc~~genrand64_real2~~CallsGraph proc~genrand64_real2 genrand64_real2 proc~init_genrand64 init_genrand64 proc~genrand64_real2->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r64 ) function genrand64_real2 () !! Generates a random number on [0,1)-real-interval implicit none genrand64_real2 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253 end function genrand64_real2","tags":"","loc":"proc\\genrand64_real2.html"},{"title":"genrand64_real3 – KohonenF08","text":"public  function genrand64_real3() Generates a random number on (0,1)-real-interval Arguments None Return Value real(kind=r64) Calls proc~~genrand64_real3~~CallsGraph proc~genrand64_real3 genrand64_real3 proc~init_genrand64 init_genrand64 proc~genrand64_real3->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r64 ) function genrand64_real3 () !! Generates a random number on (0,1)-real-interval implicit none genrand64_real3 = real ( ishft ( genrand64_int64 (), - 12 ), kind = r64 ) genrand64_real3 = ( genrand64_real3 + 0.5_r64 ) * pi252 end function genrand64_real3","tags":"","loc":"proc\\genrand64_real3.html"},{"title":"init_genrand64 – KohonenF08","text":"public  subroutine init_genrand64(seed) Initializes mt(nn) with a seed Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: seed Called by proc~~init_genrand64~~CalledByGraph proc~init_genrand64 init_genrand64 proc~genrand64_real1 genrand64_real1 proc~genrand64_real1->proc~init_genrand64 proc~genrand64_real2 genrand64_real2 proc~genrand64_real2->proc~init_genrand64 proc~genrand64_real3 genrand64_real3 proc~genrand64_real3->proc~init_genrand64 proc~init_by_array64 init_by_array64 proc~init_by_array64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_genrand64 ( seed ) !! Initializes mt(nn) with a seed implicit none integer ( i64 ), intent ( in ) :: seed integer :: i mt ( 1 ) = seed do i = 1 , nn - 1 mt ( i + 1 ) = 6364136223846793005_i64 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 )) + i end do mti = nn end subroutine init_genrand64","tags":"","loc":"proc\\init_genrand64.html"},{"title":"init_by_array64 – KohonenF08","text":"public  subroutine init_by_array64(init_key) Initializes by an array with array-length\n  init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: init_key (:) Calls proc~~init_by_array64~~CallsGraph proc~init_by_array64 init_by_array64 proc~init_genrand64 init_genrand64 proc~init_by_array64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_by_array64 ( init_key ) !! Initializes by an array with array-length !!   init_key is the array for initializing keys implicit none integer ( i64 ), intent ( in ) :: init_key (:) integer ( i64 ), parameter :: c1 = 3935559000370003845_i64 integer ( i64 ), parameter :: c2 = 2862933555777941757_i64 integer ( i64 ) :: i , j , k , kk , key_length call init_genrand64 ( 19650218_i64 ) key_length = size ( init_key ) i = 1_i64 ; j = 0_i64 k = max ( nn , key_length ) do kk = 1 , k mt ( i + 1 ) = ieor ( mt ( i + 1 ), c1 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) & + init_key ( j + 1 ) + j i = i + 1 ; j = j + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if if ( j >= key_length ) j = 0 end do do kk = 1 , nn - 1 mt ( i + 1 ) = ieor ( mt ( i + 1 ), c2 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) - i i = i + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if end do mt ( 1 ) = ishft ( 1_i64 , 63 ) ! MSB is 1; assuring non-zero initial array end subroutine init_by_array64","tags":"","loc":"proc\\init_by_array64.html"},{"title":"train_two_level_som – KohonenF08","text":"public  subroutine train_two_level_som(parameter_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: parameter_file Calls proc~~train_two_level_som~~CallsGraph proc~train_two_level_som train_two_level_som proc~calculate_sum2_clusters_grid two_level_self_organizing_map%calculate_sum2_clusters_grid proc~train_two_level_som->proc~calculate_sum2_clusters_grid proc~create_2lsom two_level_self_organizing_map%create_2lsom proc~train_two_level_som->proc~create_2lsom proc~destroy_2lsom two_level_self_organizing_map%destroy_2lsom proc~train_two_level_som->proc~destroy_2lsom proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create proc~train_two_level_som->proc~kohonen_pattern_create proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~train_two_level_som->proc~kohonen_pattern_destroy proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_two_level_som->proc~train_2lsom none~get_prototype kohonen_prototype%get_prototype proc~calculate_sum2_clusters_grid->none~get_prototype none~create~3 rkiss05_generator%create proc~create_2lsom->none~create~3 proc~calculate_distance_matrix~2 two_level_self_organizing_map%calculate_distance_matrix proc~create_2lsom->proc~calculate_distance_matrix~2 proc~create_distance factory_distance%create_distance proc~create_2lsom->proc~create_distance proc~create_random_sample~2 two_level_self_organizing_map%create_random_sample proc~create_2lsom->proc~create_random_sample~2 proc~position2index~2 position2index proc~create_2lsom->proc~position2index~2 none~destroy kohonen_prototype%destroy proc~destroy_2lsom->none~destroy none~create kohonen_prototype%create proc~kohonen_pattern_create->none~create proc~kohonen_pattern_destroy->none~destroy proc~assign_input_to_clusters two_level_self_organizing_map%assign_input_to_clusters proc~train_2lsom->proc~assign_input_to_clusters proc~train_cluster_layer two_level_self_organizing_map%train_cluster_layer proc~train_2lsom->proc~train_cluster_layer proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_2lsom->proc~train_grid_layer none~distance kohonen_prototype%distance proc~assign_input_to_clusters->none~distance proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~assign_input_to_clusters->proc~kohonen_pattern_accessor none~generate rkiss05_generator%generate proc~create_random_sample~2->none~generate proc~train_cluster_layer->none~get_prototype float float proc~train_cluster_layer->float proc~train_cluster_layer->none~distance none~set_prototype kohonen_prototype%set_prototype proc~train_cluster_layer->none~set_prototype proc~train_grid_layer->none~get_prototype proc~train_grid_layer->proc~position2index~2 proc~train_grid_layer->float proc~train_grid_layer->none~distance proc~train_grid_layer->none~set_prototype proc~calculate_distance_between_prototypes~2 two_level_self_organizing_map%calculate_distance_between_prototypes proc~train_grid_layer->proc~calculate_distance_between_prototypes~2 proc~calculate_u_matrix~2 two_level_self_organizing_map%calculate_u_matrix proc~train_grid_layer->proc~calculate_u_matrix~2 proc~index2position~2 index2position proc~train_grid_layer->proc~index2position~2 proc~train_grid_layer->proc~kohonen_pattern_accessor none~distance->none~get_prototype calculate calculate none~distance->calculate proc~calculate_distance_between_prototypes~2->proc~position2index~2 proc~calculate_u_matrix~2->none~distance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine train_two_level_som ( parameter_file ) !============================================================================== character ( len =* ), intent ( inout ) :: parameter_file ! call initialize_variables ( parameter_file ); ! call my_som % create ( som_parameters ); ! call my_som % train ( input_patterns ); ! if ( som_parameters ( 1 )% train_option == 0 ) then call my_som % calculate_sum2_clusters_grid (); endif ! call my_som % destroy (); ! call release_variables (); end subroutine train_two_level_som","tags":"","loc":"proc\\train_two_level_som.html"},{"title":"minimum – KohonenF08","text":"public  function minimum(a) result(mn) Function to calculate the minimum of an array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a Real array Return Value real(kind=wp) Real value with the minimum Source Code function minimum ( a ) result ( mn ) !=================================================================================================== !! Function to calculate the minimum of an array real ( kind = wp ), dimension (:) :: a !! Real array real ( kind = wp ) :: mn !! Real value with the minimum integer :: i , number_elements mn = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . lt . mn ) then mn = a ( i ) endif enddo ! end function minimum","tags":"","loc":"proc\\minimum.html"},{"title":"mean – KohonenF08","text":"public  function mean(a) result(mn) Function to calculate the mean of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real value with the calculated mean Calls proc~~mean~~CallsGraph proc~mean mean float float proc~mean->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mean~~CalledByGraph proc~mean mean proc~coefficient_of_variation coefficient_of_variation proc~coefficient_of_variation->proc~mean proc~std std proc~coefficient_of_variation->proc~std proc~variance variance proc~variance->proc~mean proc~std->proc~variance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function mean ( a ) result ( mn ) !============================================================================================= !! Function to calculate the mean of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: mn !! A real value with the calculated mean mn = sum ( a ) / float ( size ( a )); ! end function mean","tags":"","loc":"proc\\mean.html"},{"title":"variance – KohonenF08","text":"public  function variance(a) result(v) Function to calculate the variance of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated variance Calls proc~~variance~~CallsGraph proc~variance variance proc~mean mean proc~variance->proc~mean float float proc~mean->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~variance~~CalledByGraph proc~variance variance proc~std std proc~std->proc~variance proc~coefficient_of_variation coefficient_of_variation proc~coefficient_of_variation->proc~std Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function variance ( a ) result ( v ) !============================================================================================= !! Function to calculate the variance of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: v !! A real variable with the calculated variance real ( kind = wp ), dimension ( size ( a )) :: a2 ! a2 = a ** 2 ; v = mean ( a2 ) - ( mean ( a )) ** 2 ; ! end function variance","tags":"","loc":"proc\\variance.html"},{"title":"std – KohonenF08","text":"public  function std(a) result(s) Function to calculate the standard deviation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated standard deviation Calls proc~~std~~CallsGraph proc~std std proc~variance variance proc~std->proc~variance proc~mean mean proc~variance->proc~mean float float proc~mean->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~std~~CalledByGraph proc~std std proc~coefficient_of_variation coefficient_of_variation proc~coefficient_of_variation->proc~std Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function std ( a ) result ( s ) !============================================================================================= !! Function to calculate the standard deviation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: s !! A real variable with the calculated standard deviation real ( kind = wp ) :: v ! v = variance ( a ); s = sqrt ( v ); ! end function std","tags":"","loc":"proc\\std.html"},{"title":"coefficient_of_variation – KohonenF08","text":"public  function coefficient_of_variation(a) result(cov) Function to calculate the coefficient of variation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated coefficient of variation Calls proc~~coefficient_of_variation~~CallsGraph proc~coefficient_of_variation coefficient_of_variation proc~mean mean proc~coefficient_of_variation->proc~mean proc~std std proc~coefficient_of_variation->proc~std float float proc~mean->float proc~variance variance proc~std->proc~variance proc~variance->proc~mean Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function coefficient_of_variation ( a ) result ( cov ) !============================================================================================ !! Function to calculate the coefficient of variation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: cov !! A real variable with the calculated coefficient of variation cov = std ( a ) / mean ( a ); end function coefficient_of_variation","tags":"","loc":"proc\\coefficient_of_variation.html"},{"title":"maximum – KohonenF08","text":"public interface maximum Module Procedures private  subroutine maximum_only(a, mx) Subroutine to calculate the maximum of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a real(kind=wp) :: mx private  subroutine maximum_position(a, mx, p) Subroutine to find the position of the maximum value of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a A real array real(kind=wp) :: mx A real value with the maximum integer :: p An integer value with the position of the maximum","tags":"","loc":"interface\\maximum.html"},{"title":"train_som – KohonenF08","text":"public  subroutine train_som(parameter_file) Subroutine to train the SOM Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: parameter_file A character variable with the name of the parameter file Calls proc~~train_som~~CallsGraph proc~train_som train_som error_stop error_stop proc~train_som->error_stop none~configure logger%configure proc~train_som->none~configure none~create~7 logger%create proc~train_som->none~create~7 none~delimiter logger%delimiter proc~train_som->none~delimiter none~is_initialized logger%is_initialized proc~train_som->none~is_initialized none~message~5 logger%message proc~train_som->none~message~5 none~shutdown logger%shutdown proc~train_som->none~shutdown none~startup logger%startup proc~train_som->none~startup proc~create_som self_organizing_map%create_som proc~train_som->proc~create_som proc~destroy_som self_organizing_map%destroy_som proc~train_som->proc~destroy_som proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~train_som->proc~kohonen_pattern_destroy proc~train_som_data self_organizing_map%train_som_data proc~train_som->proc~train_som_data none~error logger%error none~configure->none~error none~delimiter->none~message~5 none~get_delimiter logger%get_delimiter none~delimiter->none~get_delimiter none~startup->none~error proc~create_som->error_stop none~create~3 rkiss05_generator%create proc~create_som->none~create~3 proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som->proc~calculate_distance_matrix proc~create_distance factory_distance%create_distance proc~create_som->proc~create_distance proc~create_random_sample self_organizing_map%create_random_sample proc~create_som->proc~create_random_sample proc~position2index self_organizing_map%position2index proc~create_som->proc~position2index none~destroy kohonen_prototype%destroy proc~destroy_som->none~destroy proc~kohonen_pattern_destroy->none~destroy none~get_prototype kohonen_prototype%get_prototype proc~train_som_data->none~get_prototype proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data->proc~calculate_distance_between_prototypes proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data->proc~calculate_u_matrix proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data->proc~find_best_match_unit proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~train_som_data->proc~kohonen_pattern_accessor proc~update_weights self_organizing_map%update_weights proc~train_som_data->proc~update_weights proc~calculate_distance_between_prototypes->proc~position2index none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance none~generate rkiss05_generator%generate proc~create_random_sample->none~generate float float proc~find_best_match_unit->float proc~find_best_match_unit->none~distance proc~update_weights->none~get_prototype proc~update_weights->proc~position2index dexp dexp proc~update_weights->dexp none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine train_som ( parameter_file ) !============================================================================== !! Subroutine to train the SOM character ( len =* ), intent ( inout ) :: parameter_file !! A character variable with the name of the parameter file call initialize_variables ( parameter_file ); ! call my_som % create ( som_parameters ); ! call my_som % train ( input_patterns ); ! call my_som % destroy (); ! call release_variables (); ! end subroutine train_som","tags":"","loc":"proc\\train_som.html"},{"title":"initialize_variables – KohonenF08","text":"public  subroutine initialize_variables(par_file) Arguments Type Intent Optional Attributes Name character(len=*) :: par_file Calls proc~~initialize_variables~3~~CallsGraph proc~initialize_variables~3 initialize_variables none~read_parameters kohonen_layer_parameters%read_parameters proc~initialize_variables~3->none~read_parameters proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create proc~initialize_variables~3->proc~kohonen_pattern_create none~create kohonen_prototype%create proc~kohonen_pattern_create->none~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: testfl integer, public :: ipar integer, public :: ipat integer, public :: isom integer, public :: iout integer, public :: ierr integer, public :: number_patterns integer, public :: train_option integer, public :: ipattern integer, public :: nvar1 integer, public :: nvar2 integer, public :: ivar integer, public :: i integer, public :: j character(len=NUMCHAR), public :: input_file character(len=NUMCHAR), public :: output_file character(len=NUMCHAR), public :: current_line character(len=NUMCHAR), public :: current_file real(kind=wp), public, allocatable :: var (:,:) character(len=NUMCHAR), public, allocatable :: pattern_files (:) Source Code subroutine initialize_variables ( par_file ) ! character ( len =* ) :: par_file ! logical :: testfl integer :: ipar , ipat , isom , iout , ierr , number_patterns , train_option integer :: ipattern , nvar1 , nvar2 , ivar , i , j character ( len = NUMCHAR ) :: input_file , output_file , current_line character ( len = NUMCHAR ) :: current_file real ( kind = wp ), allocatable :: var (:,:) character ( len = NUMCHAR ), allocatable :: pattern_files (:) ! ipar = 1 ; ipat = 2 ; isom = 3 ; ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR: the som predict parameter file does not exist' endif open ( ipar , file = trim ( par_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'SOM_PREDICT_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo read ( ipar , * , err = 90 ) train_option read ( ipar , '(A40)' , err = 90 ) som_parameter_file read ( ipar , '(A40)' , err = 90 ) prototype_file read ( ipar , '(A40)' , err = 90 ) input_file read ( ipar , * , err = 90 ) number_patterns read ( ipar , * , err = 90 ) nvar1 , nvar2 read ( ipar , '(A40)' , err = 90 ) output_file close ( ipar ); write ( * , * ) 'Reading parameter file...finished!' ! inquire ( file = trim ( som_parameter_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the som parameter file does not exist' ; endif write ( * , * ) 'Reading SOM parameter file...' ; open ( isom , file = trim ( som_parameter_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); call som_parameters ( 1 )% read_parameters ( isom ); close ( isom ); write ( * , * ) 'Reading SOM parameter file...OK!' ; ! som_parameters ( 1 )% idbg = 10 ; som_parameters ( 1 )% iout = 11 ; som_parameters ( 1 )% iindex = 12 ; som_parameters ( 1 )% iprot = 13 ; som_parameters ( 1 )% ihit = 14 ; som_parameters ( 1 )% idist = 15 ; som_parameters ( 1 )% iumat = 16 ; som_parameters ( 1 )% ipar = 17 ; ! inquire ( file = trim ( prototype_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the prototype file does not exist' ; endif allocate ( input_patterns ( number_patterns ), stat = ierr ); allocate ( map_output ( number_patterns , 3 ), stat = ierr ); allocate ( var ( nvar1 , nvar2 ), stat = ierr ); ! if ( train_option . eq . 0 ) then write ( * , * ) 'Reading input file...' ; inquire ( file = trim ( input_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the input pattern file does not exist' ; endif open ( ipat , file = trim ( input_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); do ipattern = 1 , number_patterns read ( ipat , * , err = 91 ) ( var ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ) call input_patterns ( ipattern )% create ( var ); enddo !ipatterh close ( ipar ) write ( * , * ) 'Reading input file...finished!' ; elseif ( train_option . eq . 1 ) then allocate ( pattern_files ( number_patterns ), stat = ierr ); write ( * , * ) 'Reading input file names...' ; inquire ( file = trim ( input_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the input pattern file with names does not exist' ; endif open ( ipar , file = trim ( input_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); do ipattern = 1 , number_patterns read ( ipar , '(A)' , err = 91 ) pattern_files ( ipattern ); enddo close ( ipar ); ! do ipattern = 1 , number_patterns open ( ipat , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' , access = 'sequential' ); do i = 1 , nvar1 read ( ipat , * , err = 92 ) ( var ( i , j ), j = 1 , nvar2 ); enddo close ( ipat ); enddo write ( * , * ) 'Reading input file names...finished!' ; endif ! current_file = trim ( output_file ); open ( som_parameters ( 1 )% iout , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); ! deallocate ( var ); if ( allocated ( pattern_files )) deallocate ( pattern_files ) ! return 90 stop 'ERROR while reading parameter file' 91 stop 'ERROR while reading pattern file' 92 stop 'ERROR while reading a input pattern file' ! end subroutine initialize_variables","tags":"","loc":"proc\\initialize_variables~3.html"},{"title":"release_variables – KohonenF08","text":"public  subroutine release_variables() Arguments None Calls proc~~release_variables~3~~CallsGraph proc~release_variables~3 release_variables proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~release_variables~3->proc~kohonen_pattern_destroy none~destroy kohonen_prototype%destroy proc~kohonen_pattern_destroy->none~destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i logical, public :: testop Source Code subroutine release_variables () ! integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( map_output )) then !do i=1,size(map_output) !   call map_output(i)%destroy(); !enddo deallocate ( map_output ); endif ! inquire ( unit = som_parameters ( 1 )% iout , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iout ) endif ! end subroutine release_variables","tags":"","loc":"proc\\release_variables~3.html"},{"title":"position2index – KohonenF08","text":"public  function position2index(ix, iy, iz, nx, ny) result(index_) Function to calculate the index inside a rectangular grid from position ix,iy,iz Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix Integer variables integer, intent(in) :: iy Integer variables integer, intent(in) :: iz Integer variables integer, intent(in) :: nx Integer variables integer, intent(in) :: ny Integer variables Return Value integer Integer variable with the required index Called by proc~~position2index~~CalledByGraph proc~position2index self_organizing_map%position2index proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~calculate_distance_between_prototypes->proc~position2index proc~create_som self_organizing_map%create_som proc~create_som->proc~position2index proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~position2index proc~train_som_data self_organizing_map%train_som_data proc~external_train_map->proc~train_som_data proc~read_som self_organizing_map%read_som proc~read_som->proc~position2index proc~update_weights self_organizing_map%update_weights proc~update_weights->proc~position2index proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som train_som proc~train_som->proc~create_som proc~train_som->proc~train_som_data proc~train_som_data->proc~calculate_distance_between_prototypes proc~train_som_data->proc~update_weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function position2index ( ix , iy , iz , nx , ny ) result ( index_ ) !======================================================================================== !! Function to calculate the index inside a rectangular grid from position ix,iy,iz integer , intent ( in ) :: ix , iy , iz , nx , ny !! Integer variables integer :: index_ !! Integer variable with the required index index_ = ix + ( iy - 1 ) * nx + ( iz - 1 ) * nx * ny ; ! end function position2index","tags":"","loc":"proc\\position2index.html"},{"title":"calculate_sigma – KohonenF08","text":"public  function calculate_sigma(kohonen_map, input_data, seed) result(sigma) Function to calculate the scaling factor sigma Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_data A real array with the input data integer, intent(inout), optional :: seed An integer with the random seed Return Value real(kind=wp) A real variable with the value of sigma Calls proc~~calculate_sigma~~CallsGraph proc~calculate_sigma self_organizing_map%calculate_sigma none~generate rkiss05_generator%generate proc~calculate_sigma->none~generate none~sort quicksort%sort proc~calculate_sigma->none~sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ndat integer, public :: nvar integer, public :: seed1 integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nxyz integer, public :: ierr integer, public :: i integer, public :: j real(kind=wp), public, allocatable :: sample_pos (:) real(kind=wp), public, allocatable :: p_vector (:,:) real(kind=wp), public, allocatable :: sigma_table (:,:) real(kind=wp), public, allocatable :: current_sigma (:) integer, public, allocatable :: sample_index (:) type( quicksort ), public :: qsort Source Code function calculate_sigma ( kohonen_map , input_data , seed ) result ( sigma ) !======================================================================================== !!    Function to calculate the scaling factor sigma class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_data !! A real array with the input data integer , intent ( inout ), optional :: seed !! An integer with the random seed real ( kind = wp ) :: sigma !! A real variable with the value of sigma integer :: ndat , nvar , seed1 , nx , ny , nz , nxyz , ierr , i , j real ( kind = wp ), allocatable :: sample_pos (:), p_vector (:,:), sigma_table (:,:) real ( kind = wp ), allocatable :: current_sigma (:) integer , allocatable :: sample_index (:) type ( quicksort ) :: qsort ! if (. not . present ( seed )) then seed1 = 12345 ; else seed1 = seed ; endif ! ndat = size ( input_data , 1 ); nvar = size ( input_data , 2 ); ! !kohonen_map%parameters=training_parameters(1); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; nxyz = nx * ny * nz ; allocate ( sample_pos ( ndat ), stat = ierr ); allocate ( sample_index ( ndat ), stat = ierr ); allocate ( p_vector ( nxyz , nvar ), stat = ierr ); allocate ( sigma_table ( ndat , nxyz ), stat = ierr ); allocate ( current_sigma ( ndat ), stat = ierr ); !call sgrnd(seed1); do i = 1 , size ( sample_pos ); sample_pos ( i ) = kohonen_map % rnumber_grator % generate (); enddo !call grnd_array(sample_pos); do i = 1 , nxyz sample_index ( i ) = i ; enddo ! call qsort % sort ( sample_pos , sample_index ); ! !  define p vector (See Lopez-Rubio et al, 2015) ! p_vector ( 1 : nxyz , 1 : nvar ) = input_data ( sample_index ( 1 : nxyz ), 1 : nvar ); ! !  Calculate the distance between the input data and the selected prototypes ! do i = 1 , ndat do j = 1 , nxyz sigma_table ( i , j ) = sum (( input_data ( i ,:) - p_vector ( j ,:)) ** 2 ); enddo enddo ! do j = 1 , nxyz current_sigma ( 1 : ndat ) = sigma_table ( 1 : ndat , j ); !(sample_index(i)=i,i=1,ndat) call qsort % sort ( current_sigma , sample_index ); !    if(current_sigma(1) > 1d-10) then !       current_sigma_value() enddo ! deallocate ( sample_pos , sample_index , p_vector , sigma_table , current_sigma ); ! end function calculate_sigma","tags":"","loc":"proc\\calculate_sigma.html"},{"title":"create_som – KohonenF08","text":"public  subroutine create_som(kohonen_map, training_parameters) Constructor for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object Calls proc~~create_som~~CallsGraph proc~create_som self_organizing_map%create_som error_stop error_stop proc~create_som->error_stop none~create~3 rkiss05_generator%create proc~create_som->none~create~3 proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som->proc~calculate_distance_matrix proc~create_distance factory_distance%create_distance proc~create_som->proc~create_distance proc~create_random_sample self_organizing_map%create_random_sample proc~create_som->proc~create_random_sample proc~position2index self_organizing_map%position2index proc~create_som->proc~position2index none~generate rkiss05_generator%generate proc~create_random_sample->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_som~~CalledByGraph proc~create_som self_organizing_map%create_som proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som train_som proc~train_som->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=NUMCHAR), public, parameter :: fname = 'create_som' A character variable with the name of the function integer, public :: ierr integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: nvar1 integer, public :: nvar2 integer, public :: seed integer, public :: current_index integer, public :: nepoch integer, public :: i integer, public :: j real(kind=wp), public, allocatable :: input (:,:) character(len=NUMCHAR), public :: base_message character(len=NUMCHAR), public :: message Source Code subroutine create_som ( kohonen_map , training_parameters ) !======================================================================================== !!   Constructor for self_organizing_map character ( len = NUMCHAR ), parameter :: fname = 'create_som' !! A character variable with the name of the function class ( self_organizing_map ) :: kohonen_map !! A  `self_organizing_map` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` object integer :: ierr , nx , ny , nz , ix , iy , iz , nvar1 , nvar2 , seed , current_index , nepoch integer :: i , j real ( kind = wp ), allocatable :: input (:,:) character ( len = NUMCHAR ) :: base_message , message ! base_message = trim ( kohonen_map % class_name ) // '_' // trim ( fname ) // '_ERROR' ; ! kohonen_map % parameters = training_parameters ( 1 ); nx = training_parameters ( 1 )% number_nodes_nx ; ny = training_parameters ( 1 )% number_nodes_ny ; nz = training_parameters ( 1 )% number_nodes_nz ; nvar1 = training_parameters ( 1 )% number_variables1 ; nvar2 = training_parameters ( 1 )% number_variables2 ; nepoch = training_parameters ( 1 )% number_epochs ; write ( * , * ) 'Create= ' , nx , ny , nz , nvar1 , nvar2 , nepoch ; allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % grid_pattern_index ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid_pattern_index array' ; call error_stop ( message ); endif ! allocate ( input ( nvar1 , nvar2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for input array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % number_patterns ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for number_patterns array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % cells_index ( training_parameters ( 1 )% number_patterns , 3 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for cell_index array' ; call error_stop ( message ); endif ! kohonen_map % number_patterns = 0 ; kohonen_map % cells_index = 0 ; allocate ( kohonen_map % u_matrix ( 2 * nx - 1 , 2 * ny - 1 , 2 * nz - 1 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for u_matrix array' ; call error_stop ( message ); endif kohonen_map % u_matrix = 0.0_wp ; ! allocate ( kohonen_map % distance ( nx * ny , nx * ny ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for distance array' ; call error_stop ( message ); endif kohonen_map % distance = 0.0_wp ; ! allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); kohonen_map % cells_distances = 0.0d0 ; allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); kohonen_map % coordinates = 0.0d0 ; allocate ( kohonen_map % distortion ( nepoch ), stat = ierr ); kohonen_map % distortion = 0.0d0 ; ! call kohonen_map % factory % create_distance ( training_parameters ( 1 )% distance_type ,& kohonen_map % distance_function ); ! kohonen_map % seed = training_parameters ( 1 )% random_seed_ ( 1 ); call kohonen_map % rnumber_grator % create ( kohonen_map % seed ); ! do i=1,nvar1; !     do j=1,nvar2; !         input(i,j)=kohonen_map%rnumber_grator%generate(); !         !write(*,*) 'input= ',input(i,j); !     enddo ! enddo ! write ( * , * ) 'SOM: Initializing grid...' , kohonen_map % seed ; do iz = 1 , nz ; do iy = 1 , ny ; do ix = 1 , nx ; !write(*,*) 'creating ',ix,iy,iz call kohonen_map % create_random_sample ( input ); call kohonen_map % grid ( ix , iy , iz )% create ( input ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , training_parameters ( 1 )% node_type ); enddo !ix enddo !iy enddo !iz deallocate ( input ); ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& training_parameters ( 1 )% node_type , training_parameters ( 1 )% toroidal_grid ); write ( * , * ) 'SOM: Initializing grid...OK' ; ! end subroutine create_som","tags":"","loc":"proc\\create_som.html"},{"title":"destroy_som – KohonenF08","text":"public  subroutine destroy_som(kohonen_map) Destructor for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Calls proc~~destroy_som~~CallsGraph proc~destroy_som self_organizing_map%destroy_som none~destroy kohonen_prototype%destroy proc~destroy_som->none~destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_som~~CalledByGraph proc~destroy_som self_organizing_map%destroy_som proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~destroy_som proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~destroy_som proc~train_som train_som proc~train_som->proc~destroy_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz Source Code subroutine destroy_som ( kohonen_map ) !======================================================================================== !!   Destructor for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: ix , iy , iz ! !       write(*,*) 'SOM: Releasing memory...' if ( allocated ( kohonen_map % grid )) then do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif ! if ( allocated ( kohonen_map % number_patterns )) then deallocate ( kohonen_map % number_patterns ); endif ! if ( allocated ( kohonen_map % cells_index )) then deallocate ( kohonen_map % cells_index ); endif ! if ( allocated ( kohonen_map % u_matrix )) then deallocate ( kohonen_map % u_matrix ); endif ! if ( allocated ( kohonen_map % distance_function )) then deallocate ( kohonen_map % distance_function ); endif ! if ( allocated ( kohonen_map % distance )) then deallocate ( kohonen_map % distance ); endif ! if ( allocated ( kohonen_map % cells_distances )) then deallocate ( kohonen_map % cells_distances ); endif ! if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif ! if ( allocated ( kohonen_map % distortion )) then deallocate ( kohonen_map % distortion ) endif ! if ( allocated ( kohonen_map % grid_pattern_index )) then deallocate ( kohonen_map % grid_pattern_index ); endif ! if ( allocated ( kohonen_map % list_node_grid )) then deallocate ( kohonen_map % list_node_grid ); endif call kohonen_map % rnumber_grator % destroy (); ! !        write(*,*) 'SOM: Releasing memory...OK!' ! end subroutine destroy_som","tags":"","loc":"proc\\destroy_som.html"},{"title":"create_random_sample – KohonenF08","text":"public  subroutine create_random_sample(kohonen_map, input) Subroutine to generate random values that serve as inputs to the SOM Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: input A real array with the initial values of the prototypes Calls proc~~create_random_sample~~CallsGraph proc~create_random_sample self_organizing_map%create_random_sample none~generate rkiss05_generator%generate proc~create_random_sample->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_random_sample~~CalledByGraph proc~create_random_sample self_organizing_map%create_random_sample proc~create_som self_organizing_map%create_som proc~create_som->proc~create_random_sample proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som train_som proc~train_som->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nvar1 integer, public :: nvar2 integer, public :: i integer, public :: j Source Code subroutine create_random_sample ( kohonen_map , input ) !======================================================================================== !! Subroutine to generate random values that serve as inputs to the SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: input !! A real array with the initial values of the prototypes integer :: nvar1 , nvar2 , i , j ! nvar1 = size ( input , 1 ); nvar2 = size ( input , 2 ); do i = 1 , nvar1 ; do j = 1 , nvar2 ; input ( i , j ) = kohonen_map % rnumber_grator % generate (); end do end do ! end subroutine create_random_sample","tags":"","loc":"proc\\create_random_sample.html"},{"title":"train_som_data – KohonenF08","text":"public  subroutine train_som_data(kohonen_map, input_data) Training function for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data Calls proc~~train_som_data~~CallsGraph proc~train_som_data self_organizing_map%train_som_data none~get_prototype kohonen_prototype%get_prototype proc~train_som_data->none~get_prototype proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data->proc~calculate_distance_between_prototypes proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data->proc~calculate_u_matrix proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data->proc~find_best_match_unit proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~train_som_data->proc~kohonen_pattern_accessor proc~update_weights self_organizing_map%update_weights proc~train_som_data->proc~update_weights proc~position2index self_organizing_map%position2index proc~calculate_distance_between_prototypes->proc~position2index none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance float float proc~find_best_match_unit->float proc~find_best_match_unit->none~distance proc~update_weights->none~get_prototype dexp dexp proc~update_weights->dexp none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position proc~update_weights->proc~position2index none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~train_som_data~~CalledByGraph proc~train_som_data self_organizing_map%train_som_data proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_som train_som proc~train_som->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: iteration integer, public :: iepoch integer, public :: ipattern integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: jhit integer, public :: ihit integer, public :: khit integer, public :: ineigh integer, public :: jneigh integer, public :: kneigh integer, public :: idbg integer, public :: number_variables integer, public :: idisto integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: i integer, public :: j integer, public :: k integer, public :: number_nodes integer, public :: debug_option integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 integer, public :: pos integer, public :: pos1 integer, public :: max_pattern integer, public :: ierr integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ipos integer, public :: current_pos integer, public :: ic integer, public :: itemp real(kind=wp), public :: distortion real(kind=wp), public :: dist real(kind=wp), public :: dist_hit real(kind=wp), public :: maximum_radius real(kind=wp), public :: minimum_radius real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: u_temp type( kohonen_prototype ), public :: current_prototype real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_values integer, public, allocatable :: pattern_index (:,:,:,:) integer, public, allocatable :: positions (:) Source Code subroutine train_som_data ( kohonen_map , input_data ) !======================================================================================== !!   Training function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: iteration , iepoch , ipattern , ix , iy , iz , jhit , ihit , khit , ineigh , jneigh integer :: kneigh , idbg , number_variables , idisto !neff, integer :: cx , cy , cz , i , j , k , number_nodes , debug_option , ix1 , iy1 , iz1 , pos , pos1 , max_pattern integer :: ierr , nx , ny , nz , ipos integer :: current_pos , ic , itemp real ( kind = wp ) :: distortion , dist , dist_hit , maximum_radius , minimum_radius real ( kind = wp ) :: current_radius , alpha , u_temp type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values integer , allocatable :: pattern_index (:,:,:,:), positions (:) ! ! ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; allocate ( positions ( nx * ny * nz ), stat = ierr ); idbg = kohonen_map % parameters % idbg ; idisto = kohonen_map % parameters % idisto ; debug_option = kohonen_map % parameters % debug_level ; if ( debug_option > 0 ) then open ( idbg , file = trim ( kohonen_map % parameters % debug_file ), status = 'unknown' ); endif iteration = 0 ; distortion = 0.0_wp ; number_variables = kohonen_map % parameters % number_variables1 * kohonen_map % parameters % number_variables2 ; maximum_radius = dble ( max ( kohonen_map % parameters % number_nodes_nx , kohonen_map % parameters % number_nodes_ny )); minimum_radius = 1.0_wp ; write ( * , * ) 'SOM: Training starting...' do iepoch = 1 , kohonen_map % parameters % number_epochs ; kohonen_map % distortion ( iepoch ) = distortion ; write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion ; if ( iepoch > 1 ) write ( idisto , * ) iepoch , distortion distortion = 0.0_wp ; do ipattern = 1 , kohonen_map % parameters % number_patterns ; iteration = iteration + 1 ; ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); call current_prototype % get_prototype ( current_values ); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); !write(*,*) 'Test= ',ipattern,ihit,jhit,khit,dist_hit if ( debug_option > 0 ) then write ( idbg , * ) 'Epoch,Current Pattern' , iepoch , ipattern ; call current_prototype % print ( idbg ); endif distortion = distortion + dist_hit ; if ( debug_option > 0 ) then write ( idbg , * ) 'Neighborhood,alpha= ' , alpha ; endif call kohonen_map % update_weights ( current_values , ihit , jhit , khit , maximum_radius , iteration ); ! enddo !ipattern enddo !iepoch !       write(*,*) 'SOM: Training finished' !       write(*,*) 'Total number of iterations= ',iteration !     print prototypes ! if(kohonen_map%parameters%train_option < 3) then ! do iz=1,size(kohonen_map%grid,3) !    !write(kohonen_map%parameters%iprot,'(A,I4)') 'Layer ',iz !    do iy=1,size(kohonen_map%grid,2); !       do ix=1,size(kohonen_map%grid,1); !          !write(kohonen_map%parameters%iprot,'(A6,1X,3I4)') 'node= ',ix,iy,iz !          call kohonen_map%grid(ix,iy,iz)%print(kohonen_map%parameters%iprot); !       enddo !    enddo ! enddo!ix ! endif !     calculate and print distance matrix call kohonen_map % calculate_distance_between_prototypes (); !     final best match !      call kohonen_map%find_bmu_grid(input_data); max_pattern = 0 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); kohonen_map % number_patterns ( ihit , jhit , khit ) = kohonen_map % number_patterns ( ihit , jhit , khit ) + 1 ; if ( kohonen_map % number_patterns ( ihit , jhit , khit ) > max_pattern ) then max_pattern = kohonen_map % number_patterns ( ihit , jhit , khit ); endif kohonen_map % cells_index ( ipattern , 1 ) = ihit ; kohonen_map % cells_index ( ipattern , 2 ) = jhit ; kohonen_map % cells_index ( ipattern , 3 ) = khit ; if ( debug_option > 0 ) then write ( idbg , * ) ipattern , ihit , jhit , khit ; endif !if(kohonen_map%parameters%train_option < 3) then !   write(kohonen_map%parameters%iindex,*) ipattern,ihit,jhit,khit !endif !         write(*,*) 'BMU= ',ipattern,ihit,jhit,khit,dist_hit ! enddo !ipattern ! allocate ( pattern_index ( size ( kohonen_map % grid , 1 ),& size ( kohonen_map % grid , 2 ), size ( kohonen_map % grid , 3 ),& max_pattern ), stat = ierr ); pattern_index =- 1 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); do i = 1 , max_pattern ; if ( pattern_index ( ix , iy , iz , i ) < 0 ) then pattern_index ( ix , iy , iz , i ) = ipattern ; exit ; endif enddo enddo !ipattern if ( kohonen_map % parameters % train_option < 3 ) then do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % isam , '(A,3I4)' ) 'Node= ' , ix1 , iy1 , iz1 if ( kohonen_map % number_patterns ( ix1 , iy1 , iz1 ) > 0 ) then write ( kohonen_map % parameters % isam , '(A,10000I5)' ) 'Sample ID= ' ,& pattern_index ( ix1 , iy1 , iz1 , 1 : kohonen_map % number_patterns ( ix1 , iy1 , iz1 )); else write ( kohonen_map % parameters % isam , '(A,I4)' ) 'Sample ID= ' , 0 endif enddo enddo enddo deallocate ( pattern_index ); endif ! if ( debug_option . gt . 0 ) then close ( idbg ); endif close ( idisto ); !     print hit counter if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % grid , 3 ) do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % ihit , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % grid , 2 )); enddo !ix enddo endif call kohonen_map % calculate_u_matrix (); ! end subroutine train_som_data","tags":"","loc":"proc\\train_som_data.html"},{"title":"predict_som – KohonenF08","text":"public  subroutine predict_som(kohonen_map, input_data, map_output) Function for Prediction of a self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data integer, intent(out), dimension(:,:) :: map_output An integer array with the map output Calls proc~~predict_som~~CallsGraph proc~predict_som self_organizing_map%predict_som float float proc~predict_som->float none~distance kohonen_prototype%distance proc~predict_som->none~distance none~get_prototype kohonen_prototype%get_prototype proc~predict_som->none~get_prototype proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~predict_som->proc~kohonen_pattern_accessor none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~predict_som~~CalledByGraph proc~predict_som self_organizing_map%predict_som proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~predict_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ipattern integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: number_variables integer, public :: i integer, public :: j integer, public :: k real(kind=wp), public :: dist_hit real(kind=wp), public :: dist type( kohonen_prototype ), public :: current_prototype real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_values Source Code subroutine predict_som ( kohonen_map , input_data , map_output ) !======================================================================================== !! Function for Prediction of a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer , dimension (:,:), intent ( out ) :: map_output !! An integer array with the map output integer :: ipattern , ihit , jhit , khit , ix , iy , iz , number_variables , i , j , k real ( kind = wp ) :: dist_hit , dist type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values ! number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ; ! !       write(*,*) 'SOM: Prediction starting...'; !       write(*,*) number_variables do ipattern = 1 , size ( input_data , 1 ) ihit = 0 ; jhit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%print(); !write(*,*) ihit,jhit,dist_hit !call current_prototype%get_prototype(current_values); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; !write(*,*) ix,iy,dist !call kohonen_map%grid(ix,iy)%print(); dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo ! !$OMP end parallel do ! call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( current_values ); ! if(size(current_values,2) .eq. 1) then !   write(kohonen_map%parameters%iout,*) (current_values(i,1),& !         i=1,size(current_values,1)); ! else !   do i=1,size(current_values,1) !      write(kohonen_map%parameters%iout,*) (current_values(i,j),j=1,& !            size(current_values,2)) !   enddo ! endif !call map_output(ipattern)%create(current_values); map_output ( ipattern , 1 ) = ihit ; map_output ( ipattern , 2 ) = jhit ; map_output ( ipattern , 3 ) = khit ; !size(current_values,1),size(current_values,2) !write(*,*) current_values enddo !ipattern !       write(*,*) 'SOM: Prediction finished'; ! end subroutine predict_som","tags":"","loc":"proc\\predict_som.html"},{"title":"print_som – KohonenF08","text":"public  subroutine print_som(kohonen_map, unit_) Print function for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), optional :: unit_ Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: unit1 Source Code subroutine print_som ( kohonen_map , unit_ ) !======================================================================================== !!   Print function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , intent ( inout ), optional :: unit_ !! integer :: ix , iy , iz , unit1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif write ( unit1 , * ) 'SOM: Results' ; write ( unit1 , * ) call kohonen_map % parameters % print ( unit1 ); ! write(unit1,*) 'After' write ( unit1 , * ) write ( unit1 , * ) 'SOM: Grid nodes' ; write ( unit1 , * ) do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% print ( unit1 ); enddo enddo !iy enddo !ix write ( unit1 , * ) write ( unit1 , * ) 'SOM: Hit count' ; write ( unit1 , * ) write ( unit1 , * ) 'Pattern Numbers' ; do iz = 1 , size ( kohonen_map % number_patterns , 3 ); do ix = 1 , size ( kohonen_map % number_patterns , 1 ); write ( unit1 , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 ,& size ( kohonen_map % number_patterns , 2 )); enddo enddo write ( unit1 , * ) write ( * , * ) 'SOM: Pattern index' write ( unit1 , * ) write ( unit1 , * ) write ( unit1 , * ) 'Pattern #, ix   ,iy' ; do ix = 1 , size ( kohonen_map % cells_index , 1 ); write ( unit1 , '(100I5)' ) ix , ( kohonen_map % cells_index ( ix , iy ),& iy = 1 , size ( kohonen_map % cells_index , 2 )); enddo ! end subroutine print_som","tags":"","loc":"proc\\print_som.html"},{"title":"get_count_som – KohonenF08","text":"public  subroutine get_count_som(kohonen_map, count_) Function to get count matrix for self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), dimension(:,:,:) :: count_ Source Code subroutine get_count_som ( kohonen_map , count_ ) !======================================================================================== !!   Function to get count matrix for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , dimension (:,:,:), intent ( inout ) :: count_ !! count_ = kohonen_map % number_patterns ; ! end subroutine get_count_som","tags":"","loc":"proc\\get_count_som.html"},{"title":"query_som – KohonenF08","text":"public  subroutine query_som(kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map real(kind=wp), intent(inout), dimension(:,:) :: input_pattern integer, allocatable :: sample_index (:) Calls proc~~query_som~~CallsGraph proc~query_som self_organizing_map%query_som none~get_prototype kohonen_prototype%get_prototype proc~query_som->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: ivar1 integer, public :: ivar2 integer, public :: nvar1 integer, public :: nvar2 integer, public :: number_patterns integer, public :: ipat integer, public :: ierr integer, public :: number_selected integer, public :: i integer, public :: pos real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_values real(kind=wp), public :: dist real(kind=wp), public :: dist_min integer, public, dimension(size(kohonen_map%cells_index,1)) :: position integer, public, dimension(size(kohonen_map%cells_index,1)) :: real_position Source Code subroutine query_som ( kohonen_map , input_pattern , sample_index ) !,output_patterns) !======================================================================================== !!   Function to find the input samples associated with specific vector class ( self_organizing_map ) :: kohonen_map !! real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_pattern !! integer , allocatable :: sample_index (:) !! integer :: ix , iy , iz , ihit , jhit , khit , ivar1 , ivar2 , nvar1 , nvar2 , number_patterns , ipat , ierr integer :: number_selected , i , pos real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values real ( kind = wp ) :: dist , dist_min integer , dimension ( size ( kohonen_map % cells_index , 1 )) :: position , real_position ! !(real_position(ix)=ix,ix=1,size(real_position)) do ix = 1 , size ( real_position ) real_position ( ix ) = ix ; enddo nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; dist_min = 1.0d10 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; call kohonen_map % grid ( ix , iy , iz )% get_prototype ( current_values ); do ivar1 = 1 , nvar1 ; do ivar2 = 1 , nvar2 ; if ( input_pattern ( ivar1 , ivar2 ) > 0.0_wp ) then dist = dist + ( input_pattern ( ivar1 , ivar2 ) - current_values ( ivar1 , ivar2 )) ** 2 ; endif enddo enddo if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo !$OMP end parallel do !         write(*,*) 'BMU' !         write(*,*) ihit,jhit,khit,dist_min ! position = 0 ; number_patterns = kohonen_map % number_patterns ( ihit , jhit , khit ); if ( number_patterns > 0 ) then where ( kohonen_map % cells_index (:, 1 ) == ihit . and . & kohonen_map % cells_index (:, 2 ) == jhit . and . & kohonen_map % cells_index (:, 3 ) == khit ) position = 1 ; !real_position; end where number_selected = sum ( position ); pos = 0 if ( number_selected > 0 ) then allocate ( sample_index ( number_selected ), stat = ierr ); do i = 1 , size ( real_position ) if ( position ( i ) == 1 ) then pos = pos + 1 ; sample_index ( pos ) = real_position ( i ); !write(*,*) 'Inside= ',i,real_position(i) endif enddo endif !write(*,*) kohonen_map%cells_index(118,1:3) else write ( * , * ) 'WARNING: Query has returned an empty result' return endif ! end subroutine query_som","tags":"","loc":"proc\\query_som.html"},{"title":"read_som – KohonenF08","text":"public  subroutine read_som(kohonen_map, som_fl) Subroutine to read the prototypes to define a self_organizing_map Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object character(len=*) :: som_fl A character variable with the name of the file Calls proc~~read_som~~CallsGraph proc~read_som self_organizing_map%read_som none~destroy kohonen_prototype%destroy proc~read_som->none~destroy none~set_prototype kohonen_prototype%set_prototype proc~read_som->none~set_prototype proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~read_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~read_som->proc~calculate_distance_matrix proc~position2index self_organizing_map%position2index proc~read_som->proc~position2index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: testfl logical, public :: toroidal_grid integer, public :: isom integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nvar1 integer, public :: nvar2 integer, public :: ierr integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ivar integer, public :: current_index character(len=40), public :: current_line character(len=40), public :: node_type real(kind=wp), public, allocatable :: Prototype_value (:,:) Source Code subroutine read_som ( kohonen_map , som_fl ) !======================================================================================== !! Subroutine to read the prototypes to define a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len =* ) :: som_fl !! A character variable with the name of the file logical :: testfl , toroidal_grid integer :: isom , nx , ny , nz , nvar1 , nvar2 , ierr , ix , iy , iz , ivar , current_index character ( len = 40 ) :: current_line , node_type real ( kind = wp ), allocatable :: Prototype_value (:,:) ! isom = 20 ; inquire ( file = trim ( som_fl ), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the som file does not exist' stop endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...' write ( * , * ) open ( isom , file = trim ( som_fl ), status = 'unknown' , action = 'read' , access = 'sequential' ); read ( isom , '(A)' ) current_line write ( * , * ) trim ( current_line ) read ( isom , '(A17,1X,3I6)' ) current_line , nx , ny , nz write ( * , * ) current_line , nx , ny , nz read ( isom , '(A21,1X,2I6)' ) current_line , nvar1 , nvar2 write ( * , * ) current_line , nvar1 , nvar2 read ( isom , '(A25,1X,A11,1X,L4)' ) current_line , node_type , toroidal_grid write ( * , * ) current_line , node_type , toroidal_grid allocate ( Prototype_value ( nvar1 * nvar2 , 1 ), stat = ierr ); ! if ( allocated ( kohonen_map % grid )) then do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); do iz = 1 , nz read ( isom , '(A)' ) current_line ; write ( * , * ) 'Reading ' , trim ( current_line ); do iy = 1 , ny do ix = 1 , nx ; read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , * ) ( Prototype_value ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ); !write(*,*) ix,iy,(Prototype_value(ivar,1),ivar=1,nvar1*nvar2) call kohonen_map % grid ( ix , iy , iz )% set_prototype ( Prototype_value ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , node_type ); enddo enddo enddo close ( isom ) !write(*,*) 'Reading done' ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& node_type , toroidal_grid ); ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...finished' write ( * , * ) ! end subroutine read_som","tags":"","loc":"proc\\read_som.html"},{"title":"index2position – KohonenF08","text":"public  subroutine index2position(index_, nx, ny, nz, cx, cy, cz) Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: index_ Integer variable representing the index integer, intent(in) :: nx Integer variables representing the dimensions of the kohonen map integer, intent(in) :: ny Integer variables representing the dimensions of the kohonen map integer, intent(in) :: nz Integer variables representing the dimensions of the kohonen map integer, intent(inout) :: cx Integer variables representing the position of the node integer, intent(inout) :: cy Integer variables representing the position of the node integer, intent(inout) :: cz Integer variables representing the position of the node Called by proc~~index2position~~CalledByGraph proc~index2position self_organizing_map%index2position proc~update_weights self_organizing_map%update_weights proc~update_weights->proc~index2position proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~update_weights proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_som train_som proc~train_som->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine index2position ( index_ , nx , ny , nz , cx , cy , cz ) !======================================================================================== !! Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index integer , intent ( in ) :: index_ !! Integer variable representing the index integer , intent ( in ) :: nx , ny , nz !! Integer variables representing the dimensions of the kohonen map integer , intent ( inout ) :: cx , cy , cz !! Integer variables representing the position of the node !  write(*,*) index_,nx,ny,1+int((index_-1)/(nx*ny)) cz = min ( 1 + int (( index_ - 1 ) / ( nx * ny )), nz ); cy = min ( 1 + int (( index_ - 1 - ( cz - 1 ) * nx * ny ) / nx ), ny ); cx = min ( index_ - ( cz - 1 ) * nx * ny - ( cy - 1 ) * nx , nx ); ! end subroutine index2position","tags":"","loc":"proc\\index2position.html"},{"title":"calculate_distance_matrix – KohonenF08","text":"public  subroutine calculate_distance_matrix(coordinates, distance_matrix, grid_type, toroidal) Subroutine to calculate the distance between the units inside a kohonen layer Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: coordinates Real array with the coordinates real(kind=wp), intent(inout), dimension(:,:) :: distance_matrix Real array with the distance_matrix character(len=*) :: grid_type Character variable with the grid type logical :: toroidal Logical variable for toroidal grid Called by proc~~calculate_distance_matrix~~CalledByGraph proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som self_organizing_map%create_som proc~create_som->proc~calculate_distance_matrix proc~read_som self_organizing_map%read_som proc~read_som->proc~calculate_distance_matrix proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som train_som proc~train_som->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=wp), public :: maxdiffx real(kind=wp), public :: maxdiffy real(kind=wp), public :: maxdiffz real(kind=wp), public, dimension(3) :: diffs Source Code subroutine calculate_distance_matrix ( coordinates , distance_matrix , grid_type , toroidal ) !======================================================================================== !! Subroutine to calculate the distance between the units inside a kohonen layer real ( kind = wp ), dimension (:,:), intent ( inout ) :: coordinates !! Real array with the coordinates real ( kind = wp ), dimension (:,:), intent ( inout ) :: distance_matrix !! Real array with the distance_matrix character ( len =* ) :: grid_type !! Character variable with the grid type logical :: toroidal !! Logical variable for toroidal grid integer :: i , j real ( kind = wp ) :: maxdiffx , maxdiffy , maxdiffz real ( kind = wp ), dimension ( 3 ) :: diffs ! maxdiffx = maxval ( coordinates (:, 1 )) / 2.0_wp ; maxdiffy = maxval ( coordinates (:, 2 )) / 2.0_wp ; maxdiffz = maxval ( coordinates (:, 3 )) / 2.0_wp ; ! distance_matrix = 0.0d0 ; ! if ( toroidal ) then do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); if ( diffs ( 1 ) > maxdiffx ) diffs ( 1 ) = 2.0_wp * maxdiffx - diffs ( 1 ); if ( diffs ( 2 ) > maxdiffy ) diffs ( 2 ) = 2.0_wp * maxdiffy - diffs ( 2 ); !if (diffs(3) > maxdiffy) diffs(3)=2*maxdiffz - diffs(3); if ( trim ( grid_type ) == 'hexagonal' ) then distance_matrix ( i , j ) = sum ( diffs ** 2 ); elseif ( trim ( grid_type ) == 'rectangular' ) then !rectangular distance_matrix ( i , j ) = maxval ( diffs ); endif !write(*,*) 'd= ',i,j,diffs(1:3),trim(grid_type)!distance_matrix(i,j) enddo enddo else do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); distance_matrix ( i , j ) = dsqrt ( sum ( diffs ** 2 )); enddo enddo endif ! distance_matrix = distance_matrix + transpose ( distance_matrix ); ! end subroutine calculate_distance_matrix","tags":"","loc":"proc\\calculate_distance_matrix.html"},{"title":"calculate_coordinates – KohonenF08","text":"public  subroutine calculate_coordinates(current_index, ix, iy, iz, nx, ny, nz, coordinates, node_type) Subroutine to calculate the coordinates of the units inside a kohonen layer Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_index integer, intent(in) :: ix integer, intent(in) :: iy integer, intent(in) :: iz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz real(kind=wp), intent(out), dimension(:,:) :: coordinates character(len=*), intent(in) :: node_type Called by proc~~calculate_coordinates~~CalledByGraph proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som self_organizing_map%create_som proc~create_som->proc~calculate_coordinates proc~read_som self_organizing_map%read_som proc~read_som->proc~calculate_coordinates proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som train_som proc~train_som->proc~create_som Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , coordinates , node_type ) !======================================================================================== !!  Subroutine to calculate the coordinates of the units inside a kohonen layer integer , intent ( in ) :: current_index , ix , iy , iz , nx , ny , nz !! real ( kind = wp ), dimension (:,:), intent ( out ) :: coordinates !! character ( len =* ), intent ( in ) :: node_type !! coordinates ( current_index , 1 ) = dble ( ix ); coordinates ( current_index , 2 ) = dble ( iy ); coordinates ( current_index , 3 ) = dble ( iz ); !write(*,*) coordinates(current_index,1:3); if ( trim ( node_type ) == 'hexagonal' ) then coordinates ( current_index , 1 ) = coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( coordinates ( current_index , 2 ), 2.0_wp )); coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2.0_wp ) * coordinates ( current_index , 2 ); endif ! end subroutine calculate_coordinates","tags":"","loc":"proc\\calculate_coordinates.html"},{"title":"find_best_match_unit – KohonenF08","text":"public  subroutine find_best_match_unit(kohonen_map, current_prototype, ihit, jhit, khit, dist_hit) Subroutine to calculate the best match unit Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_prototype ), intent(inout) :: current_prototype A kohonen_prototype object integer, intent(out) :: ihit Integer variables for the coordinates of the BMU integer, intent(out) :: jhit Integer variables for the coordinates of the BMU integer, intent(out) :: khit Integer variables for the coordinates of the BMU real(kind=wp), intent(out) :: dist_hit Real variable with the distance to the BMU Calls proc~~find_best_match_unit~~CallsGraph proc~find_best_match_unit self_organizing_map%find_best_match_unit float float proc~find_best_match_unit->float none~distance kohonen_prototype%distance proc~find_best_match_unit->none~distance calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_best_match_unit~~CalledByGraph proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~find_best_match_unit proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_som train_som proc~train_som->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: debug_option integer, public :: idbg integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: number_variables real(kind=wp), public :: dist Source Code subroutine find_best_match_unit ( kohonen_map , current_prototype , ihit , jhit , khit , dist_hit ) !======================================================================================== !! Subroutine to calculate the best match unit class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_prototype ), intent ( inout ) :: current_prototype !! A `kohonen_prototype` object integer , intent ( out ) :: ihit , jhit , khit !! Integer variables for the coordinates of the BMU real ( kind = wp ), intent ( out ) :: dist_hit !! Real variable with the distance to the BMU integer :: debug_option , idbg , ix , iy , iz , number_variables real ( kind = wp ) :: dist ! idbg = kohonen_map % parameters % idbg ; debug_option = kohonen_map % parameters % debug_level ; number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e7 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); !write(*,*) 'dist= ',dist if ( debug_option > 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ); write ( idbg , * ) ix , iy , iz , dist ; endif dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! !        write(*,*) 'find= ',ihit,jhit,khit,dist_hit return ! end subroutine find_best_match_unit","tags":"","loc":"proc\\find_best_match_unit.html"},{"title":"update_weights – KohonenF08","text":"public  subroutine update_weights(kohonen_map, current_values, ihit, jhit, khit, maximum_radius, iteration) Subroutine to update the weights Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: current_values A real array with the values of the current unit integer, intent(inout) :: ihit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: jhit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: khit Integer variables with the coordinates of the unit (neuron) to be modified real(kind=wp), intent(inout) :: maximum_radius Real variable with the maximum radius of the neighborhood integer, intent(inout) :: iteration Integer variables with the coordinates of the unit (neuron) to be modified Calls proc~~update_weights~~CallsGraph proc~update_weights self_organizing_map%update_weights dexp dexp proc~update_weights->dexp none~get_prototype kohonen_prototype%get_prototype proc~update_weights->none~get_prototype none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position proc~position2index self_organizing_map%position2index proc~update_weights->proc~position2index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~update_weights~~CalledByGraph proc~update_weights self_organizing_map%update_weights proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~update_weights proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_som train_som proc~train_som->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: prototype_values real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: winner_values real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: term1 real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: term2 integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: debug_option integer, public :: ic integer, public :: current_pos integer, public :: ineigh integer, public :: jneigh integer, public :: kneigh integer, public :: idbg real(kind=wp), public :: time_factor real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: sigma2 real(kind=wp), public :: h_neighborhood real(kind=wp), public :: real_distance real(kind=wp), public :: term3 real(kind=wp), public :: distance_ratio real(kind=wp), public :: geometric_distance2 real(kind=wp), public :: eps real(kind=wp), public :: current_distance real(kind=wp), public :: lambda real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: v_vector real(kind=wp), public :: v_vector_norm real(kind=wp), public :: r real(kind=wp), public :: Psi character(len=NUMCHAR), public :: m_estimator Source Code subroutine update_weights ( kohonen_map , current_values , ihit , jhit , khit ,& maximum_radius , iteration ) !======================================================================================== !!    Subroutine to update the weights class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: current_values !! A real array with the values of the current unit integer , intent ( inout ) :: ihit , jhit , khit , iteration !! Integer variables with the coordinates of the unit (neuron) to be modified real ( kind = wp ), intent ( inout ) :: maximum_radius !! Real variable with the maximum radius of the neighborhood real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: prototype_values real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: winner_values , term1 , term2 integer :: nx , ny , nz , debug_option , ic , current_pos , ineigh , jneigh , kneigh , idbg real ( kind = wp ) :: time_factor , current_radius , alpha , sigma2 , h_neighborhood , real_distance , term3 real ( kind = wp ) :: distance_ratio , geometric_distance2 , eps , current_distance , lambda !type(influence_function) :: influence_func real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: v_vector real ( kind = wp ) :: v_vector_norm , r , Psi character ( len = NUMCHAR ) :: m_estimator ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; debug_option = kohonen_map % parameters % debug_level ; idbg = kohonen_map % parameters % idbg ; lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); time_factor = 1.0_wp - dble ( iteration ) / & dble ( kohonen_map % parameters % number_epochs * kohonen_map % parameters % number_patterns ); !current_radius = max(maximum_radius*real(1001-iteration)/1000.0 + 0.9999999999,4.0d0); current_radius = max ( maximum_radius * time_factor , 4.0_wp ); !alpha = max(kohonen_map%parameters%learning_rate*(1.0d0-real(iteration)/1000.0),0.01d0); alpha = max ( kohonen_map % parameters % learning_rate * time_factor , 0.01_wp ); sigma2 = current_radius ** 2 ; ! m_estimator = trim ( kohonen_map % parameters % m_estimator ); ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance < current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters % neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * dexp ( - 0.5_wp * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option > 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters % som_type )) case ( 'normal_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); !v_vector=(current_values-prototype_values); !v_vector_norm=dsqrt(sum(v_vector**2)); !r=v_vector_norm/sigma; !Psi=influence_func%calculate(m_estimator,r); !prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'visom' ) !write(*,*) trim(kohonen_map%parameters%som_type) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh == ihit ) . and . ( jneigh == jhit ) . and . ( kneigh == khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); eps = max ( 1.0_wp * time_factor , 0.0_wp ); term3 = 1.0_wp ; !((1.0d0-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * & ( distance_ratio - 1.0_wp ) * term3 ); endif !write(*,*) iteration,dsqrt(real_distance),dsqrt(geometric_distance2)*lambda,distance_ratio call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'robust_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); ! v_vector=(current_values-prototype_values); ! v_vector_norm=dsqrt(sum(v_vector**2)); ! r=v_vector_norm/sigma; ! Psi=influence_func%calculate(m_estimator,r); ! prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo !ic ! end subroutine update_weights","tags":"","loc":"proc\\update_weights.html"},{"title":"calculate_distance_between_prototypes – KohonenF08","text":"public  subroutine calculate_distance_between_prototypes(kohonen_map) Subroutine to calculate the distance between the prototypes Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Calls proc~~calculate_distance_between_prototypes~~CallsGraph proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~position2index self_organizing_map%position2index proc~calculate_distance_between_prototypes->proc~position2index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_distance_between_prototypes~~CalledByGraph proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~calculate_distance_between_prototypes proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_som train_som proc~train_som->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 integer, public :: pos integer, public :: pos1 type( kohonen_prototype ), public :: current_prototype type( kohonen_prototype ), public :: current_prototype1 Source Code subroutine calculate_distance_between_prototypes ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the distance between the prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: nx , ny , ix , iy , iz , ix1 , iy1 , iz1 , pos , pos1 ! type ( kohonen_prototype ) :: current_prototype , current_prototype1 !! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_prototype = kohonen_map % grid ( ix , iy , iz ); pos = position2index ( ix , iy , iz , nx , ny ); do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); pos1 = position2index ( ix1 , iy1 , iz1 , nx , ny ) current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); kohonen_map % distance ( pos , pos1 ) = current_prototype1 % distance ( current_prototype ,& kohonen_map % distance_function ); enddo !ix1 enddo !iy1 enddo !iz1 enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! if ( kohonen_map % parameters % train_option < 3 ) then do ix = 1 , size ( kohonen_map % distance , 1 ) write ( kohonen_map % parameters % idist , * ) ( kohonen_map % distance ( ix , iy ), iy = 1 , size ( kohonen_map % distance , 2 )); enddo !ix endif ! end subroutine calculate_distance_between_prototypes","tags":"","loc":"proc\\calculate_distance_between_prototypes.html"},{"title":"find_bmu_grid – KohonenF08","text":"public  subroutine find_bmu_grid(kohonen_map, input_data) Subroutine to calculate the best match unit over the grid Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data Calls proc~~find_bmu_grid~~CallsGraph proc~find_bmu_grid self_organizing_map%find_bmu_grid float float proc~find_bmu_grid->float none~distance kohonen_prototype%distance proc~find_bmu_grid->none~distance proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~find_bmu_grid->proc~kohonen_pattern_accessor calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: idat integer, public :: pat_hit type( kohonen_prototype ), public :: current_prototype real(kind=wp), public :: dist real(kind=wp), public :: dist_min Source Code subroutine find_bmu_grid ( kohonen_map , input_data ) !======================================================================================== !! Subroutine to calculate the best match unit over the grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: nx , ny , nz , ix , iy , iz , ihit , jhit , khit , idat , pat_hit type ( kohonen_prototype ) :: current_prototype real ( kind = wp ) :: dist , dist_min ! do idat = 1 , size ( input_data ) dist_min = 1.0e7 ; ihit = 0 ; jhit = 0 ; khit = 0 ; call input_data ( idat )% get ( current_prototype ); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( kohonen_map % parameters % number_variables ) if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; pat_hit = idat ; endif enddo enddo enddo !$OMP end parallel do kohonen_map % grid_pattern_index ( ihit , jhit , khit ) = pat_hit ; kohonen_map % cells_index ( idat , 1 ) = ihit ; kohonen_map % cells_index ( idat , 2 ) = jhit ; kohonen_map % cells_index ( idat , 3 ) = khit ; !    write(*,*) 'BMU= ',idat,ihit,jhit,khit,dist_min enddo ! ! end subroutine find_bmu_grid","tags":"","loc":"proc\\find_bmu_grid.html"},{"title":"calculate_u_matrix – KohonenF08","text":"public  subroutine calculate_u_matrix(kohonen_map) Subroutine to calculate  the u_matrix Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Calls proc~~calculate_u_matrix~~CallsGraph proc~calculate_u_matrix self_organizing_map%calculate_u_matrix none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_u_matrix~~CalledByGraph proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~calculate_u_matrix proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_som train_som proc~train_som->proc~train_som_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=NUMCHAR), public :: type_ integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nt integer, public :: ierr integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: nxu integer, public :: nyu integer, public :: nzu real(kind=wp), public :: dist real(kind=wp), public :: u_temp Source Code subroutine calculate_u_matrix ( kohonen_map ) !======================================================================================== !! Subroutine to calculate  the u_matrix class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len = NUMCHAR ) :: type_ integer :: nx , ny , nz , nt , ierr , ix , iy , iz , cx , cy , cz , nxu , nyu , nzu real ( kind = wp ) :: dist , u_temp ! type_ = trim ( kohonen_map % parameters % node_type ); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; ! nxu = size ( kohonen_map % u_matrix , 1 ); nyu = size ( kohonen_map % u_matrix , 2 ); nzu = size ( kohonen_map % u_matrix , 3 ); ! select case ( trim ( type_ )) ! case ( 'rectangular' ) !call kohonen_map%calculate_u_matrix_rectangular(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); ! horizontal if ( ix < nx ) then cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif !vertical if ( iy < ny ) then cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; endif ! if ( iz < nz ) then cx = ix ; cy = iy ; cz = iz + 1 ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! Diagonal if ( ix < nx . and . iy < ny ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = dist + kohonen_map % grid ( ix , cy , iz )% distance ( kohonen_map % grid ( cx , iy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; endif enddo enddo enddo ! do iz = 1 , size ( kohonen_map % u_matrix , 3 ), 2 do iy = 1 , size ( kohonen_map % u_matrix , 2 ), 2 do ix = 1 , size ( kohonen_map % u_matrix , 1 ), 2 u_temp = 0.0d0 ; if ( ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 ) . and . & iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == 1 . and . ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( iy == size ( kohonen_map % u_matrix , 2 ) . and . ix > 1 . and .& ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == 1 . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = 0.0_wp ; endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! case ( 'hexagonal' ) !call kohonen_map%calculate_u_matrix_hexagonal(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); if ( ix < nx ) then !horizontal cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! if ( iy < ny ) then !diagonals cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; if ( mod ( iy , 2 ) == 0 . and . ix < nx ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; elseif ( mod ( iy , 2 ) == 1 . and . ix > 1 ) then cx = ix - 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 2 , 2 * iy , 2 * iz - 1 ) = dist ; endif endif enddo enddo enddo ! do iz = 1 , nzu , 2 ; do iy = 1 , nyu , 2 ; do ix = 1 , nxu , 2 ; u_temp = 0.0d0 ; if ( ix > 1 . and . iy > 1 . and . ix < nxu . and . iy < nyu ) then !middle part of the map u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); endif nt = 6 ; elseif ( iy == 1 . and . ix > 1 . and . ix < nxu ) then ! upper edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == nyu . and . ix > 1 . and . ix < nxu ) then ! lower edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); endif nt = 4 ; elseif ( ix == 1 . and . iy > 1 . and . iy < nyu ) then ! left edge u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); nt = 5 ; endif elseif ( ix == nxu . and . iy > 1 . and . iy < nyu ) then ! right edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ); nt = 5 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; endif elseif ( ix == 1 . and . iy == 1 ) then ! top left corner u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == nxu . and . iy == 1 ) then ! top right corner u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == nyu ) then ! bottom left corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); nt = 3 ; endif ; elseif ( ix == nxu . and . iy == nyu ) then ! bottom right corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ); nt = 3 ; else u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; endif endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! end select ! if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % u_matrix , 3 ); write ( kohonen_map % parameters % iumat , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % u_matrix , 1 ); write ( kohonen_map % parameters % iumat , '(100f10.5)' ) ( kohonen_map % u_matrix ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % u_matrix , 2 )); enddo enddo endif ! end subroutine calculate_u_matrix","tags":"","loc":"proc\\calculate_u_matrix.html"},{"title":"calculate_u_matrix_hexagonal – KohonenF08","text":"public  subroutine calculate_u_matrix_hexagonal(kohonen_map) Subroutine to calculate the u_matrix for an hexagonal grid Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Source Code subroutine calculate_u_matrix_hexagonal ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matrix for an hexagonal grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_hexagonal","tags":"","loc":"proc\\calculate_u_matrix_hexagonal.html"},{"title":"calculate_u_matrix_rectangular – KohonenF08","text":"public  subroutine calculate_u_matrix_rectangular(kohonen_map) Subroutine to calculate the u_matix for a rectangular grid Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object Source Code subroutine calculate_u_matrix_rectangular ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matix for a rectangular grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_rectangular","tags":"","loc":"proc\\calculate_u_matrix_rectangular.html"},{"title":"get_u_matrix_som – KohonenF08","text":"public  subroutine get_u_matrix_som(kohonen_map, u_matrix) Subroutine to get the u_matrix from a SOM Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:,:) :: u_matrix A real array to return the u_matrix Source Code subroutine get_u_matrix_som ( kohonen_map , u_matrix ) !======================================================================================== !! Subroutine to get the u_matrix from a SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:,:), intent ( out ) :: u_matrix !! A real array to return the u_matrix u_matrix = kohonen_map % u_matrix ; ! end subroutine get_u_matrix_som","tags":"","loc":"proc\\get_u_matrix_som.html"},{"title":"get_prototypes – KohonenF08","text":"public  subroutine get_prototypes(kohonen_map, prototypes) Subroutine to get SOM prototypes Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: prototypes A real array to return the values of the SOM prototypes Calls proc~~get_prototypes~~CallsGraph proc~get_prototypes self_organizing_map%get_prototypes none~get_prototype kohonen_prototype%get_prototype proc~get_prototypes->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: pos integer, public :: nvar1 integer, public :: nvar2 integer, public, dimension(1) :: nvar real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1, kohonen_map%parameters%number_variables2) :: current_prototype real(kind=wp), public, dimension(kohonen_map%parameters%number_variables1* kohonen_map%parameters%number_variables2) :: current_prototype1 Source Code subroutine get_prototypes ( kohonen_map , prototypes ) !======================================================================================== !! Subroutine to get SOM prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: prototypes !! A real array to return the values of the SOM prototypes integer :: i , j , k , pos , nvar1 , nvar2 integer , dimension ( 1 ) :: nvar real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ) :: current_prototype1 ! nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; nvar ( 1 ) = nvar1 * nvar2 pos = 0 ; do k = 1 , size ( kohonen_map % grid , 3 ) do j = 1 , size ( kohonen_map % grid , 2 ); do i = 1 , size ( kohonen_map % grid , 1 ); pos = pos + 1 ; call kohonen_map % grid ( i , j , k )% get_prototype ( current_prototype ); current_prototype1 ( 1 : nvar1 * nvar2 ) = reshape ( current_prototype , nvar ) prototypes ( pos ,:) = current_prototype1 ; enddo enddo enddo ! end subroutine get_prototypes","tags":"","loc":"proc\\get_prototypes.html"},{"title":"external_train_map – KohonenF08","text":"public  subroutine external_train_map(x, nvar, npat, nx, ny, nepoch, alpha, grid_type, distance_type, neigh_type, toroidal, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_som\") Uses iso_c_binding proc~~external_train_map~~UsesGraph proc~external_train_map self_organizing_map%external_train_map iso_c_binding iso_c_binding proc~external_train_map->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutine to connect the self_organizing_map module to R o C\nImport section Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real array with the input patterns integer(kind=c_int), intent(in) :: nvar Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: npat Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: nx Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: ny Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: nepoch Integer variables to indicate the number of epochs for training real(kind=c_double), intent(in) :: alpha Real value with the initial learning rate integer(kind=c_int), intent(in) :: grid_type Integer variable to indicate the type of grid integer(kind=c_int), intent(in) :: distance_type Integer variable to indicate the distance type integer(kind=c_int), intent(in) :: neigh_type Integer variable to indicate the neighborhood type integer(kind=c_int), intent(in) :: toroidal Integer variable to indicate if a toroidal grid is used real(kind=c_double), intent(out) :: prot (nx*ny,nvar) Real array for the prototypes real(kind=c_double), intent(out) :: distortion (nepoch) Real array for the distortion measure (error during training) real(kind=c_double), intent(out) :: u_matrix (2*nx-1,2*ny-1) Real array for the u_matrix real(kind=c_double), intent(out) :: coords (nx*ny,3) Real array for the grid coordinates of the SOM integer(kind=c_int), intent(out) :: number_patterns (nx,ny) Integer array with the number of hits for each neuron integer(kind=c_int), intent(out) :: node_index (npat,3) Integer array with the index node for all the neurons of the SOM Calls proc~~external_train_map~~CallsGraph proc~external_train_map self_organizing_map%external_train_map none~get_prototype kohonen_prototype%get_prototype proc~external_train_map->none~get_prototype proc~destroy_som self_organizing_map%destroy_som proc~external_train_map->proc~destroy_som proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create proc~external_train_map->proc~kohonen_pattern_create proc~position2index self_organizing_map%position2index proc~external_train_map->proc~position2index proc~train_som_data self_organizing_map%train_som_data proc~external_train_map->proc~train_som_data none~destroy kohonen_prototype%destroy proc~destroy_som->none~destroy none~create kohonen_prototype%create proc~kohonen_pattern_create->none~create proc~train_som_data->none~get_prototype proc~calculate_distance_between_prototypes self_organizing_map%calculate_distance_between_prototypes proc~train_som_data->proc~calculate_distance_between_prototypes proc~calculate_u_matrix self_organizing_map%calculate_u_matrix proc~train_som_data->proc~calculate_u_matrix proc~find_best_match_unit self_organizing_map%find_best_match_unit proc~train_som_data->proc~find_best_match_unit proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~train_som_data->proc~kohonen_pattern_accessor proc~update_weights self_organizing_map%update_weights proc~train_som_data->proc~update_weights proc~calculate_distance_between_prototypes->proc~position2index none~distance kohonen_prototype%distance proc~calculate_u_matrix->none~distance float float proc~find_best_match_unit->float proc~find_best_match_unit->none~distance proc~update_weights->none~get_prototype proc~update_weights->proc~position2index dexp dexp proc~update_weights->dexp none~set_prototype kohonen_prototype%set_prototype proc~update_weights->none~set_prototype proc~index2position self_organizing_map%index2position proc~update_weights->proc~index2position none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: version = 0.1_wp Parameter version character(len=*), public, parameter :: program_name = \"som_train\" Parameter name of the function type( self_organizing_map ), public :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: parameters real(kind=wp), public, dimension(nvar,1) :: var integer, public :: i integer, public :: j integer, public :: k integer, public :: ierr integer, public :: pos integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: nx1 integer, public :: ny1 type( kohonen_pattern ), public, allocatable :: input_patterns (:) real(kind=wp), public, dimension(nx*ny,nvar) :: prototypes real(kind=wp), public, dimension(nvar,1) :: temp Source Code subroutine external_train_map ( x , nvar , npat , nx , ny , nepoch , alpha , grid_type ,& distance_type , neigh_type , toroidal , prot , distortion ,& u_matrix , coords , number_patterns , node_index ) bind ( C , name = \"train_som\" ) !======================================================================================== !!    Subroutine to connect the self_organizing_map module to R o C use , intrinsic :: iso_c_binding , only : c_double , c_int , c_char !! Import section real ( kind = wp ), parameter :: version = 0.1_wp ; !! Parameter version character ( len =* ), parameter :: program_name = \"som_train\" ; !! Parameter name of the function integer ( c_int ), intent ( in ) :: nvar , npat !! Integer variables to indicate the number of variables and patterns integer ( c_int ), intent ( in ) :: nx , ny !! Integer variables to indicate the number of nodes of the SOM integer ( c_int ), intent ( in ) :: nepoch !! Integer variables to indicate the number of epochs for training integer ( c_int ), intent ( in ) :: toroidal !! Integer variable to indicate if a toroidal grid is used real ( c_double ), intent ( out ) :: prot ( nx * ny , nvar ) !! Real array for the prototypes real ( c_double ), intent ( out ) :: distortion ( nepoch ) !! Real array for the distortion measure (error during training) real ( c_double ), intent ( out ) :: u_matrix ( 2 * nx - 1 , 2 * ny - 1 ) !! Real array for the u_matrix real ( c_double ), intent ( out ) :: coords ( nx * ny , 3 ) !! Real array for the grid coordinates of the SOM integer ( c_int ), intent ( out ) :: number_patterns ( nx , ny ) !! Integer array with the number of hits for each neuron integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! Integer array with the index node for all the neurons of the SOM real ( c_double ), intent ( in ) :: x ( npat , nvar ) !! Real array with the input patterns real ( c_double ), intent ( in ) :: alpha !! Real value with the initial learning rate integer ( c_int ), intent ( in ) :: grid_type !! Integer variable to indicate the type of grid integer ( c_int ), intent ( in ) :: distance_type !! Integer variable to indicate the distance type integer ( c_int ), intent ( in ) :: neigh_type !! Integer variable to indicate the neighborhood type type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters real ( kind = wp ), dimension ( nvar , 1 ) :: var integer :: i , j , k , ierr , pos , ihit , jhit , khit , nx1 , ny1 type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), dimension ( nx * ny , nvar ) :: prototypes real ( kind = wp ), dimension ( nvar , 1 ) :: temp ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = nepoch ; parameters ( 1 )% learning_rate = alpha ; parameters ( 1 )% random_seed_ = 12345 ; if ( grid_type == 0 ) then parameters ( 1 )% node_type = \"rectangular\" ; !\"hexagonal\" !rectangular, hexagonal elseif ( grid_type == 1 ) then parameters ( 1 )% node_type = \"hexagonal\" ; endif parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" ; parameters ( 1 )% pattern_file = \"NOFILE\" ; parameters ( 1 )% output_file = \"NOFILE\" ; parameters ( 1 )% distance_type = \"euclidean\" ; !\"euclidean\" !euclidean, manhattan, correlation, correlation2 if ( neigh_type == 0 ) then parameters ( 1 )% neighborhood_type = \"bubble\" ; elseif ( neigh_type == 1 ) then parameters ( 1 )% neighborhood_type = \"gaussian\" ; !gaussian,bubble endif parameters ( 1 )% som_type = \"normal_som\" !,visom if ( toroidal == 1 ) then parameters ( 1 )% toroidal_grid = . TRUE .; else parameters ( 1 )% toroidal_grid = . FALSE .; endif ! ! ADDED TO AVOID PRINTING UNIT INFO (THE CAUSE IS UNKNONW) ! write(*,*) '' ! write(*,'(A,A,f10.5)') trim(program_name),' version: ',version ! write(*,*) '' allocate ( input_patterns ( npat ), stat = ierr ); do i = 1 , npat var ( 1 : nvar , 1 ) = x ( i , 1 : nvar ) !write(*,*) i,var call input_patterns ( i )% create ( var ); !    call input_patterns(i)%print(); enddo ! Create SOM call my_som % create ( parameters ); ! Train SOM call my_som % train ( input_patterns ); ! Extract results pos = 0 k = 1 nx1 = nx ; ny1 = ny ; do j = 1 , ny do i = 1 , nx pos = position2index ( i , j , k , nx1 , ny1 ); !write(*,*) i,j,pos,i+(j-1)*nx call my_som % grid ( i , j , k )% get_prototype ( temp ); !position2index() prototypes ( pos , 1 : nvar ) = temp ( 1 : nvar , 1 ); enddo enddo ! ! Get the results in the arrays ! distortion = my_som % distortion u_matrix ( 1 : 2 * nx - 1 , 1 : 2 * ny - 1 ) = my_som % u_matrix (:,:, 1 ); !do i=1,size(my_som%coordinates,1); !write(*,*) my_som%coordinates(i,1:3); !   coords(i,1:3)=my_som%coordinates(i,1:3); !enddo coords = my_som % coordinates ; !coords(1:nx*nx,1)=my_som%coordinates(:,1); !coords(1:nx*nx,2)=my_som%coordinates(:,2); !coords(1:nx*nx,3)=my_som%coordinates(:,3); number_patterns = my_som % number_patterns (:,:, 1 ); node_index = my_som % cells_index prot = prototypes ; ! call my_som % destroy (); ! do i = 1 , npat call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); ! ! ! write(*,*) ! write(*,'(A,A,f10.5,2X,A)') trim(program_name),' version: ',version,'Finished' ! write(*,*) ! end subroutine external_train_map","tags":"","loc":"proc\\external_train_map.html"},{"title":"external_predict_map – KohonenF08","text":"public  subroutine external_predict_map(prot, nx, ny, new_pat, npat, nvar, node_index) bind(C, name=\"predict_som\") Uses iso_c_binding proc~~external_predict_map~~UsesGraph proc~external_predict_map self_organizing_map%external_predict_map iso_c_binding iso_c_binding proc~external_predict_map->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutine to connect this module to R Type Bound self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: prot (nx*ny,nvar) integer(kind=c_int), intent(in) :: nx integer(kind=c_int), intent(in) :: ny real(kind=c_double), intent(in) :: new_pat (npat,nvar) integer(kind=c_int), intent(in) :: npat integer(kind=c_int), intent(in) :: nvar integer(kind=c_int), intent(out) :: node_index (npat,3) Calls proc~~external_predict_map~~CallsGraph proc~external_predict_map self_organizing_map%external_predict_map none~set_prototype kohonen_prototype%set_prototype proc~external_predict_map->none~set_prototype proc~create_som self_organizing_map%create_som proc~external_predict_map->proc~create_som proc~destroy_som self_organizing_map%destroy_som proc~external_predict_map->proc~destroy_som proc~predict_som self_organizing_map%predict_som proc~external_predict_map->proc~predict_som error_stop error_stop proc~create_som->error_stop none~create~3 rkiss05_generator%create proc~create_som->none~create~3 proc~calculate_coordinates self_organizing_map%calculate_coordinates proc~create_som->proc~calculate_coordinates proc~calculate_distance_matrix self_organizing_map%calculate_distance_matrix proc~create_som->proc~calculate_distance_matrix proc~create_distance factory_distance%create_distance proc~create_som->proc~create_distance proc~create_random_sample self_organizing_map%create_random_sample proc~create_som->proc~create_random_sample proc~position2index self_organizing_map%position2index proc~create_som->proc~position2index none~destroy kohonen_prototype%destroy proc~destroy_som->none~destroy float float proc~predict_som->float none~distance kohonen_prototype%distance proc~predict_som->none~distance none~get_prototype kohonen_prototype%get_prototype proc~predict_som->none~get_prototype proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~predict_som->proc~kohonen_pattern_accessor none~distance->none~get_prototype calculate calculate none~distance->calculate none~generate rkiss05_generator%generate proc~create_random_sample->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( self_organizing_map ), public :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: parameters integer, public :: ipat integer, public :: inode integer, public :: i_hit integer, public :: nx1 integer, public :: ny1 integer, public :: nz1 integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: pos integer, public :: ierr real(kind=wp), public :: dist real(kind=wp), public :: dist_hit real(kind=wp), public, dimension(nvar,1) :: temp type( kohonen_pattern ), public, dimension(npat) :: input_data Source Code subroutine external_predict_map ( prot , nx , ny , new_pat , npat , nvar , node_index ) & bind ( C , name = \"predict_som\" ) !======================================================================================== !!    Subroutine to connect this module to R use , intrinsic :: iso_c_binding , only : c_double , c_int integer ( c_int ), intent ( in ) :: nx , ny , npat , nvar real ( c_double ), intent ( in ) :: prot ( nx * ny , nvar ), new_pat ( npat , nvar ) integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters integer :: ipat , inode , i_hit , nx1 , ny1 , nz1 , cx , cy , cz , ix , iy , iz , pos , ierr real ( kind = wp ) :: dist , dist_hit real ( kind = wp ), dimension ( nvar , 1 ) :: temp type ( kohonen_pattern ), dimension ( npat ) :: input_data ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = 1 ; parameters ( 1 )% learning_rate = 0.0d0 ; parameters ( 1 )% random_seed_ = 12345 ; parameters ( 1 )% node_type = \"hexagonal\" parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" parameters ( 1 )% pattern_file = \"NOFILE\" parameters ( 1 )% output_file = \"NOFILE\" parameters ( 1 )% distance_type = \"euclidean\" !\"euclidean\" !euclidean, manhattan, correlation, correlation2 parameters ( 1 )% neighborhood_type = \"gaussian\" !gaussian,bubble parameters ( 1 )% som_type = \"normal_som\" !,visom parameters ( 1 )% toroidal_grid = . TRUE . ! ! call parameters(1)%print(); ! call my_som % create ( parameters ); ! pos = 0 ; iz = 1 ; do iy = 1 , ny do ix = 1 , nx pos = pos + 1 ; temp ( 1 : nvar , 1 ) = prot ( pos , 1 : nvar ) call my_som % grid ( ix , iy , iz )% set_prototype ( temp ) enddo enddo ! do ipat = 1 , npat temp ( 1 : nvar , 1 ) = new_pat ( ipat , 1 : nvar ); call input_data ( ipat )% create ( temp ); enddo ! call my_som % predict ( input_data , node_index ); ! call my_som % destroy (); ! do ipat = 1 , size ( input_data ); call input_data ( ipat )% destroy (); enddo ! end subroutine external_predict_map","tags":"","loc":"proc\\external_predict_map.html"},{"title":"kohonen_pattern_nrow – KohonenF08","text":"public  function kohonen_pattern_nrow(current_pattern) result(nr) Function to calculate the number of rows (samples) in a pattern Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of rows (samples) in a pattern Calls proc~~kohonen_pattern_nrow~~CallsGraph proc~kohonen_pattern_nrow kohonen_pattern%kohonen_pattern_nrow none~get_nrow kohonen_prototype%get_nrow proc~kohonen_pattern_nrow->none~get_nrow Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function kohonen_pattern_nrow ( current_pattern ) result ( nr ) !======================================================================================== !! Function to calculate the number of rows (samples) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nr !! An integer with the number of rows (samples) in a pattern nr = current_pattern % pattern % get_nrow (); ! end function kohonen_pattern_nrow","tags":"","loc":"proc\\kohonen_pattern_nrow.html"},{"title":"kohonen_pattern_ncol – KohonenF08","text":"public  function kohonen_pattern_ncol(current_pattern) result(nc) Function to calculate the number of columns (variables) in a pattern Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of columns (variables) in a pattern Calls proc~~kohonen_pattern_ncol~~CallsGraph proc~kohonen_pattern_ncol kohonen_pattern%kohonen_pattern_ncol none~get_ncol kohonen_prototype%get_ncol proc~kohonen_pattern_ncol->none~get_ncol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function kohonen_pattern_ncol ( current_pattern ) result ( nc ) !======================================================================================== !! Function to calculate the number of columns (variables) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nc !! An integer with the number of columns (variables) in a pattern nc = current_pattern % pattern % get_ncol (); ! end function kohonen_pattern_ncol","tags":"","loc":"proc\\kohonen_pattern_ncol.html"},{"title":"kohonen_pattern_create – KohonenF08","text":"public  subroutine kohonen_pattern_create(current_pattern, input, name) Kohonen pattern constructor Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object real(kind=wp), intent(inout), dimension(:,:) :: input A real array character(len=*), optional :: name A character string with the name of the pattern Calls proc~~kohonen_pattern_create~~CallsGraph proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create none~create kohonen_prototype%create proc~kohonen_pattern_create->none~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~kohonen_pattern_create~~CalledByGraph proc~kohonen_pattern_create kohonen_pattern%kohonen_pattern_create proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~kohonen_pattern_create proc~initialize_variables~3 initialize_variables proc~initialize_variables~3->proc~kohonen_pattern_create proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~kohonen_pattern_create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine kohonen_pattern_create ( current_pattern , input , name ) !======================================================================================== !!   Kohonen pattern constructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input !! A real array character ( len =* ), optional :: name !! A character string with the name of the pattern call current_pattern % pattern % create ( input ); if ( present ( name )) then current_pattern % pattern_name = trim ( name ); else current_pattern % pattern_name = \"\" ; endif ! end subroutine kohonen_pattern_create","tags":"","loc":"proc\\kohonen_pattern_create.html"},{"title":"kohonen_pattern_destroy – KohonenF08","text":"public  subroutine kohonen_pattern_destroy(current_pattern) Kohonen pattern destructor Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Calls proc~~kohonen_pattern_destroy~~CallsGraph proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy none~destroy kohonen_prototype%destroy proc~kohonen_pattern_destroy->none~destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~kohonen_pattern_destroy~~CalledByGraph proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~release_variables~3 release_variables proc~release_variables~3->proc~kohonen_pattern_destroy proc~release_variables~4 release_variables proc~release_variables~4->proc~kohonen_pattern_destroy proc~train_som train_som proc~train_som->proc~kohonen_pattern_destroy proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~kohonen_pattern_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine kohonen_pattern_destroy ( current_pattern ) !======================================================================================== !!   Kohonen pattern destructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object call current_pattern % pattern % destroy (); ! end subroutine kohonen_pattern_destroy","tags":"","loc":"proc\\kohonen_pattern_destroy.html"},{"title":"kohonen_pattern_accessor – KohonenF08","text":"public  subroutine kohonen_pattern_accessor(current_pattern, pattern_value) Kohonen pattern accessor Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value Called by proc~~kohonen_pattern_accessor~~CalledByGraph proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~assign_input_to_clusters two_level_self_organizing_map%assign_input_to_clusters proc~assign_input_to_clusters->proc~kohonen_pattern_accessor proc~evaluate_2lsom two_level_self_organizing_map%evaluate_2lsom proc~evaluate_2lsom->proc~kohonen_pattern_accessor proc~find_bmu_grid self_organizing_map%find_bmu_grid proc~find_bmu_grid->proc~kohonen_pattern_accessor proc~predict_2lsom two_level_self_organizing_map%predict_2lsom proc~predict_2lsom->proc~kohonen_pattern_accessor proc~predict_som self_organizing_map%predict_som proc~predict_som->proc~kohonen_pattern_accessor proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_grid_layer->proc~kohonen_pattern_accessor proc~train_som_data self_organizing_map%train_som_data proc~train_som_data->proc~kohonen_pattern_accessor proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~predict_som proc~external_train_map self_organizing_map%external_train_map proc~external_train_map->proc~train_som_data proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~assign_input_to_clusters proc~train_2lsom->proc~train_grid_layer proc~train_som train_som proc~train_som->proc~train_som_data proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine kohonen_pattern_accessor ( current_pattern , pattern_value ) !======================================================================================== !! Kohonen pattern accessor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! pattern_value = current_pattern % pattern ; ! end subroutine kohonen_pattern_accessor","tags":"","loc":"proc\\kohonen_pattern_accessor.html"},{"title":"kohonen_pattern_mutator – KohonenF08","text":"public  subroutine kohonen_pattern_mutator(current_pattern, pattern_value) kohonen_pattern_mutator Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value Source Code subroutine kohonen_pattern_mutator ( current_pattern , pattern_value ) !======================================================================================== !!   kohonen_pattern_mutator class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! current_pattern % pattern = pattern_value ; ! end subroutine kohonen_pattern_mutator","tags":"","loc":"proc\\kohonen_pattern_mutator.html"},{"title":"kohonen_pattern_print – KohonenF08","text":"public  subroutine kohonen_pattern_print(current_pattern, unit_) Subroutine to print a Kohonen pattern Type Bound kohonen_pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit where the patterns will be printed Source Code subroutine kohonen_pattern_print ( current_pattern , unit_ ) !======================================================================================== !! Subroutine to print a Kohonen pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer , intent ( inout ), optional :: unit_ !! An integer variable with the number of the unit where the patterns will be printed if ( present ( unit_ )) then write ( unit_ , * ) write ( unit_ , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( unit_ , * ) call current_pattern % pattern % print ( unit_ ); else write ( * , * ) write ( * , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( * , * ) call current_pattern % pattern % print (); endif ! end subroutine kohonen_pattern_print","tags":"","loc":"proc\\kohonen_pattern_print.html"},{"title":"create_distance – KohonenF08","text":"public  subroutine create_distance(factory, type_, dist) Class constructor Type Bound factory_distance Arguments Type Intent Optional Attributes Name class( factory_distance ) :: factory A factory_distance object character(len=*) :: type_ A character string with the type of distance to be instantiated class( distance_base ), allocatable :: dist An allocatable distance_base object Called by proc~~create_distance~~CalledByGraph proc~create_distance factory_distance%create_distance proc~create_2lsom two_level_self_organizing_map%create_2lsom proc~create_2lsom->proc~create_distance proc~create_som self_organizing_map%create_som proc~create_som->proc~create_distance proc~set_cluster_layer two_level_self_organizing_map%set_cluster_layer proc~set_cluster_layer->proc~create_distance proc~external_predict_map self_organizing_map%external_predict_map proc~external_predict_map->proc~create_som proc~train_som train_som proc~train_som->proc~create_som proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~create_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine create_distance ( factory , type_ , dist ) !======================================================================================== !! Class constructor class ( factory_distance ) :: factory !! A `factory_distance` object character ( len =* ) :: type_ !! A character string with the type of distance to be instantiated class ( distance_base ), allocatable :: dist !! An allocatable `distance_base` object select case ( trim ( type_ )) case ( 'euclidean' ) !write(*,*) 'Euclidean distance'; if ( allocated ( dist )) deallocate ( dist ); allocate ( euclidean_distance :: dist ); case ( 'manhattan' ) !         !write(*,*) 'Manhattan distance allocated'; if ( allocated ( dist )) deallocate ( dist ); allocate ( manhattan_distance :: dist ); case ( 'max' ) if ( allocated ( dist )) deallocate ( dist ); allocate ( max_distnace :: dist ); case default write ( * , * ) 'ERROR: the requested distance is not defined' stop end select ! end subroutine create_distance","tags":"","loc":"proc\\create_distance.html"},{"title":"initialize_variables – KohonenF08","text":"public  subroutine initialize_variables(par_file) Arguments Type Intent Optional Attributes Name character(len=*) :: par_file Calls proc~~initialize_variables~4~~CallsGraph proc~initialize_variables~4 initialize_variables none~create~3 rkiss05_generator%create proc~initialize_variables~4->none~create~3 none~destroy~3 rkiss05_generator%destroy proc~initialize_variables~4->none~destroy~3 none~generate rkiss05_generator%generate proc~initialize_variables~4->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: idata integer, public :: ipattern integer, public :: ivar integer, public :: ierr integer, public :: number_variables integer, public :: i integer, public :: j integer, public :: ipar integer, public :: train_option integer, public :: view_option integer, public :: random_seeds_option real(kind=wp), public, allocatable :: var (:,:) logical, public :: testfl logical, public :: testop character(len=NUMCHAR), public :: current_line character(len=NUMCHAR), public :: current_file integer, public, dimension(1000) :: column_var character(len=NUMCHAR), public, allocatable :: pattern_files (:) Source Code subroutine initialize_variables ( par_file ) ! character ( len =* ) :: par_file ! integer :: idata , ipattern , ivar , ierr , number_variables , i , j , ipar , train_option , view_option integer :: random_seeds_option real ( kind = wp ), allocatable :: var (:,:) logical :: testfl , testop character ( len = NUMCHAR ) :: current_line character ( len = NUMCHAR ) :: current_file integer , dimension ( 1000 ) :: column_var character ( len = NUMCHAR ), allocatable :: pattern_files (:) ! idata = 1 ; ipar = 2 ; ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR: parameter file does not exist' endif open ( ipar , file = trim ( par_file ), status = 'unknown' , access = 'sequential' , action = 'read' ); write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'TWO_LEVEL_SOM_ESTIMATE_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo do while ( trim ( current_line ) . ne . 'LAYER1' ) read ( ipar , '(A)' ) current_line enddo write ( * , * ) write ( * , * ) 'LAYER 1: Reading parameters...' ; write ( * , * ) read ( ipar , * ) train_option write ( * , * ) 'Train option= ' , train_option read ( ipar , '(A40)' ) som_parameters ( 1 )% pattern_file write ( * , * ) 'Pattern file= ' , trim ( som_parameters ( 1 )% pattern_file ) read ( ipar , * ) som_parameters ( 1 )% number_patterns ; write ( * , * ) 'Number patterns= ' , som_parameters ( 1 )% number_patterns ; read ( ipar , * ) som_parameters ( 1 )% number_variables1 ,& som_parameters ( 1 )% number_variables2 ; number_variables = som_parameters ( 1 )% number_variables1 * & som_parameters ( 1 )% number_variables2 ; write ( * , * ) 'nvar1,nvar2,nvar= ' , som_parameters ( 1 )% number_variables1 ,& som_parameters ( 1 )% number_variables2 ,& number_variables ; allocate ( var ( som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 ), stat = ierr ); allocate ( association_matrix ( som_parameters ( 1 )% number_patterns , som_parameters ( 1 )% number_patterns ), stat = ierr ); association_matrix = 0.0d0 ; allocate ( clusters ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( train_option . eq . 0 ) then if ( number_variables . le . 10 ) then read ( ipar , * ) ( column_var ( ivar ), ivar = 1 , number_variables ); write ( * , * ) 'columns= ' ,( column_var ( ivar ), ivar = 1 , number_variables ); else read ( ipar , * ) write ( * , * ) 'WARNING: Assigning columns internally' do ivar = 1 , number_variables column_var ( ivar ) = ivar ; enddo endif else read ( ipar , * ) endif read ( ipar , '(A40)' ) som_parameters ( 1 )% som_type write ( * , * ) 'SOM type= ' , trim ( som_parameters ( 1 )% som_type ); read ( ipar , * ) som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz read ( ipar , * ) som_parameters ( 1 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 1 )% number_epochs read ( ipar , * ) som_parameters ( 1 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 1 )% learning_rate !   read(ipar,*) som_parameters(1)%random_seed_(1) !   write(*,*) 'random seed= ',som_parameters(1)%random_seed_(1) read ( ipar , '(A40)' ) som_parameters ( 1 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 1 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 1 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 1 )% neighborhood_type ) read ( ipar , * ) som_parameters ( 1 )% debug_level write ( * , * ) 'debug level= ' , som_parameters ( 1 )% debug_level read ( ipar , '(A40)' ) som_parameters ( 1 )% debug_file write ( * , * ) 'debug file= ' , trim ( som_parameters ( 1 )% debug_file ); read ( ipar , '(A40)' ) som_parameters ( 1 )% output_file write ( * , * ) 'output file base= ' , trim ( som_parameters ( 1 )% output_file ) read ( ipar , * ) view_option if ( view_option . eq . 1 ) then som_parameters ( 1 )% view_flag = . TRUE .; else som_parameters ( 1 )% view_flag = . FALSE .; endif write ( * , * ) 'Print training results= ' , som_parameters ( 1 )% view_flag write ( * , * ) write ( * , * ) 'LAYER 1: Reading parameters...finished' ; write ( * , * ) current_line = '' ; do while ( trim ( current_line ) . ne . 'LAYER2' ) read ( ipar , '(A)' ) current_line enddo write ( * , * ) write ( * , * ) 'LAYER 2: Reading parameters...' ; write ( * , * ) som_parameters ( 2 )% number_nodes_nx = 0 ; som_parameters ( 2 )% number_nodes_ny = 0 ; som_parameters ( 2 )% number_nodes_nz = 0 ; read ( ipar , * ) ( min_nodes ( i ), i = 1 , 3 ); write ( 6 , * ) 'Min number of nodes= ' ,( min_nodes ( i ), i = 1 , 3 ); read ( ipar , * ) ( max_nodes ( i ), i = 1 , 3 ); write ( 6 , * ) 'Max number of nodes= ' ,( max_nodes ( i ), i = 1 , 3 ) !    write(*,*) 'number nodes= ',som_parameters(2)%number_nodes_nx,& !                 som_parameters(2)%number_nodes_ny,& !                 som_parameters(2)%number_nodes_nz read ( ipar , * ) som_parameters ( 2 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 2 )% number_epochs read ( ipar , * ) som_parameters ( 2 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 2 )% learning_rate !   read(ipar,*) som_parameters(2)%random_seed_ !   write(*,*) 'random seed= ',som_parameters(2)%random_seed_ read ( ipar , '(A40)' ) som_parameters ( 2 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 2 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 2 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 2 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 2 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 2 )% neighborhood_type ) write ( * , * ) write ( * , * ) 'LAYER 2: Reading parameters...finished' ; write ( * , * ) ! current_line = '' ; do while ( current_line . ne . 'RANDOM_SEEDS' ) read ( ipar , '(A)' ) current_line enddo write ( 6 , * ) '' write ( 6 , * ) 'RANDOM SEEDS: Reading parameters...' write ( 6 , * ) '' ! read ( ipar , * ) random_seeds_option ; write ( 6 , * ) 'random seeds option= ' , random_seeds_option ; read ( ipar , * ) number_clusters_evaluations ; write ( 6 , * ) 'Number random seeds= ' , number_clusters_evaluations ; allocate ( seeds ( number_clusters_evaluations ), stat = ierr ); if ( random_seeds_option . eq . 1 ) then read ( ipar , * ) ( seeds ( iseed ), iseed = 1 , number_clusters_evaluations ); write ( 6 , * ) 'Seeds= ' ,( seeds ( iseed ), iseed = 1 , number_clusters_evaluations ); else read ( ipar , * ) seeds ( 1 ); call rgrator % create ( seeds ( 1 )); !call sgrnd(seeds(1)); do i = 1 , number_clusters_evaluations !seeds(i)=int(1.0e7*grnd()); seeds ( i ) = int ( 1.0e7 * rgrator % generate ()); enddo call rgrator % destroy (); endif ! allocate ( total_results ( max_nodes ( 1 ) - min_nodes ( 1 ), number_clusters_evaluations , 3 ), stat = ierr ); ! write ( 6 , * ) '' write ( 6 , * ) 'RANDOM SEEDS: Reading parameters...finished' write ( 6 , * ) '' !   stop ! !   allocate(my_som(number_clusters_evaluations),stat=ierr); ! write ( * , * ) 'Reading parameter file...finished' close ( ipar ); inquire ( file = trim ( som_parameters ( 1 )% pattern_file ), exist = testfl ) if (. not . testfl ) then stop 'ERROR: input file does not exist' endif ! som_parameters ( 1 )% idbg = 10 ; som_parameters ( 1 )% iout = 11 ; som_parameters ( 1 )% iindex = 12 ; som_parameters ( 1 )% iprot = 13 ; som_parameters ( 1 )% ihit = 14 ; som_parameters ( 1 )% idist = 15 ; som_parameters ( 1 )% iumat = 16 ; som_parameters ( 1 )% ipar = 17 ; som_parameters ( 1 )% isam = 18 ; som_parameters ( 1 )% iclus = 19 ; som_parameters ( 1 )% icen = 20 ; som_parameters ( 1 )% iclus1 = 21 ; ! som_parameters ( 1 )% iout1 = 22 ; som_parameters ( 1 )% imeas = 23 ; ! ! ! allocate ( input_patterns ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( train_option . eq . 0 ) then ! write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' ); do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' elseif ( train_option . eq . 1 ) then allocate ( pattern_files ( som_parameters ( 1 )% number_patterns ), stat = ierr ); write ( * , * ) 'Reading pattern files...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' ); do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , '(A)' , err = 90 ) pattern_files ( ipattern ); enddo !ipattern write ( * , * ) 'Reading pattern files...finished!' ; ! write ( * , * ) 'Reading patterns...' ; do ipattern = 1 , som_parameters ( 1 )% number_patterns inquire ( file = trim ( pattern_files ( ipattern )), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the file ' , trim ( pattern_files ( ipattern )), ' does not exist' stop endif write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )); open ( idata , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' , access = 'sequential' ); do i = 1 , size ( var , 1 ) read ( idata , * , err = 91 ) ( var ( i , j ), j = 1 , size ( var , 2 )); enddo !ix close ( idata ); write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )), ' finished' ; call input_patterns ( ipattern )% create ( var ); enddo !ipattern write ( * , * ) 'Reading patterns...finished!' ; endif ! if ( som_parameters ( 1 )% debug_level . gt . 0 ) then open ( som_parameters ( 1 )% idbg , file = trim ( som_parameters ( 1 )% debug_file ),& status = 'unknown' , access = 'sequential' , action = 'write' ); endif ! write ( * , * ) 'Opening output files...' ; ! output file current_file = trim ( som_parameters ( 1 )% output_file ) // '_evaluation_output.out' open ( som_parameters ( 1 )% iout1 , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); !    write(som_parameters(1)%iout1,'(A)') 'KOHONEN MAP EVALUATION RESULTS'; !    write(som_parameters(1)%iout1,'(A6,1X,6A12)') 'clust.','H Ind.','KL','CH','Ball','Silhouette','Friedman' ! current_file = trim ( som_parameters ( 1 )% output_file ) // '_association_matrix.out' ; matrix_fl = trim ( current_file ); open ( som_parameters ( 1 )% imeas , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); !  write(som_parameters(1)%imeas,'(A)') 'KOHONEN MAP - ASSOCIATION MATRIX' !  write(som_parameters(1)%imeas,*) som_parameters(1)%number_patterns,som_parameters(1)%number_patterns ! ! parameter file ! !    current_file=trim(som_parameters(1)%output_file)//'_parameters.som'; !    open(som_parameters(1)%ipar,file=trim(current_file),status='unknown',& !         action='write',access='sequential') !    call som_parameters(1)%print(som_parameters(1)%ipar); !    som_parameters(2)%output_file='NOFILE'; !    som_parameters(2)%pattern_file='NOFILE'; !    som_parameters(2)%debug_file='NOFILE'; !    call som_parameters(2)%print(som_parameters(1)%ipar); !    close(som_parameters(1)%ipar) ! ! neuron indices !    current_file=trim(som_parameters(1)%output_file)//'_neuron_indices.out'; !    open(som_parameters(1)%iindex,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iindex,'(A)') 'KOHONEN MAP PATTERN INDICES' !    write(som_parameters(1)%iindex,'(A17,1X,2I6)') 'Number Patterns= ',& !          som_parameters(1)%number_patterns,3; !       write(som_parameters(1)%iindex,'(A21)') 'Pattern Number,ix,iy ' ! ! neuron prototypes !    current_file=trim(som_parameters(1)%output_file)//'_prototypes.out'; !    open(som_parameters(1)%iprot,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iprot,'(A)') 'KOHONEN MAP PROTOTYPES' !    write(som_parameters(1)%iprot,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz !    write(som_parameters(1)%iprot,'(A21,1X,2I6)') 'number of variables= ',& !         som_parameters(1)%number_variables1,som_parameters(1)%number_variables2 ! ! neuron hit !    current_file=trim(som_parameters(1)%output_file)//'_neuron_hit.out'; !    open(som_parameters(1)%ihit,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%ihit,'(A)') 'KOHONEN MAP NEURON HITS' !    write(som_parameters(1)%ihit,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! neuron distances !    current_file=trim(som_parameters(1)%output_file)//'_neuron_distances.out'; !    open(som_parameters(1)%idist,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%idist,'(A)') 'KOHONEN MAP DISTANCE MATRIX' !    write(som_parameters(1)%idist,'(A17,1X,2I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx*som_parameters(1)%number_nodes_ny*& !         som_parameters(1)%number_nodes_nz,& !         som_parameters(1)%number_nodes_nx*som_parameters(1)%number_nodes_ny*& !         som_parameters(1)%number_nodes_nz ! ! u-matrix !    current_file=trim(som_parameters(1)%output_file)//'_u-matrix.out'; !    open(som_parameters(1)%iumat,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iumat,'(A)') 'KOHONEN MAP U-MATRIX' !    write(som_parameters(1)%iumat,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_map_samples.out'; !    open(som_parameters(1)%isam,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%isam,'(A)') 'KOHONEN MAP SAMPLE LOCATION' !    write(som_parameters(1)%isam,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_clusters.out'; !    open(som_parameters(1)%iclus,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iclus,'(A)') 'KOHONEN MAP CLUSTERS' !    write(som_parameters(1)%iclus,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_cluster_centers.out'; !    open(som_parameters(1)%icen,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%icen,'(A)') 'KOHONEN MAP CLUSTER CENTERS' !    write(som_parameters(1)%icen,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_cluster_samples.out'; !    open(som_parameters(1)%iclus1,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iclus1,'(A)') 'KOHONEN MAP CLUSTER SAMPLES' ! !   write(som_parameters(1)%icen,'(A17,1X,3I6)') 'number of nodes= ',& ! !        som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& ! !        som_parameters(1)%number_nodes_nz !    write(som_parameters(1)%iclus1,'(2I6)') som_parameters(1)%number_patterns,5 ! write ( * , * ) 'Opening output files...finished!!!' ; ! deallocate ( var ); ! return ; ! 90 stop 'ERROR while reading pattern file' 91 stop 'ERROR while reading pattern sample file' ! end subroutine initialize_variables","tags":"","loc":"proc\\initialize_variables~4.html"},{"title":"release_variables – KohonenF08","text":"public  subroutine release_variables() Arguments None Calls proc~~release_variables~4~~CallsGraph proc~release_variables~4 release_variables proc~kohonen_pattern_destroy kohonen_pattern%kohonen_pattern_destroy proc~release_variables~4->proc~kohonen_pattern_destroy none~destroy kohonen_prototype%destroy proc~kohonen_pattern_destroy->none~destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i logical, public :: testop Source Code subroutine release_variables () integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( seeds )) then deallocate ( seeds ); endif ! if ( allocated ( total_results )) then deallocate ( total_results ); endif ! if ( allocated ( association_matrix )) then deallocate ( association_matrix ); endif ! if ( allocated ( clusters )) then deallocate ( clusters ); endif ! inquire ( unit = som_parameters ( 1 )% iout1 , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iout1 ); endif ! inquire ( unit = som_parameters ( 1 )% imeas , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% imeas ); endif !   inquire(unit=som_parameters(1)%iindex,opened=testop); !   if(testop) then !     close(som_parameters(1)%iindex); !   endif ! ! !   inquire(unit=som_parameters(1)%iprot,opened=testop); !   if(testop) then !     close(som_parameters(1)%iprot); !   endif ! ! !   inquire(unit=som_parameters(1)%ihit,opened=testop); !   if(testop) then !     close(som_parameters(1)%ihit); !   endif ! ! !   inquire(unit=som_parameters(1)%idist,opened=testop); !   if(testop) then !     close(som_parameters(1)%idist); !   endif ! ! !   inquire(unit=som_parameters(1)%iumat,opened=testop); !   if(testop) then !     close(som_parameters(1)%iumat); !   endif ! ! !   inquire(unit=som_parameters(1)%isam,opened=testop); !   if(testop) then !     close(som_parameters(1)%isam); !   endif ! ! !   inquire(unit=som_parameters(1)%iclus,opened=testop); !   if(testop) then !     close(som_parameters(1)%iclus); !   endif ! ! !   inquire(unit=som_parameters(1)%icen,opened=testop); !   if(testop) then !     close(som_parameters(1)%icen); !   endif ! ! !   inquire(unit=som_parameters(1)%iclus1,opened=testop); !   if(testop) then !     close(som_parameters(1)%iclus1); !   endif ! ! ! !   inquire(file=trim(som_parameters(1)%debug_file),opened=testop); !   if(testop) then !     close(som_parameters(1)%idbg); !   endif ! end subroutine release_variables","tags":"","loc":"proc\\release_variables~4.html"},{"title":"calculate_euclidean_distance – KohonenF08","text":"public  function calculate_euclidean_distance(distance, vector1, vector2) result(d) Function to calculate euclidean distance between vectors Type Bound euclidean_distance Arguments Type Intent Optional Attributes Name class( euclidean_distance ) :: distance A euclidean_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Source Code function calculate_euclidean_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate euclidean distance between vectors class ( euclidean_distance ) :: distance !! A `euclidean_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 !! A real vector real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector2 !! A real vector real ( kind = wp ) :: d !! A real variable with the distance d = sum (( vector1 - vector2 ) ** 2 ); ! end function calculate_euclidean_distance","tags":"","loc":"proc\\calculate_euclidean_distance.html"},{"title":"position2index – KohonenF08","text":"public  function position2index(ix, iy, iz, nx, ny) result(index_) Function to calculate the index inside a rectangular grid from position ix,iy,iz Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix Integer variables ix,iy,iz,nx,ny integer, intent(in) :: iy Integer variables ix,iy,iz,nx,ny integer, intent(in) :: iz Integer variables ix,iy,iz,nx,ny integer, intent(in) :: nx Integer variables ix,iy,iz,nx,ny integer, intent(in) :: ny Integer variables ix,iy,iz,nx,ny Return Value integer Integer variable with the index Called by proc~~position2index~2~~CalledByGraph proc~position2index~2 position2index proc~calculate_distance_between_prototypes~2 two_level_self_organizing_map%calculate_distance_between_prototypes proc~calculate_distance_between_prototypes~2->proc~position2index~2 proc~create_2lsom two_level_self_organizing_map%create_2lsom proc~create_2lsom->proc~position2index~2 proc~read_som_layer two_level_self_organizing_map%read_som_layer proc~read_som_layer->proc~position2index~2 proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_grid_layer->proc~position2index~2 proc~train_grid_layer->proc~calculate_distance_between_prototypes~2 proc~update_weights~2 two_level_self_organizing_map%update_weights proc~update_weights~2->proc~position2index~2 proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~train_grid_layer proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~create_2lsom proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function position2index ( ix , iy , iz , nx , ny ) result ( index_ ) !======================================================================================== !!   Function to calculate the index inside a rectangular grid from position ix,iy,iz integer , intent ( in ) :: ix , iy , iz , nx , ny !! Integer variables ix,iy,iz,nx,ny integer :: index_ !! Integer variable with the index !***** index_ = ix + ( iy - 1 ) * nx + ( iz - 1 ) * nx * ny ! end function position2index","tags":"","loc":"proc\\position2index~2.html"},{"title":"create_2lsom – KohonenF08","text":"public  subroutine create_2lsom(kohonen_map, training_parameters) Constructor of a two_level self_organized_map class Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters structure Calls proc~~create_2lsom~~CallsGraph proc~create_2lsom two_level_self_organizing_map%create_2lsom none~create~3 rkiss05_generator%create proc~create_2lsom->none~create~3 proc~calculate_distance_matrix~2 two_level_self_organizing_map%calculate_distance_matrix proc~create_2lsom->proc~calculate_distance_matrix~2 proc~create_distance factory_distance%create_distance proc~create_2lsom->proc~create_distance proc~create_random_sample~2 two_level_self_organizing_map%create_random_sample proc~create_2lsom->proc~create_random_sample~2 proc~position2index~2 position2index proc~create_2lsom->proc~position2index~2 none~generate rkiss05_generator%generate proc~create_random_sample~2->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_2lsom~~CalledByGraph proc~create_2lsom two_level_self_organizing_map%create_2lsom proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~create_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ierr integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: nvar1 integer, public :: nvar2 integer, public :: number_clusters integer, public :: ivar1 integer, public :: ivar2 integer, public :: current_index real(kind=wp), public, allocatable :: input (:,:) integer, public :: seed Source Code subroutine create_2lsom ( kohonen_map , training_parameters ) !======================================================================================== !!   Constructor of a two_level self_organized_map class class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` structure integer :: ierr , nx , ny , nz , ix , iy , iz , nvar1 , nvar2 , number_clusters , ivar1 , ivar2 , current_index real ( kind = wp ), allocatable :: input (:,:) integer :: seed ! kohonen_map % parameters = training_parameters ( 1 : 2 ); nx = training_parameters ( 1 )% number_nodes_nx ; ny = training_parameters ( 1 )% number_nodes_ny ; nz = training_parameters ( 1 )% number_nodes_nz ; nvar1 = training_parameters ( 1 )% number_variables1 ; nvar2 = training_parameters ( 1 )% number_variables2 ; number_clusters = training_parameters ( 2 )% number_nodes_nx * & training_parameters ( 2 )% number_nodes_ny * & training_parameters ( 2 )% number_nodes_nz ; kohonen_map % number_clusters = number_clusters ; kohonen_map % number_variables = nvar1 * nvar2 ; kohonen_map % number_variables1 = nvar1 ; kohonen_map % number_variables2 = nvar2 ; kohonen_map % number_nodes = nx * ny * nz ; allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); kohonen_map % coordinates = 0 ; allocate ( input ( nvar1 , nvar2 ), stat = ierr ); input = 0.0_wp ; allocate ( kohonen_map % number_patterns ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % cells_index ( training_parameters ( 1 )% number_patterns , 3 ), stat = ierr ); kohonen_map % number_patterns = 0 ; kohonen_map % cells_index = 0 ; allocate ( kohonen_map % u_matrix ( 2 * nx - 1 , 2 * ny - 1 , 2 * nz - 1 ), stat = ierr ); kohonen_map % u_matrix = 0.0_wp ; allocate ( kohonen_map % distance ( nx * ny * nz , nx * ny * nz ), stat = ierr ); !  cluster layer arrays allocate ( kohonen_map % cluster_layer ( number_clusters ), stat = ierr ); allocate ( kohonen_map % cluster_cells_index ( nx * ny * nz , 4 ), stat = ierr ); kohonen_map % cluster_cells_index = 0 ; allocate ( kohonen_map % cluster_number_patterns ( number_clusters ), stat = ierr ); kohonen_map % cluster_number_patterns = 0 ; allocate ( kohonen_map % grid_cluster ( nx , ny , nz ), stat = ierr ); kohonen_map % grid_cluster = 0 ; allocate ( kohonen_map % cluster_samples ( training_parameters ( 1 )% number_patterns ), stat = ierr ); allocate ( kohonen_map % number_cluster_samples ( number_clusters ), stat = ierr ); !Lack of initialization was causing problems during execution kohonen_map % number_cluster_samples = 0 ; allocate ( kohonen_map % index_cluster_samples ( number_clusters ,& training_parameters ( 1 )% number_patterns ), stat = ierr ); kohonen_map % index_cluster_samples = 0 ! call kohonen_map % factory % create_distance ( training_parameters ( 1 )% distance_type ,& kohonen_map % distance_function ); ! kohonen_map % seed1 = training_parameters ( 1 )% random_seed_ ( 1 ) + 100 ; call kohonen_map % rnumber_grator ( 1 )% create ( kohonen_map % seed1 ); !call sgrnd(seed) write ( * , * ) 'TWO LEVEL SOM: Initializing grid...' , seed do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx call kohonen_map % create_random_sample ( input ); !call grnd_array(input); !            write(*,*) ix,iy,input(1:2,1) call kohonen_map % grid ( ix , iy , iz )% create ( input ); !call kohonen_map%grid(ix,iy)%print(); current_index = position2index ( ix , iy , iz , nx , ny ); kohonen_map % coordinates ( current_index , 1 ) = dble ( ix ); kohonen_map % coordinates ( current_index , 2 ) = dble ( iy ); kohonen_map % coordinates ( current_index , 3 ) = dble ( iz ); !            write(*,*) ix+(iy-1)*nx+(iz-1)*nx*ny if ( trim ( training_parameters ( 1 )% node_type ) . eq . 'hexagonal' ) then !              write(*,*) 'hexagonal' kohonen_map % coordinates ( current_index , 1 ) = kohonen_map % coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( kohonen_map % coordinates ( current_index , 2 ), 2.0_wp )); kohonen_map % coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2._wp ) * kohonen_map % coordinates ( current_index , 2 ); endif enddo !iz enddo !iy enddo !ix ! ! ! allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); call kohonen_map % calculate_distance_matrix ( kohonen_map % coordinates ,& kohonen_map % cells_distances , training_parameters ( 1 )% node_type ,& training_parameters ( 1 )% toroidal_grid ); ! ! ! kohonen_map % seed2 = training_parameters ( 2 )% random_seed_ ( 1 ); !call sgrnd(seed); call kohonen_map % rnumber_grator ( 2 )% create ( kohonen_map % seed2 ); ! do ix = 1 , number_clusters !call grnd_array(input); call kohonen_map % create_random_sample ( input ); call kohonen_map % cluster_layer ( ix )% create ( input ); enddo ! deallocate ( input ); ! write ( * , * ) 'TWO LEVEL SOM: Initializing grid...OK' ! end subroutine create_2lsom","tags":"","loc":"proc\\create_2lsom.html"},{"title":"destroy_2lsom – KohonenF08","text":"public  subroutine destroy_2lsom(kohonen_map) Destructor of a two_level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object Calls proc~~destroy_2lsom~~CallsGraph proc~destroy_2lsom two_level_self_organizing_map%destroy_2lsom none~destroy kohonen_prototype%destroy proc~destroy_2lsom->none~destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_2lsom~~CalledByGraph proc~destroy_2lsom two_level_self_organizing_map%destroy_2lsom proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~destroy_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz Source Code subroutine destroy_2lsom ( kohonen_map ) !======================================================================================== !!   Destructor of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: ix , iy , iz ! write ( * , * ) 'TWO LEVEL SOM: Releasing memory...' if ( allocated ( kohonen_map % grid )) then do ix = 1 , size ( kohonen_map % grid , 1 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do iz = 1 , size ( kohonen_map % grid , 3 ); call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif ! if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif ! if ( allocated ( kohonen_map % number_patterns )) then deallocate ( kohonen_map % number_patterns ); endif ! if ( allocated ( kohonen_map % cells_index )) then deallocate ( kohonen_map % cells_index ); endif ! if ( allocated ( kohonen_map % u_matrix )) then deallocate ( kohonen_map % u_matrix ); endif ! if ( allocated ( kohonen_map % distance )) then deallocate ( kohonen_map % distance ); endif ! if ( allocated ( kohonen_map % distance_function )) then deallocate ( kohonen_map % distance_function ); endif ! ! Deallocate cluster layers arrays ! do ix = 1 , size ( kohonen_map % cluster_layer ) call kohonen_map % cluster_layer ( ix )% destroy (); enddo deallocate ( kohonen_map % cluster_layer ) ! if ( allocated ( kohonen_map % cluster_cells_index )) then deallocate ( kohonen_map % cluster_cells_index ); endif ! if ( allocated ( kohonen_map % cluster_number_patterns )) then deallocate ( kohonen_map % cluster_number_patterns ); endif ! if ( allocated ( kohonen_map % grid_cluster )) then deallocate ( kohonen_map % grid_cluster ); endif ! if ( allocated ( kohonen_map % cluster_samples )) then deallocate ( kohonen_map % cluster_samples ); endif ! if ( allocated ( kohonen_map % number_cluster_samples )) then deallocate ( kohonen_map % number_cluster_samples ); endif ! if ( allocated ( kohonen_map % index_cluster_samples )) then deallocate ( kohonen_map % index_cluster_samples ); endif ! write ( * , * ) 'TWO LEVEL SOM: Releasing memory...OK!' ! end subroutine destroy_2lsom","tags":"","loc":"proc\\destroy_2lsom.html"},{"title":"create_random_sample – KohonenF08","text":"public  subroutine create_random_sample(kohonen_map, input) Subroutine to generate random values that serve as inputs to the SOM Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: input A real array with the initial values of the prototypes Calls proc~~create_random_sample~2~~CallsGraph proc~create_random_sample~2 two_level_self_organizing_map%create_random_sample none~generate rkiss05_generator%generate proc~create_random_sample~2->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_random_sample~2~~CalledByGraph proc~create_random_sample~2 two_level_self_organizing_map%create_random_sample proc~create_2lsom two_level_self_organizing_map%create_2lsom proc~create_2lsom->proc~create_random_sample~2 proc~set_cluster_layer two_level_self_organizing_map%set_cluster_layer proc~set_cluster_layer->proc~create_random_sample~2 proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~create_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nvar1 integer, public :: nvar2 integer, public :: i integer, public :: j Source Code subroutine create_random_sample ( kohonen_map , input ) !======================================================================================== !! Subroutine to generate random values that serve as inputs to the SOM class ( two_level_self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: input !! A real array with the initial values of the prototypes integer :: nvar1 , nvar2 , i , j ! nvar1 = size ( input , 1 ); nvar2 = size ( input , 2 ); do i = 1 , nvar1 ; do j = 1 , nvar2 ; input ( i , j ) = kohonen_map % rnumber_grator ( 1 )% generate (); end do end do ! end subroutine create_random_sample","tags":"","loc":"proc\\create_random_sample~2.html"},{"title":"train_2lsom – KohonenF08","text":"public  subroutine train_2lsom(kohonen_map, input_data) Subroutine to train a two_level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array Calls proc~~train_2lsom~~CallsGraph proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~assign_input_to_clusters two_level_self_organizing_map%assign_input_to_clusters proc~train_2lsom->proc~assign_input_to_clusters proc~train_cluster_layer two_level_self_organizing_map%train_cluster_layer proc~train_2lsom->proc~train_cluster_layer proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_2lsom->proc~train_grid_layer none~distance kohonen_prototype%distance proc~assign_input_to_clusters->none~distance proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~assign_input_to_clusters->proc~kohonen_pattern_accessor float float proc~train_cluster_layer->float proc~train_cluster_layer->none~distance none~get_prototype kohonen_prototype%get_prototype proc~train_cluster_layer->none~get_prototype none~set_prototype kohonen_prototype%set_prototype proc~train_cluster_layer->none~set_prototype proc~train_grid_layer->float proc~train_grid_layer->none~distance proc~train_grid_layer->none~get_prototype proc~train_grid_layer->none~set_prototype proc~calculate_distance_between_prototypes~2 two_level_self_organizing_map%calculate_distance_between_prototypes proc~train_grid_layer->proc~calculate_distance_between_prototypes~2 proc~calculate_u_matrix~2 two_level_self_organizing_map%calculate_u_matrix proc~train_grid_layer->proc~calculate_u_matrix~2 proc~index2position~2 index2position proc~train_grid_layer->proc~index2position~2 proc~train_grid_layer->proc~kohonen_pattern_accessor proc~position2index~2 position2index proc~train_grid_layer->proc~position2index~2 none~distance->none~get_prototype calculate calculate none~distance->calculate proc~calculate_distance_between_prototypes~2->proc~position2index~2 proc~calculate_u_matrix~2->none~distance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~train_2lsom~~CalledByGraph proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine train_2lsom ( kohonen_map , input_data ) !======================================================================================== !!   Subroutine to train a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array call train_grid_layer ( kohonen_map , input_data ); ! call train_cluster_layer ( kohonen_map ); ! call kohonen_map % assign_input_to_clusters ( input_data ); ! end subroutine train_2lsom","tags":"","loc":"proc\\train_2lsom.html"},{"title":"predict_2lsom – KohonenF08","text":"public  subroutine predict_2lsom(kohonen_map, input_data, map_output) Subroutine to make a prediction from a trained two_level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array integer, intent(out), dimension(:,:) :: map_output An integer array Calls proc~~predict_2lsom~~CallsGraph proc~predict_2lsom two_level_self_organizing_map%predict_2lsom float float proc~predict_2lsom->float none~distance kohonen_prototype%distance proc~predict_2lsom->none~distance none~get_prototype kohonen_prototype%get_prototype proc~predict_2lsom->none~get_prototype proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~predict_2lsom->proc~kohonen_pattern_accessor none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ipattern integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: number_variables integer, public :: ic real(kind=wp), public :: dist_hit real(kind=wp), public :: dist type( kohonen_prototype ), public :: current_prototype type( kohonen_prototype ), public :: predict_grid_prototype type( kohonen_prototype ), public :: predict_cluster_prototype real(kind=wp), public, dimension(kohonen_map%number_variables1,kohonen_map%number_variables2) :: current_values real(kind=wp), public, dimension(kohonen_map%number_clusters) :: distance_units Source Code subroutine predict_2lsom ( kohonen_map , input_data , map_output ) !======================================================================================== !! Subroutine to make a prediction from a trained two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array integer , dimension (:,:), intent ( out ) :: map_output !! An integer array integer :: ipattern , ihit , jhit , khit , ix , iy , iz , number_variables , ic real ( kind = wp ) :: dist_hit , dist type ( kohonen_prototype ) :: current_prototype , predict_grid_prototype , predict_cluster_prototype real ( kind = wp ), dimension ( kohonen_map % number_variables1 , kohonen_map % number_variables2 ) :: current_values real ( kind = wp ), dimension ( kohonen_map % number_clusters ) :: distance_units ! number_variables = kohonen_map % number_variables1 * kohonen_map % number_variables2 ; ! write ( * , * ) write ( * , * ) ' TWO LEVEL SOM: Prediction starting...' ; write ( * , * ) !       write(*,*) '                Prediction for Grid Layer in progress' do ipattern = 1 , size ( input_data , 1 ) ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0 ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix ; jhit = iy ; khit = iz ; endif enddo !ix enddo !iy enddo !iz !call kohonen_map%grid(ihit,jhit,khit)%get_prototype(current_values); predict_grid_prototype = kohonen_map % grid ( ihit , jhit , khit ); ihit = 0 ; dist_hit = 1 0.0e4 ; do ic = 1 , size ( kohonen_map % cluster_layer ) dist = kohonen_map % cluster_layer ( ic )% distance ( predict_grid_prototype , kohonen_map % distance_function ); distance_units ( ic ) = dist ; if ( dist . lt . dist_hit ) then dist_hit = dist ; ihit = ic ; endif enddo !         write(*,*) ipattern,ihit predict_cluster_prototype = kohonen_map % cluster_layer ( ihit ); call predict_cluster_prototype % get_prototype ( current_values ); map_output ( ipattern , 1 ) = ihit enddo !ipattern write ( * , * ) 'TWO LEVEL SOM: Prediction finished' ; ! end subroutine predict_2lsom","tags":"","loc":"proc\\predict_2lsom.html"},{"title":"train_grid_layer – KohonenF08","text":"public  subroutine train_grid_layer(kohonen_map, input_data) Subroutine to train the grid layer of a two_level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array Calls proc~~train_grid_layer~~CallsGraph proc~train_grid_layer two_level_self_organizing_map%train_grid_layer float float proc~train_grid_layer->float none~distance kohonen_prototype%distance proc~train_grid_layer->none~distance none~get_prototype kohonen_prototype%get_prototype proc~train_grid_layer->none~get_prototype none~set_prototype kohonen_prototype%set_prototype proc~train_grid_layer->none~set_prototype proc~calculate_distance_between_prototypes~2 two_level_self_organizing_map%calculate_distance_between_prototypes proc~train_grid_layer->proc~calculate_distance_between_prototypes~2 proc~calculate_u_matrix~2 two_level_self_organizing_map%calculate_u_matrix proc~train_grid_layer->proc~calculate_u_matrix~2 proc~index2position~2 index2position proc~train_grid_layer->proc~index2position~2 proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~train_grid_layer->proc~kohonen_pattern_accessor proc~position2index~2 position2index proc~train_grid_layer->proc~position2index~2 none~distance->none~get_prototype calculate calculate none~distance->calculate proc~calculate_distance_between_prototypes~2->proc~position2index~2 proc~calculate_u_matrix~2->none~distance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~train_grid_layer~~CalledByGraph proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~train_grid_layer proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: iteration integer, public :: iepoch integer, public :: ipattern integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: jhit integer, public :: ihit integer, public :: khit integer, public :: ineigh integer, public :: jneigh integer, public :: kneigh integer, public :: idbg integer, public :: number_variables integer, public :: max_pattern integer, public :: ierr integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ic integer, public :: current_pos integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: i integer, public :: j integer, public :: k integer, public :: number_nodes integer, public :: debug_option integer, public :: pos integer, public :: pos1 integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 real(kind=wp), public :: distortion real(kind=wp), public :: dist real(kind=wp), public :: dist_hit real(kind=wp), public :: maximum_radius real(kind=wp), public :: minimum_radius real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: sigma2 real(kind=wp), public :: geometric_distance2 real(kind=wp), public :: h_neighborhood real(kind=wp), public :: real_distance real(kind=wp), public :: lambda real(kind=wp), public :: current_distance real(kind=wp), public :: d1 real(kind=wp), public :: d2 real(kind=wp), public :: d3 real(kind=wp), public :: term3 real(kind=wp), public :: distance_ratio type( kohonen_prototype ), public :: current_prototype type( kohonen_prototype ), public :: current_prototype1 real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: current_values real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: prototype_values real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: winner_values real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: term1 real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: term2 integer, public, allocatable :: pattern_index (:,:,:,:) logical, public :: testop integer, public :: unit_out Source Code subroutine train_grid_layer ( kohonen_map , input_data ) !======================================================================================== !! Subroutine to train the grid layer of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array integer :: iteration , iepoch , ipattern , ix , iy , iz , jhit , ihit , khit , ineigh , jneigh , kneigh integer :: idbg , number_variables , max_pattern , ierr , nx , ny , nz , ic , current_pos integer :: cx , cy , cz , i , j , k , number_nodes , debug_option , pos , pos1 , ix1 , iy1 , iz1 real ( kind = wp ) :: distortion , dist , dist_hit , maximum_radius , minimum_radius , current_radius , alpha real ( kind = wp ) :: sigma2 , geometric_distance2 , h_neighborhood , real_distance , lambda , current_distance , d1 , d2 , d3 real ( kind = wp ) :: term3 , distance_ratio type ( kohonen_prototype ) :: current_prototype , current_prototype1 real ( kind = wp ), dimension ( kohonen_map % number_variables1 ,& kohonen_map % number_variables2 ) :: current_values , prototype_values , winner_values , term1 , term2 integer , allocatable :: pattern_index (:,:,:,:) logical :: testop integer :: unit_out nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; idbg = kohonen_map % parameters ( 1 )% idbg ; debug_option = kohonen_map % parameters ( 1 )% debug_level ; if ( debug_option . gt . 0 ) then open ( idbg , file = trim ( kohonen_map % parameters ( 1 )% debug_file ), status = 'unknown' ); endif iteration = 0 distortion = 0.0_wp number_variables = kohonen_map % number_variables ; maximum_radius = real ( max ( kohonen_map % parameters ( 1 )% number_nodes_nx , kohonen_map % parameters ( 1 )% number_nodes_ny ,& kohonen_map % parameters ( 1 )% number_nodes_nz )); lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); minimum_radius = 1.0_wp ; if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Grid Layer: Training starting...' endif do iepoch = 1 , kohonen_map % parameters ( 1 )% number_epochs if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion endif distortion = 0.0_wp do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns iteration = iteration + 1 !          det best match grid unit ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e7 call input_data ( ipattern )% get ( current_prototype ); call current_prototype % get_prototype ( current_values ); !call kohonen_map%find_best_match_unit(current_prototype,ihit,jhit,khit,dist_hit); !call current_prototype%print(unit_out); !write(*,*) 'check= ',ipattern,ihit,jhit,khit,dist_hit if ( debug_option . gt . 0 ) then write ( idbg , * ) 'Epoch,Current Pattern' , iepoch , ipattern ; call current_prototype % print ( idbg ); endif ! do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ! calculate distance !call kohonen_map%grid(ix,iy,iz)%print(); dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); !write(*,*) ix,iy,iz,dist !stop if ( debug_option . gt . 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ); write ( idbg , * ) ix , iy , iz , dist endif dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix ; jhit = iy ; khit = iz ; endif enddo !iz enddo !iy enddo !ix !write(*,*) 'epoch,ipat,i,j,k,d= ',iepoch,ipattern,ihit,jhit,dist_hit !            if(kohonen_map%parameters(1)%ireal == 7) then !               write(unit_out,*) 'current_prototype' !               call current_prototype%print(unit_out) !               write(unit_out,*) 'bmu ',ipattern,ihit,jhit,dist_hit !               call kohonen_map%grid(ihit,jhit,khit)%print(unit_out) !            endif !           kohonen_map%number_patterns(ihit,jhit)=kohonen_map%number_patterns(ihit,jhit)+1; distortion = distortion + dist_hit ; ! define radius current_radius = max ( maximum_radius * real ( 1001 - iteration ) / 100 0.0 + 0.9999999999 , 1.0_wp ); ! define learning rate alpha = max ( kohonen_map % parameters ( 1 )% learning_rate * ( 1.0_wp - real ( iteration ) / 100 0.0 ), 0.01_wp ); sigma2 = current_radius ** 2 !max(0.2*maximum_radius*(1.0_wp-real(iteration)/1000.0),1.0_wp); ! update prototypes if ( debug_option . gt . 0 ) then write ( idbg , * ) 'Neighborhood,alpha= ' , alpha endif ! !           call kohonen_map%update_weights(current_values,ihit,jhit,khit,maximum_radius,iteration) ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance . lt . current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters ( 1 )% neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * exp ( - 0.5 * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option . gt . 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters ( 1 )% som_type )); case ( 'normal_som' ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'visom' ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh . eq . ihit ) . and . ( jneigh . eq . jhit ) . and . ( kneigh . eq . khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); !eps=max(1.0_wp*time_factor,0.0_wp); term3 = 1.0_wp ; !((1.0_wp-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * ( distance_ratio - 1.0_wp ) * term3 ); endif call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo ! enddo !ipattern !if(kohonen_map%parameters(1)%ireal == 7) stop enddo !iepoch if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Grid Layer: Training finished' endif ! Print prototypes !     print prototypes inquire ( unit = kohonen_map % parameters ( 1 )% iprot , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % grid , 3 ); write ( kohonen_map % parameters ( 1 )% iprot , '(A,I4)' ) 'Layer ' , iz do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters ( 1 )% iprot , '(A6,1X,3I4)' ) 'node= ' , ix , iy , iz call kohonen_map % grid ( ix , iy , iz )% print ( kohonen_map % parameters ( 1 )% iprot ); enddo enddo enddo !ix endif !     calculate and print distance matrix inquire ( unit = kohonen_map % parameters ( 1 )% idist , opened = testop ); if ( testop ) then call kohonen_map % calculate_distance_between_prototypes () ! !         do ix=1,size(kohonen_map%grid,1); !           do iy=1,size(kohonen_map%grid,2); !              do iz=1,size(kohonen_map%grid,3); !                  current_prototype=kohonen_map%grid(ix,iy,iz); !                  pos=ix+(iy-1)*kohonen_map%parameters(1)%number_nodes_ny+& !                    (iz-1)*kohonen_map%parameters(1)%number_nodes_nx*kohonen_map%parameters(1)%number_nodes_ny; !                  do ix1=1,size(kohonen_map%grid,1); !                     do iy1=1,size(kohonen_map%grid,2); !                        do iz1=1,size(kohonen_map%grid,3); !                           pos1=ix1+(iy1-1)*kohonen_map%parameters(1)%number_nodes_ny+& !                              (iz1-1)*kohonen_map%parameters(1)%number_nodes_nx*& !                              kohonen_map%parameters(1)%number_nodes_ny; !                           current_prototype1=kohonen_map%grid(ix1,iy1,iz1); !                           kohonen_map%distance(pos,pos1)=current_prototype1%distance(current_prototype,& !                                                         kohonen_map%distance_function); !                        enddo!iz1 !                     enddo!iy1 !                  enddo!ix1 !               enddo!iz !            enddo!iy !         enddo!ix ! ! !         do ix=1,size(kohonen_map%distance,1) !            write(kohonen_map%parameters(1)%idist,*) (kohonen_map%distance(ix,iy),iy=1,size(kohonen_map%distance,2)); !         enddo!ix endif ! !     final best match if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Grid Layer: Find Best Match Unit...' write ( 6 , * ) endif max_pattern = 0 ; do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0 ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); !         call kohonen_map%find_best_match_unit(current_prototype,ihit,jhit,khit,dist_hit); !write(*,*) 'bmu=',ipattern,ihit,jhit,khit do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo kohonen_map % number_patterns ( ihit , jhit , khit ) = kohonen_map % number_patterns ( ihit , jhit , khit ) + 1 ; if ( kohonen_map % number_patterns ( ihit , jhit , khit ) . gt . max_pattern ) then max_pattern = kohonen_map % number_patterns ( ihit , jhit , khit ); endif kohonen_map % cells_index ( ipattern , 1 ) = ihit ; kohonen_map % cells_index ( ipattern , 2 ) = jhit ; kohonen_map % cells_index ( ipattern , 3 ) = khit ; if ( debug_option . gt . 0 ) then write ( idbg , * ) ipattern , ihit , jhit , khit endif inquire ( unit = kohonen_map % parameters ( 1 )% iindex , opened = testop ); if ( testop ) then write ( kohonen_map % parameters ( 1 )% iindex , * ) ipattern , ihit , jhit , khit endif !          mtchx(i) = ihit !          mtchy(i) = jhit !          ioutrep(ihit,jhit) = i enddo !ipattern if ( kohonen_map % parameters ( 1 )% debug_level . gt . 0 ) then close ( idbg ) endif allocate ( pattern_index ( size ( kohonen_map % grid , 1 ), size ( kohonen_map % grid , 2 ),& size ( kohonen_map % grid , 3 ),& max_pattern ), stat = ierr ); pattern_index =- 1 ; do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); do i = 1 , max_pattern if ( pattern_index ( ix , iy , iz , i ) . lt . 0 ) then pattern_index ( ix , iy , iz , i ) = ipattern ; exit endif enddo enddo !ipattern inquire ( unit = kohonen_map % parameters ( 1 )% isam , opened = testop ); if ( testop ) then do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters ( 1 )% isam , '(A,3I4)' ) 'Node= ' , ix1 , iy1 , iz1 if ( kohonen_map % number_patterns ( ix1 , iy1 , iz1 ) . gt . 0 ) then write ( kohonen_map % parameters ( 1 )% isam , '(A,100I4)' ) 'Sample ID= ' ,& pattern_index ( ix1 , iy1 , iz1 , 1 : kohonen_map % number_patterns ( ix1 , iy1 , iz1 )); else write ( kohonen_map % parameters ( 1 )% isam , '(A,I4)' ) 'Sample ID= ' , 0 endif enddo enddo enddo deallocate ( pattern_index ); endif !     print hit counter inquire ( unit = kohonen_map % parameters ( 1 )% ihit , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % grid , 3 ) write ( kohonen_map % parameters ( 1 )% ihit , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters ( 1 )% ihit , '(100I6)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 , size ( kohonen_map % grid , 2 )); enddo !ix enddo !iz endif !     calculate u_matrix inquire ( unit = kohonen_map % parameters ( 1 )% iumat , opened = testop ); if ( testop ) then call kohonen_map % calculate_u_matrix (); !       do iz=1,size(kohonen_map%grid,3); !          do iy=1,size(kohonen_map%grid,2); !             do ix=1,size(kohonen_map%grid,1); !                dist=0.0_wp; !                number_nodes=0; !                do k=-1,1 !                   do j=-1,1 !                      do i=-1,1 !                         cx=ix+i;cy=iy+j;cz=iz+k; !                         if( (cx .ge. 1 .and. cx .le. size(kohonen_map%grid,1)) .and. & !                           (cy .ge. 1 .and. cy .le. size(kohonen_map%grid,2)) .and. & !                           (cz .ge. 1 .and. cz .le. size(kohonen_map%grid,3))) then !                               !write(*,*) ix,iy,cx,cy !                               dist=dist+kohonen_map%grid(ix,iy,iz)%distance(kohonen_map%grid(cx,cy,cz),& !                                     kohonen_map%distance_function); !                               number_nodes=number_nodes+1; !                         endif !                      enddo !                   enddo!j !                enddo!i !                kohonen_map%u_matrix(ix,iy,iz)=dist/real(number_nodes); !             enddo!iz !          enddo!iy !       enddo!ix !       do iz=1,size(kohonen_map%grid,3) !          write(kohonen_map%parameters(1)%iumat,'(A,I4)') 'Layer ',iz !          do ix=1,size(kohonen_map%grid,1) !             write(kohonen_map%parameters(1)%iumat,*) (kohonen_map%u_matrix(ix,iy,iz),iy=1,size(kohonen_map%grid,2)); !          enddo !       enddo endif if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Grid Layer: Find Best Match Unit finished' write ( 6 , * ) endif end subroutine train_grid_layer","tags":"","loc":"proc\\train_grid_layer.html"},{"title":"train_cluster_layer – KohonenF08","text":"public  subroutine train_cluster_layer(kohonen_map) Subroutine to train the cluster layer of a two_level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object Calls proc~~train_cluster_layer~~CallsGraph proc~train_cluster_layer two_level_self_organizing_map%train_cluster_layer float float proc~train_cluster_layer->float none~distance kohonen_prototype%distance proc~train_cluster_layer->none~distance none~get_prototype kohonen_prototype%get_prototype proc~train_cluster_layer->none~get_prototype none~set_prototype kohonen_prototype%set_prototype proc~train_cluster_layer->none~set_prototype none~distance->none~get_prototype calculate calculate none~distance->calculate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~train_cluster_layer~~CalledByGraph proc~train_cluster_layer two_level_self_organizing_map%train_cluster_layer proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~train_cluster_layer proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: iepoch integer, public :: ihit integer, public :: ic integer, public :: number_variables integer, public :: iteration integer, public :: ineigh integer, public :: current_pos integer, public :: ipattern integer, public :: ipos integer, public :: pos type( kohonen_prototype ), public :: current_prototype real(kind=wp), public :: dist_hit real(kind=wp), public :: dist real(kind=wp), public :: distortion real(kind=wp), public :: maximum_radius real(kind=wp), public :: minimum_radius real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: h_neighborhood real(kind=wp), public :: sigma2 real(kind=wp), public :: geometric_distance2 real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: current_values real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: prototype_values real(kind=wp), public, dimension(kohonen_map%number_variables1*kohonen_map%number_variables2) :: centers real(kind=wp), public, dimension(kohonen_map%number_clusters) :: distance_units real(kind=wp), public, dimension(kohonen_map%number_variables1*kohonen_map%number_variables2, kohonen_map%number_clusters) :: centers1 logical, public :: testop Source Code subroutine train_cluster_layer ( kohonen_map ) !======================================================================================== !! Subroutine to train the cluster layer of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: ix , iy , iz , iepoch , ihit , ic , number_variables , iteration , ineigh , current_pos , ipattern , ipos , pos type ( kohonen_prototype ) :: current_prototype real ( kind = wp ) :: dist_hit , dist , distortion , maximum_radius , minimum_radius , current_radius real ( kind = wp ) :: alpha , h_neighborhood , sigma2 , geometric_distance2 real ( kind = wp ), dimension ( kohonen_map % number_variables1 ,& kohonen_map % number_variables2 ) :: current_values , prototype_values real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ) :: centers real ( kind = wp ), dimension ( kohonen_map % number_clusters ) :: distance_units real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ,& kohonen_map % number_clusters ) :: centers1 logical :: testop ! number_variables = kohonen_map % number_variables1 * kohonen_map % number_variables2 ; !maximum_radius=real(max(kohonen_map%parameters%number_nodes_nx,kohonen_map%parameters%number_nodes_ny)); maximum_radius = real ( kohonen_map % number_clusters ); minimum_radius = 1.0_wp ; ! iteration = 0 distortion = 0.0_wp ; if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Cluster Layer: Training starting...' endif ! do iepoch = 1 , kohonen_map % parameters ( 2 )% number_epochs if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion endif distortion = 0.0_wp ; do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); iteration = iteration + 1 ihit = 0 ; dist_hit = 10000 0.0 ; current_prototype = kohonen_map % grid ( ix , iy , iz ); call current_prototype % get_prototype ( current_values ); do ic = 1 , size ( kohonen_map % cluster_layer ) dist = kohonen_map % cluster_layer ( ic )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ic ; endif enddo !ic distortion = distortion + dist_hit ; current_radius = max ( maximum_radius * real ( 1001 - iteration ) / 100 0.0 + 0.9999999999 , 0.49_wp ); sigma2 = current_radius ** 2 ; !current_radius=0.0_wp; ! define learning rate alpha = max ( kohonen_map % parameters ( 2 )% learning_rate * & ( 1.0_wp - real ( iteration ) / 100 0.0 ), 0.01_wp ); do ineigh = ihit - int ( current_radius ), ihit + int ( current_radius ) if ( ineigh . ge . 1 . and . ineigh . le . size ( kohonen_map % cluster_layer )) then select case ( trim ( kohonen_map % parameters ( 2 )% neighborhood_type )) case ( 'gaussian' ); geometric_distance2 = ( ihit - ineigh ) ** 2 ; h_neighborhood = alpha * exp ( - 0.5 * geometric_distance2 / sigma2 ); case ( 'bubble' ); h_neighborhood = alpha ; end select call kohonen_map % cluster_layer ( ineigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); call kohonen_map % cluster_layer ( ineigh )% set_prototype ( prototype_values ); endif enddo !ineigh enddo !iz enddo !iy enddo !ix enddo !iepoch if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Cluster Layer: Training finished' ; ! write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Cluster Layer: Find Best Match Unit...' write ( 6 , * ) endif ! current_pos = 0 ; do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_pos = current_pos + 1 ; ihit = 0 ; dist_hit = 10000 0.0 ; current_prototype = kohonen_map % grid ( ix , iy , iz ); call current_prototype % get_prototype ( current_values ); do ic = 1 , size ( kohonen_map % cluster_layer ); dist = kohonen_map % cluster_layer ( ic )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); distance_units ( ic ) = dist ; if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ic ; !write(*,*) 'hit= ',ix,iy,iz,ihit endif enddo kohonen_map % cluster_cells_index ( current_pos , 1 ) = ix ; kohonen_map % cluster_cells_index ( current_pos , 2 ) = iy ; kohonen_map % cluster_cells_index ( current_pos , 3 ) = iz ; kohonen_map % cluster_cells_index ( current_pos , 4 ) = ihit ; !write(6,*) 'hit= ',ix,iy,iz,ihit !            if(kohonen_map%number_patterns(ix,iy,iz) .ge. 1) then kohonen_map % grid_cluster ( ix , iy , iz ) = ihit ; !            endif !             if(debug_option .gt. 0) then !               write(idbg,*) ix,iy,iz,ihit !             endif enddo !iz enddo !iy enddo !ix ! Print grid cluster inquire ( unit = kohonen_map % parameters ( 1 )% iclus , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % grid_cluster , 3 ); write ( kohonen_map % parameters ( 1 )% iclus , * ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % grid_cluster , 1 ); write ( kohonen_map % parameters ( 1 )% iclus , '(100I5)' ) ( kohonen_map % grid_cluster ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % grid_cluster , 2 )) enddo !ix enddo !iz endif ! !     do ipattern=1,48 !        write(*,*) kohonen_map%cells_index(ipattern,:) !     enddo do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); !write(*,*) 'pre= ',ipattern,ix,iy,iz,kohonen_map%parameters(1)%number_patterns do ipos = 1 , size ( kohonen_map % cluster_cells_index , 1 ) if ( kohonen_map % cluster_cells_index ( ipos , 1 ) . eq . ix . and . & kohonen_map % cluster_cells_index ( ipos , 2 ) . eq . iy . and . & kohonen_map % cluster_cells_index ( ipos , 3 ) . eq . iz ) then pos = ipos ; exit endif enddo !ipos ic = kohonen_map % cluster_cells_index ( pos , 4 ); kohonen_map % cluster_samples ( ipattern ) = ic ; !write(*,*) 'clust-train = ',pos,ipattern, ic inquire ( unit = kohonen_map % parameters ( 1 )% iclus1 , opened = testop ); if ( testop ) then write ( kohonen_map % parameters ( 1 )% iclus1 , * ) ipattern , ix , iy , iz , ic ; endif enddo !ipattern ! do ic = 1 , size ( kohonen_map % cluster_layer ); !write(unit1,*) 'Cluster= ',ic !call kohonen_map%cluster_layer(ic)%print(unit1); call kohonen_map % cluster_layer ( ic )% get_prototype ( centers ) centers1 (:, ic ) = centers (:) enddo !ic inquire ( unit = kohonen_map % parameters ( 1 )% icen , opened = testop ); if ( testop ) then do ix = 1 , size ( centers1 , 1 ) write ( kohonen_map % parameters ( 1 )% icen , * ) ix ,( centers1 ( ix , ic ), ic = 1 , size ( centers1 , 2 )) enddo endif ! if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Cluster Layer: Find Best Match Unit finished' write ( 6 , * ) endif ! end subroutine train_cluster_layer","tags":"","loc":"proc\\train_cluster_layer.html"},{"title":"print_2lsom – KohonenF08","text":"public  subroutine print_2lsom(kohonen_map, unit_) Subroutine to print the layers of a two_level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer, optional :: unit_ An integer variable with the unit Calls proc~~print_2lsom~~CallsGraph proc~print_2lsom two_level_self_organizing_map%print_2lsom none~get_prototype kohonen_prototype%get_prototype proc~print_2lsom->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: unit1 integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ic real(kind=wp), public, dimension(kohonen_map%number_variables1*kohonen_map%number_variables2) :: centers real(kind=wp), public, dimension(kohonen_map%number_variables1*kohonen_map%number_variables2, kohonen_map%number_clusters) :: centers1 Source Code subroutine print_2lsom ( kohonen_map , unit_ ) !======================================================================================== !!   Subroutine to print the layers of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer , optional :: unit_ !! An integer variable with the unit integer :: unit1 , ix , iy , iz , ic real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ) :: centers real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ,& kohonen_map % number_clusters ) :: centers1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif ! write ( unit1 , * ) 'TWO LEVEL SOM: Results' ; write ( unit1 , * ) call kohonen_map % parameters ( 1 )% print ( unit1 ); ! write(unit1,*) 'After' write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Grid nodes' ; write ( unit1 , * ) do iz = 1 , size ( kohonen_map % grid , 3 ); do ix = 1 , size ( kohonen_map % grid , 1 ); do iy = 1 , size ( kohonen_map % grid , 2 ); write ( unit1 , * ) ix , iy , iz call kohonen_map % grid ( ix , iy , iz )% print ( unit1 ); enddo !iy enddo !ix enddo write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Grid Hit count' ; write ( unit1 , * ) write ( unit1 , * ) 'Pattern Numbers' ; do iz = 1 , size ( kohonen_map % number_patterns , 3 ) write ( unit1 , * ) write ( unit1 , * ) 'Layer ' , iz write ( unit1 , * ) do ix = 1 , size ( kohonen_map % number_patterns , 1 ) write ( unit1 , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 , size ( kohonen_map % number_patterns , 2 )) enddo enddo write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Grid Pattern index' write ( unit1 , * ) write ( unit1 , * ) write ( unit1 , * ) 'Pattern #, ix   ,iy' ; do ix = 1 , size ( kohonen_map % cells_index , 1 ) write ( unit1 , '(100I5)' ) ix , ( kohonen_map % cells_index ( ix , iy ), iy = 1 , size ( kohonen_map % cells_index , 2 )) enddo write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Cluster nodes' ; write ( unit1 , * ) open ( 2 , file = 'cluster_centers.out' , status = 'unknown' ) do ic = 1 , size ( kohonen_map % cluster_layer ); write ( unit1 , * ) 'Cluster= ' , ic call kohonen_map % cluster_layer ( ic )% print ( unit1 ); call kohonen_map % cluster_layer ( ic )% get_prototype ( centers ) centers1 (:, ic ) = centers (:) enddo !ic do ix = 1 , size ( centers1 , 1 ) write ( 2 , * ) ix ,( centers1 ( ix , ic ), ic = 1 , size ( centers1 , 2 )) enddo close ( 2 ) ! write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Cluster Pattern index' write ( unit1 , * ) ! do ix = 1 , size ( kohonen_map % cluster_cells_index , 1 ) write ( unit1 , * ) ( kohonen_map % cluster_cells_index ( ix , iy ), iy = 1 , size ( kohonen_map % cluster_cells_index , 2 )) enddo ! do iz = 1 , size ( kohonen_map % grid_cluster , 3 ); write ( unit1 , * ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % grid_cluster , 1 ); write ( unit1 , '(100I5)' ) ( kohonen_map % grid_cluster ( ix , iy , iz ), iy = 1 , size ( kohonen_map % grid_cluster , 2 )) enddo !ix enddo !iz ! end subroutine print_2lsom","tags":"","loc":"proc\\print_2lsom.html"},{"title":"set_cluster_layer – KohonenF08","text":"public  subroutine set_cluster_layer(kohonen_map, seed) Subroutine to initialize the cluster layer of a Two Level Self-Organizing Map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer :: seed An integer variable with the random seed Calls proc~~set_cluster_layer~~CallsGraph proc~set_cluster_layer two_level_self_organizing_map%set_cluster_layer none~create~3 rkiss05_generator%create proc~set_cluster_layer->none~create~3 proc~create_distance factory_distance%create_distance proc~set_cluster_layer->proc~create_distance proc~create_random_sample~2 two_level_self_organizing_map%create_random_sample proc~set_cluster_layer->proc~create_random_sample~2 none~generate rkiss05_generator%generate proc~create_random_sample~2->none~generate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: number_clusters integer, public :: ierr real(kind=wp), public, allocatable :: input (:,:) Source Code subroutine set_cluster_layer ( kohonen_map , seed ) !======================================================================================== !!   Subroutine to initialize the cluster layer of a Two Level Self-Organizing Map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: seed !! An integer variable with the random seed integer :: ix , number_clusters , ierr real ( kind = wp ), allocatable :: input (:,:) ! number_clusters = kohonen_map % parameters ( 2 )% number_nodes_nx * & kohonen_map % parameters ( 2 )% number_nodes_ny * & kohonen_map % parameters ( 2 )% number_nodes_nz ; write ( * , * ) 'nc=' , number_clusters allocate ( input ( kohonen_map % number_variables1 , kohonen_map % number_variables2 ), stat = ierr ) write ( * , * ) 'nc1= ' , size ( input , 1 ), size ( input , 2 ) ! seed = kohonen_map % parameters ( 2 )% random_seed_ ( 1 ); allocate ( kohonen_map % cluster_layer ( number_clusters ), stat = ierr ); write ( * , * ) seed call kohonen_map % rnumber_grator ( 2 )% create ( seed ); !call sgrnd(seed); do ix = 1 , number_clusters !call grnd_array(input); call kohonen_map % create_random_sample ( input ); write ( * , * ) ix , input write ( * , * ) size ( kohonen_map % cluster_layer ) call kohonen_map % cluster_layer ( ix )% create ( input ); enddo ! call kohonen_map % factory % create_distance ( kohonen_map % parameters ( 2 )% distance_type , kohonen_map % distance_function ); ! deallocate ( input ); ! end subroutine set_cluster_layer","tags":"","loc":"proc\\set_cluster_layer.html"},{"title":"set_parameters – KohonenF08","text":"public  subroutine set_parameters(kohonen_map, training_parameters) Subroutine to set parameters Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_layer_parameters ), dimension(2) :: training_parameters Source Code subroutine set_parameters ( kohonen_map , training_parameters ) !======================================================================================== !!   Subroutine to set parameters class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_layer_parameters ), dimension ( 2 ) :: training_parameters !A `kohonen_layer_parameters` object kohonen_map % parameters = training_parameters ; ! end subroutine set_parameters","tags":"","loc":"proc\\set_parameters.html"},{"title":"evaluate_2lsom – KohonenF08","text":"public  subroutine evaluate_2lsom(kohonen_map, input_data, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array real(kind=wp), optional, dimension(:) :: results A real array Calls proc~~evaluate_2lsom~~CallsGraph proc~evaluate_2lsom two_level_self_organizing_map%evaluate_2lsom none~get_prototype kohonen_prototype%get_prototype proc~evaluate_2lsom->none~get_prototype proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~evaluate_2lsom->proc~kohonen_pattern_accessor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ipattern1 integer, public :: ipattern2 integer, public :: current_cluster integer, public :: ic integer, public :: is integer, public :: pos integer, public, dimension(size(input_data)) :: indicator integer, public, dimension(size(input_data)) :: positions integer, public, dimension(kohonen_map%number_clusters,size(input_data)) :: sample_positions integer, public, dimension(kohonen_map%number_clusters) :: number_samples_cluster type( kohonen_pattern ), public :: current_pattern1 type( kohonen_pattern ), public :: current_pattern2 type( kohonen_prototype ), public :: current_prototype1 type( kohonen_prototype ), public :: current_prototype2 real(kind=wp), public, dimension(kohonen_map%number_variables1,kohonen_map%number_variables2) :: current_values1 real(kind=wp), public, dimension(kohonen_map%number_variables1,kohonen_map%number_variables2) :: current_values2 real(kind=wp), public :: current_dissimilarity real(kind=wp), public, dimension(size(input_data)) :: mean_dissimilarity_a real(kind=wp), public, dimension(size(input_data)) :: silhouette real(kind=wp), public, dimension(size(input_data)) :: min_b real(kind=wp), public, dimension(size(input_data)) :: W real(kind=wp), public, dimension(size(input_data)) :: B real(kind=wp), public, dimension(size(input_data),kohonen_map%number_clusters) :: mean_dissimilarity_b Source Code subroutine evaluate_2lsom ( kohonen_map , input_data , results ) !======================================================================================== !!   Subroutine to calculate some clustering statistics of a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array real ( kind = wp ), dimension (:), optional :: results !! A real array integer :: ipattern1 , ipattern2 , current_cluster , ic , is , pos integer , dimension ( size ( input_data )) :: indicator , positions integer , dimension ( kohonen_map % number_clusters , size ( input_data )) :: sample_positions integer , dimension ( kohonen_map % number_clusters ) :: number_samples_cluster type ( kohonen_pattern ) :: current_pattern1 , current_pattern2 type ( kohonen_prototype ) :: current_prototype1 , current_prototype2 real ( kind = wp ), dimension ( kohonen_map % number_variables1 , kohonen_map % number_variables2 ) :: & current_values1 , current_values2 real ( kind = wp ) :: current_dissimilarity real ( kind = wp ), dimension ( size ( input_data )) :: mean_dissimilarity_a , silhouette , min_b , W , B real ( kind = wp ), dimension ( size ( input_data ), kohonen_map % number_clusters ) :: mean_dissimilarity_b !  Silouette or whatever !  find samples in each cluster min_b = 1 0.0d8 ; B = 0.0_wp ; W = 0.0_wp ; do is = 1 , size ( input_data ) positions ( is ) = is ; enddo ! do ic = 1 , kohonen_map % number_clusters indicator = 0 ; pos = 0 ; where ( kohonen_map % cluster_samples . eq . ic ) indicator = 1 ; end where number_samples_cluster ( ic ) = sum ( indicator ); if ( number_samples_cluster ( ic ) . eq . 0 ) then write ( 6 , * ) 'WARNING: Empty cluster. No cluster evaluation is done' if ( present ( results )) then results = 0.0_wp ; endif return endif do ipattern1 = 1 , size ( indicator ) if ( indicator ( ipattern1 ) . eq . 1 ) then pos = pos + 1 ; sample_positions ( ic , pos ) = ipattern1 ; endif enddo enddo !ic ! do ipattern1 = 1 , size ( input_data ) current_cluster = kohonen_map % cluster_samples ( ipattern1 ); ! get current prototype current_pattern1 = input_data ( ipattern1 ); call current_pattern1 % get ( current_prototype1 ); call current_prototype1 % get_prototype ( current_values1 ); current_dissimilarity = 0.0_wp ; do ipattern2 = 1 , number_samples_cluster ( current_cluster ); if ( sample_positions ( current_cluster , ipattern2 ) . ne . ipattern1 ) then current_pattern2 = input_data ( ipattern2 ); call current_pattern2 % get ( current_prototype2 ); call current_prototype2 % get_prototype ( current_values2 ); !\t    if(kohonen_map%number_variables1 .eq. 1 .or. kohonen_map%number_variables2 .eq. 1 ) then current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); !            else !              current_dissimilarity=current_dissimilarity+sum(sum((current_values1-current_values2)**2)); !            endif endif enddo !ipattern2 mean_dissimilarity_a ( ipattern1 ) = current_dissimilarity / max ( 1.0 , real ( number_samples_cluster ( current_cluster ) - 1 )); W ( ipattern1 ) = current_dissimilarity ; ! do ic = 1 , kohonen_map % number_clusters current_dissimilarity = 0.0_wp ; if ( ic . ne . current_cluster ) then do ipattern2 = 1 , number_samples_cluster ( ic ); current_pattern2 = input_data ( ipattern2 ); call current_pattern2 % get ( current_prototype2 ); call current_prototype2 % get_prototype ( current_values2 ); !               if(kohonen_map%number_variables1 .eq. 1 .or. kohonen_map%number_variables2 .eq. 1 ) then current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); !               else !                 current_dissimilarity=current_dissimilarity+sum(sum((current_values1-current_values2)**2)); !               endif enddo !ipattern2 endif mean_dissimilarity_b ( ipattern1 , ic ) = current_dissimilarity / max ( 1.0 , real ( number_samples_cluster ( ic ) - 1 )); B ( ipattern1 ) = B ( ipattern1 ) + current_dissimilarity ; enddo !ic ! do ic = 1 , kohonen_map % number_clusters if ( ic . ne . current_cluster . and . mean_dissimilarity_b ( ipattern1 , ic ) . lt . min_b ( ipattern1 ) ) then min_b ( ipattern1 ) = mean_dissimilarity_b ( ipattern1 , ic ) endif enddo ! if ( mean_dissimilarity_a ( ipattern1 ) . lt . min_b ( ipattern1 )) then silhouette ( ipattern1 ) = 1.0_wp - ( mean_dissimilarity_a ( ipattern1 ) / min_b ( ipattern1 )); else silhouette ( ipattern1 ) = ( min_b ( ipattern1 ) / mean_dissimilarity_a ( ipattern1 )) - 1.0_wp ; endif !write(6,*) ipattern1,mean_dissimilarity_a(ipattern1),min_b(ipattern1),silhouette(ipattern1) !(mean_dissimilarity_b(ipattern1,ic),ic=1,3); enddo !ipattern1 write ( 6 , * ) '' write ( 6 , * ) 'CH= ' ,( sum ( B ) / dble ( kohonen_map % number_clusters - 1 ))& / ( sum ( W ) / ( dble ( size ( input_data ) - kohonen_map % number_clusters ))); !,sum(B),sum(W), write ( 6 , * ) 'Silhouette= ' , sum ( silhouette ) / real ( size ( silhouette )) write ( 6 , * ) '' ! if ( present ( results )) then results ( 1 ) = sum ( B ); results ( 2 ) = sum ( W ); results ( 3 ) = sum ( silhouette ) / real ( size ( silhouette )); endif ! end subroutine evaluate_2lsom","tags":"","loc":"proc\\evaluate_2lsom.html"},{"title":"calculate_sum2_clusters_grid – KohonenF08","text":"public  subroutine calculate_sum2_clusters_grid(kohonen_map, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), optional, dimension(:) :: results A real array Calls proc~~calculate_sum2_clusters_grid~~CallsGraph proc~calculate_sum2_clusters_grid two_level_self_organizing_map%calculate_sum2_clusters_grid none~get_prototype kohonen_prototype%get_prototype proc~calculate_sum2_clusters_grid->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_sum2_clusters_grid~~CalledByGraph proc~calculate_sum2_clusters_grid two_level_self_organizing_map%calculate_sum2_clusters_grid proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~calculate_sum2_clusters_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 integer, public :: ic integer, public :: current_cluster integer, public :: j integer, public :: ipos integer, public :: pos integer, public :: isample integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: cix integer, public :: ciy integer, public :: ciz integer, public :: current_pos integer, public :: sample_pos real(kind=wp), public, dimension(kohonen_map%number_variables1, kohonen_map%number_variables2) :: mean_unit real(kind=wp), public, dimension(kohonen_map%number_clusters) :: W real(kind=wp), public, dimension(kohonen_map%number_clusters) :: B real(kind=wp), public :: current_dissimilarity real(kind=wp), public, dimension(kohonen_map%number_variables1* kohonen_map%number_variables2,1) :: current_values1 real(kind=wp), public, dimension(kohonen_map%number_variables1* kohonen_map%number_variables2,1) :: current_values2 type( kohonen_prototype ), public :: current_prototype1 type( kohonen_prototype ), public :: current_prototype2 integer, public, dimension(kohonen_map%number_nodes) :: indicator integer, public, dimension(kohonen_map%number_clusters) :: number_samples_cluster integer, public, dimension(kohonen_map%number_nodes) :: positions integer, public, dimension(kohonen_map%number_clusters,kohonen_map%number_nodes) :: sample_positions real(kind=wp), public, dimension(kohonen_map%number_nodes) :: mean_dissimilarity_a real(kind=wp), public, dimension(kohonen_map%number_nodes) :: min_b real(kind=wp), public, dimension(kohonen_map%number_nodes) :: silhouette real(kind=wp), public, dimension(kohonen_map%number_nodes,kohonen_map%number_clusters) :: mean_dissimilarity_b Source Code subroutine calculate_sum2_clusters_grid ( kohonen_map , results ) !======================================================================================== !! Subroutine to calculate some clustering statistics of a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:), optional :: results !! A real array integer :: ix1 , iy1 , iz1 , ic , current_cluster , j , ipos , pos , isample integer :: nx , ny , nz , cix , ciy , ciz , current_pos , sample_pos real ( kind = wp ), dimension ( kohonen_map % number_variables1 ,& kohonen_map % number_variables2 ) :: mean_unit real ( kind = wp ), dimension ( kohonen_map % number_clusters ) :: W , B real ( kind = wp ) :: current_dissimilarity real ( kind = wp ), dimension ( kohonen_map % number_variables1 * & kohonen_map % number_variables2 , 1 ) :: current_values1 , current_values2 type ( kohonen_prototype ) :: current_prototype1 , current_prototype2 integer , dimension ( kohonen_map % number_nodes ) :: indicator integer , dimension ( kohonen_map % number_clusters ) :: number_samples_cluster integer , dimension ( kohonen_map % number_nodes ) :: positions integer , dimension ( kohonen_map % number_clusters , kohonen_map % number_nodes ) :: sample_positions real ( kind = wp ), dimension ( kohonen_map % number_nodes ) :: mean_dissimilarity_a , min_b , silhouette real ( kind = wp ), dimension ( kohonen_map % number_nodes , kohonen_map % number_clusters ) :: mean_dissimilarity_b ! positions ( 1 : kohonen_map % number_nodes ) = ( / ( ipos , ipos = 1 , kohonen_map % number_nodes ) / ) ! nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; !  find samples in each cluster min_b = 1 0.0d8 ; ! B = 0.0_wp ; W = 0.0_wp ; mean_unit = 0.0_wp ! do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); current_cluster = kohonen_map % grid_cluster ( ix1 , iy1 , iz1 ); current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); call current_prototype1 % get_prototype ( current_values1 ); current_prototype2 = kohonen_map % cluster_layer ( current_cluster ); call current_prototype2 % get_prototype ( current_values2 ) W ( current_cluster ) = W ( current_cluster ) + sum (( current_values1 - current_values2 ) ** 2 ); mean_unit = mean_unit + current_values1 ; enddo !ix enddo !iy enddo !iz mean_unit = mean_unit / dble ( nx * ny * nz ); ! do ic = 1 , kohonen_map % number_clusters current_prototype1 = kohonen_map % cluster_layer ( ic ); call current_prototype1 % get_prototype ( current_values1 ); B ( ic ) = B ( ic ) + sum (( current_values1 - mean_unit ) ** 2 ); enddo !ic ! if ( present ( results )) then results ( 1 ) = sum ( W ); results ( 2 ) = sum ( B ); !  else !     write(6,*) 'Number clusters,W,B= ',kohonen_map%number_clusters,sum(W),sum(B) endif ! ! Silhouette for grid layer ! do ic = 1 , kohonen_map % number_clusters indicator = 0 ; where ( kohonen_map % cluster_cells_index (:, 4 ) == ic ) indicator = 1 ; end where number_samples_cluster ( ic ) = sum ( indicator ); pos = 0 ; do isample = 1 , size ( indicator ) if ( indicator ( isample ) . eq . 1 ) then pos = pos + 1 ; sample_positions ( ic , pos ) = isample ; endif enddo !write(6,*) (sample_positions(ic,isample),isample=1,number_samples_cluster(ic)); enddo ! current_pos = 0 ; do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); current_pos = current_pos + 1 ; current_cluster = kohonen_map % grid_cluster ( ix1 , iy1 , iz1 ); current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); call current_prototype1 % get_prototype ( current_values1 ); current_dissimilarity = 0.0_wp ; do ic = 1 , number_samples_cluster ( current_cluster ); if ( sample_positions ( current_cluster , ic ) . ne . current_pos ) then sample_pos = sample_positions ( current_cluster , ic ); cix = kohonen_map % cluster_cells_index ( sample_pos , 1 ); ciy = kohonen_map % cluster_cells_index ( sample_pos , 2 ); ciz = kohonen_map % cluster_cells_index ( sample_pos , 3 ); current_prototype2 = kohonen_map % grid ( cix , ciy , ciz ); call current_prototype2 % get_prototype ( current_values2 ); current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); endif enddo mean_dissimilarity_a ( current_pos ) = current_dissimilarity / dble ( number_samples_cluster ( current_cluster )); ! do ic = 1 , kohonen_map % number_clusters if ( ic /= current_cluster ) then current_dissimilarity = 0.0_wp ; do isample = 1 , number_samples_cluster ( ic ); sample_pos = sample_positions ( ic , isample ); cix = kohonen_map % cluster_cells_index ( sample_pos , 1 ); ciy = kohonen_map % cluster_cells_index ( sample_pos , 2 ); ciz = kohonen_map % cluster_cells_index ( sample_pos , 3 ); current_prototype2 = kohonen_map % grid ( cix , ciy , ciz ); call current_prototype2 % get_prototype ( current_values2 ); current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); enddo !isample mean_dissimilarity_b ( current_pos , ic ) = current_dissimilarity / dble ( number_samples_cluster ( ic )); endif enddo !ic ! do ic = 1 , kohonen_map % number_clusters if ( ic . ne . current_cluster . and . mean_dissimilarity_b ( current_pos , ic ) . lt . min_b ( current_pos ) ) then min_b ( current_pos ) = mean_dissimilarity_b ( current_pos , ic ) endif enddo ! if ( mean_dissimilarity_a ( current_pos ) . lt . min_b ( current_pos )) then silhouette ( current_pos ) = 1.0_wp - ( mean_dissimilarity_a ( current_pos ) / min_b ( current_pos )); else silhouette ( current_pos ) = ( min_b ( current_pos ) / mean_dissimilarity_a ( current_pos )) - 1.0_wp ; endif ! enddo !ix1 enddo !iy1 enddo !iz1 write ( * , * ) 'Number clusters,W,B,sil= ' , kohonen_map % number_clusters , sum ( W ), sum ( B ), sum ( silhouette ) / dble ( kohonen_map % number_nodes ); if ( present ( results )) then results ( 3 ) = sum ( silhouette ) / dble ( kohonen_map % number_nodes ); endif !  write(*,*) 'b',min_b !mean_dissimilarity_b !  write(*,*) 'a',mean_dissimilarity_a !  write(*,*) 'a,b',sum(mean_dissimilarity_a)/dble(kohonen_map%number_clusters),& !                   sum(mean_dissimilarity_b)/dble(kohonen_map%number_clusters) ! ! end subroutine calculate_sum2_clusters_grid","tags":"","loc":"proc\\calculate_sum2_clusters_grid.html"},{"title":"calculate_cluster_measures – KohonenF08","text":"public  subroutine calculate_cluster_measures(kohonen_map, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), dimension(:,:,:) :: results A real array Variables Type Visibility Attributes Name Initial logical, public :: testop Source Code subroutine calculate_cluster_measures ( kohonen_map , results ) !======================================================================================== !! Subroutine to calculate some clustering statistics of a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:,:,:) :: results !! A real array logical :: testop ! inquire ( unit = kohonen_map % parameters ( 1 )% iout , opened = testop ); if (. not . testop ) then write ( 6 , * ) 'ERROR: the output file is not opened' stop endif ! end subroutine calculate_cluster_measures","tags":"","loc":"proc\\calculate_cluster_measures.html"},{"title":"read_som_layer – KohonenF08","text":"public  subroutine read_som_layer(kohonen_map, som_fl, layer_type) Subroutine to read the prototypes of the first/seconf layer of a two level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object character(len=*) :: som_fl A character variable character(len=*) :: layer_type A character variable Calls proc~~read_som_layer~~CallsGraph proc~read_som_layer two_level_self_organizing_map%read_som_layer none~create kohonen_prototype%create proc~read_som_layer->none~create none~destroy kohonen_prototype%destroy proc~read_som_layer->none~destroy none~set_prototype kohonen_prototype%set_prototype proc~read_som_layer->none~set_prototype proc~calculate_coordinates~2 two_level_self_organizing_map%calculate_coordinates proc~read_som_layer->proc~calculate_coordinates~2 proc~calculate_distance_matrix~2 two_level_self_organizing_map%calculate_distance_matrix proc~read_som_layer->proc~calculate_distance_matrix~2 proc~position2index~2 position2index proc~read_som_layer->proc~position2index~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: testfl logical, public :: toroidal_grid integer, public :: isom integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nvar1 integer, public :: nvar2 integer, public :: ierr integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ivar integer, public :: current_index character(len=40), public :: current_line character(len=40), public :: node_type real(kind=wp), public, allocatable :: Prototype_value (:,:) Source Code subroutine read_som_layer ( kohonen_map , som_fl , layer_type ) !======================================================================================== !! Subroutine to read the prototypes of the first/seconf layer of a two level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object character ( len =* ) :: som_fl , layer_type !! A character variable logical :: testfl , toroidal_grid integer :: isom , nx , ny , nz , nvar1 , nvar2 , ierr , ix , iy , iz , ivar , current_index character ( len = 40 ) :: current_line , node_type real ( kind = wp ), allocatable :: Prototype_value (:,:) ! isom = 20 ; inquire ( file = trim ( som_fl ), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the som file does not exist' stop endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...' write ( * , * ) open ( isom , file = trim ( som_fl ), status = 'unknown' , action = 'read' , access = 'sequential' ); read ( isom , '(A)' ) current_line write ( * , * ) trim ( current_line ) read ( isom , '(A17,1X,3I6)' ) current_line , nx , ny , nz write ( * , * ) current_line , nx , ny , nz read ( isom , '(A21,1X,2I6)' ) current_line , nvar1 , nvar2 write ( * , * ) current_line , nvar1 , nvar2 kohonen_map % number_variables1 = nvar1 ; kohonen_map % number_variables2 = nvar2 ; kohonen_map % number_variables = nvar1 * nvar2 ; read ( isom , '(A25,1X,A11,1X,L4)' ) current_line , node_type , toroidal_grid write ( * , * ) current_line , node_type , toroidal_grid allocate ( Prototype_value ( nvar1 * nvar2 , 1 ), stat = ierr ); ! select case ( trim ( layer_type )) case ( 'grid' ) if ( allocated ( kohonen_map % grid )) then do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); if ( allocated ( kohonen_map % cells_distances )) then deallocate ( kohonen_map % cells_distances ); endif allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); if ( allocated ( kohonen_map % cluster_cells_index )) then deallocate ( kohonen_map % cluster_cells_index ); endif allocate ( kohonen_map % cluster_cells_index ( nx * ny * nz , 4 ), stat = ierr ); if ( allocated ( kohonen_map % grid_cluster )) then deallocate ( kohonen_map % grid_cluster ); endif allocate ( kohonen_map % grid_cluster ( nx , ny , nz ), stat = ierr ); case ( 'cluster' ) if ( allocated ( kohonen_map % cluster_layer ) ) then do iz = 1 , size ( kohonen_map % cluster_layer , 1 ) call kohonen_map % cluster_layer ( ix )% destroy (); enddo deallocate ( kohonen_map % cluster_layer ); endif allocate ( kohonen_map % cluster_layer ( nx ), stat = ierr ); end select do iz = 1 , nz read ( isom , '(A)' ) current_line write ( * , * ) 'Reading ' , trim ( current_line ) do iy = 1 , ny do ix = 1 , nx read ( isom , '(A)' ) current_line !            write(*,*) current_line read ( isom , '(A)' ) current_line !            write(*,*) current_line read ( isom , * ) ( Prototype_value ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ) !write(*,*) ix,iy,(Prototype_value(ivar,1),ivar=1,nvar1*nvar2) select case ( trim ( layer_type )) case ( 'grid' ) call kohonen_map % grid ( ix , iy , iz )% create ( Prototype_value ); !call kohonen_map%grid(ix,iy,iz)%print() current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , kohonen_map % coordinates , node_type ); case ( 'cluster' ) call kohonen_map % cluster_layer ( ix )% set_prototype ( Prototype_value ); end select enddo enddo enddo close ( isom ) ! if ( trim ( layer_type ) . eq . 'grid' ) then call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances , node_type , toroidal_grid ); endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...finished' write ( * , * ) ! end subroutine read_som_layer","tags":"","loc":"proc\\read_som_layer.html"},{"title":"query_2lsom – KohonenF08","text":"public  subroutine query_2lsom(kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_pattern A real array integer, allocatable :: sample_index (:) An integer array Calls proc~~query_2lsom~~CallsGraph proc~query_2lsom two_level_self_organizing_map%query_2lsom none~get_prototype kohonen_prototype%get_prototype proc~query_2lsom->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: ivar1 integer, public :: ivar2 integer, public :: nvar1 integer, public :: nvar2 integer, public :: number_patterns integer, public :: ipat integer, public :: ierr integer, public :: number_selected integer, public :: i integer, public :: pos integer, public :: ic integer, public :: number_samples real(kind=wp), public, dimension(kohonen_map%parameters(1)%number_variables1, kohonen_map%parameters(1)%number_variables2) :: current_values real(kind=wp), public, dimension(kohonen_map%parameters(1)%number_variables1, kohonen_map%parameters(1)%number_variables2) :: centers real(kind=wp), public :: dist real(kind=wp), public :: dist_min integer, public, dimension(size(kohonen_map%cells_index,1)) :: position integer, public, dimension(size(kohonen_map%cells_index,1)) :: real_position Source Code subroutine query_2lsom ( kohonen_map , input_pattern , sample_index ) !,output_patterns) !======================================================================================== !!  Function to find the input samples associated with specific vector class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_pattern !! A real array integer , allocatable :: sample_index (:) !! An integer array integer :: ix , iy , iz , ihit , jhit , khit , ivar1 , ivar2 , nvar1 , nvar2 , number_patterns , ipat , ierr integer :: number_selected , i , pos , ic , number_samples real ( kind = wp ), dimension ( kohonen_map % parameters ( 1 )% number_variables1 ,& kohonen_map % parameters ( 1 )% number_variables2 ) :: current_values , centers real ( kind = wp ) :: dist , dist_min integer , dimension ( size ( kohonen_map % cells_index , 1 )) :: position , real_position ! do ic = 1 , size ( kohonen_map % cluster_layer ); !write(unit1,*) 'Cluster= ',ic !call kohonen_map%cluster_layer(ic)%print(unit1); call kohonen_map % cluster_layer ( ic )% get_prototype ( centers ); !centers1(:,ic)=centers(:) dist_min = 1.0d5 ; dist = 0.0_wp ; do ix = 1 , size ( centers , 1 ); do iy = 1 , size ( centers , 2 ); if ( input_pattern ( ix , iy ) > 0.0_wp ) then dist = dist + ( input_pattern ( ix , iy ) - centers ( ix , iy )) ** 2 endif enddo enddo if ( dist < dist_min ) then dist_min = dist ; ihit = ic ; endif number_samples = kohonen_map % number_cluster_samples ( ihit ); if ( number_samples . gt . 0 ) then allocate ( sample_index ( number_samples ), stat = ierr ); sample_index = kohonen_map % index_cluster_samples ( ihit , 1 : number_samples ); else write ( * , * ) 'WARNING: Empty query' return endif enddo !ic ! end subroutine query_2lsom","tags":"","loc":"proc\\query_2lsom.html"},{"title":"get_cluster_samples – KohonenF08","text":"public  subroutine get_cluster_samples(kohonen_map, clusters) Accessor to cluster results obtained using a two-level self_organized_map Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer, intent(inout), dimension(:) :: clusters An integer array Source Code subroutine get_cluster_samples ( kohonen_map , clusters ) !======================================================================================== !! Accessor to cluster results obtained using a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer , dimension (:), intent ( inout ) :: clusters !! An integer array write ( * , * ) 'size_cluster= ' , size ( clusters ) if ( size ( clusters ) . eq . size ( kohonen_map % cluster_samples )) then clusters = kohonen_map % cluster_samples ; endif ! end subroutine get_cluster_samples","tags":"","loc":"proc\\get_cluster_samples.html"},{"title":"index2position – KohonenF08","text":"public  subroutine index2position(index_, nx, ny, nz, cx, cy, cz) Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index Arguments Type Intent Optional Attributes Name integer, intent(in) :: index_ Integer variables, index_,nx,ny,nz integer, intent(in) :: nx Integer variables, index_,nx,ny,nz integer, intent(in) :: ny Integer variables, index_,nx,ny,nz integer, intent(in) :: nz Integer variables, index_,nx,ny,nz integer, intent(inout) :: cx Integer variables cx,cy,cz integer, intent(inout) :: cy Integer variables cx,cy,cz integer, intent(inout) :: cz Integer variables cx,cy,cz Called by proc~~index2position~2~~CalledByGraph proc~index2position~2 index2position proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_grid_layer->proc~index2position~2 proc~update_weights~2 two_level_self_organizing_map%update_weights proc~update_weights~2->proc~index2position~2 proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~train_grid_layer proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine index2position ( index_ , nx , ny , nz , cx , cy , cz ) !======================================================================================== !!  Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index integer , intent ( in ) :: index_ , nx , ny , nz !! Integer variables, index_,nx,ny,nz integer , intent ( inout ) :: cx , cy , cz !! Integer variables cx,cy,cz !  write(*,*) index_,nx,ny,1+int((index_-1)/(nx*ny)) cz = min ( 1 + int (( index_ - 1 ) / ( nx * ny )), nz ); cy = min ( 1 + int (( index_ - 1 - ( cz - 1 ) * nx * ny ) / nx ), ny ); cx = min ( index_ - ( cz - 1 ) * nx * ny - ( cy - 1 ) * nx , nx ); ! end subroutine index2position","tags":"","loc":"proc\\index2position~2.html"},{"title":"calculate_distance_matrix – KohonenF08","text":"public  subroutine calculate_distance_matrix(coordinates, distance_matrix, grid_type, toroidal) Subroutine to calculate the distance between the units inside a kohonen layer Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: coordinates A real array real(kind=wp), intent(inout), dimension(:,:) :: distance_matrix A real array character(len=*) :: grid_type A character varaible logical :: toroidal A logical variableS Called by proc~~calculate_distance_matrix~2~~CalledByGraph proc~calculate_distance_matrix~2 two_level_self_organizing_map%calculate_distance_matrix proc~create_2lsom two_level_self_organizing_map%create_2lsom proc~create_2lsom->proc~calculate_distance_matrix~2 proc~read_som_layer two_level_self_organizing_map%read_som_layer proc~read_som_layer->proc~calculate_distance_matrix~2 proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~create_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=wp), public :: maxdiffx real(kind=wp), public :: maxdiffy real(kind=wp), public :: maxdiffz real(kind=wp), public, dimension(3) :: diffs Source Code subroutine calculate_distance_matrix ( coordinates , distance_matrix , grid_type , toroidal ) !======================================================================================== !! Subroutine to calculate the distance between the units inside a kohonen layer real ( kind = wp ), dimension (:,:), intent ( inout ) :: coordinates !! A real array real ( kind = wp ), dimension (:,:), intent ( inout ) :: distance_matrix !! A real array character ( len =* ) :: grid_type !! A character varaible logical :: toroidal !! A logical variableS integer :: i , j real ( kind = wp ) :: maxdiffx , maxdiffy , maxdiffz real ( kind = wp ), dimension ( 3 ) :: diffs ! maxdiffx = maxval ( coordinates (:, 1 )) / 2.0_wp ; maxdiffy = maxval ( coordinates (:, 2 )) / 2.0_wp ; maxdiffz = maxval ( coordinates (:, 3 )) / 2.0_wp ; ! if ( toroidal ) then do i = 1 , size ( distance_matrix , 1 ) do j = i + 1 , size ( distance_matrix , 2 ) diffs = abs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); if ( diffs ( 1 ) > maxdiffx ) diffs ( 1 ) = 2.0_wp * maxdiffx - diffs ( 1 ); if ( diffs ( 2 ) > maxdiffy ) diffs ( 2 ) = 2.0_wp * maxdiffy - diffs ( 2 ); !if (diffs(3) > maxdiffy) diffs(3)=2*maxdiffz - diffs(3); if ( trim ( grid_type ) . eq . \"hexagonal\" ) then distance_matrix ( i , j ) = sum ( diffs ** 2 ); elseif ( trim ( grid_type ) . eq . \"rectangular\" ) then !rectangular distance_matrix ( i , j ) = maxval ( diffs ); endif enddo enddo else do i = 1 , size ( distance_matrix , 1 ) do j = i + 1 , size ( distance_matrix , 2 ) diffs = abs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); distance_matrix ( i , j ) = dsqrt ( sum ( diffs ** 2 )); enddo enddo endif ! distance_matrix = distance_matrix + transpose ( distance_matrix ); !write(*,'(49f10.4)') distance_matrix(1,:) ! end subroutine calculate_distance_matrix","tags":"","loc":"proc\\calculate_distance_matrix~2.html"},{"title":"calculate_coordinates – KohonenF08","text":"public  subroutine calculate_coordinates(current_index, ix, iy, iz, nx, ny, nz, coordinates, node_type) Subroutine to calculate the coordinates of the units inside a kohonen layer Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_index Integer variables integer, intent(in) :: ix Integer variables integer, intent(in) :: iy Integer variables integer, intent(in) :: iz Integer variables integer, intent(in) :: nx Integer variables integer, intent(in) :: ny Integer variables integer, intent(in) :: nz Integer variables real(kind=wp), intent(out), dimension(:,:) :: coordinates Real array character(len=*), intent(in) :: node_type Character variable Called by proc~~calculate_coordinates~2~~CalledByGraph proc~calculate_coordinates~2 two_level_self_organizing_map%calculate_coordinates proc~read_som_layer two_level_self_organizing_map%read_som_layer proc~read_som_layer->proc~calculate_coordinates~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , coordinates , node_type ) !======================================================================================== !! Subroutine to calculate the coordinates of the units inside a kohonen layer integer , intent ( in ) :: current_index , ix , iy , iz , nx , ny , nz !! Integer variables real ( kind = wp ), dimension (:,:), intent ( out ) :: coordinates !! Real array character ( len =* ), intent ( in ) :: node_type !! Character variable coordinates ( current_index , 1 ) = dble ( ix ); coordinates ( current_index , 2 ) = dble ( iy ); coordinates ( current_index , 3 ) = dble ( iz ); if ( trim ( node_type ) . eq . 'hexagonal' ) then coordinates ( current_index , 1 ) = coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( coordinates ( current_index , 2 ), 2.0_wp )); coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2._wp ) * coordinates ( current_index , 2 ); endif ! end subroutine calculate_coordinates","tags":"","loc":"proc\\calculate_coordinates~2.html"},{"title":"find_best_match_unit – KohonenF08","text":"public  subroutine find_best_match_unit(kohonen_map, current_prototype, ihit, jhit, khit, dist_hit) Subroutine to calculate the best match unit Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_prototype ), intent(inout) :: current_prototype A kohonen_prototype object integer, intent(out) :: ihit Integer variables integer, intent(out) :: jhit Integer variables integer, intent(out) :: khit Integer variables real(kind=wp), intent(out) :: dist_hit A real variable Calls proc~~find_best_match_unit~2~~CallsGraph proc~find_best_match_unit~2 two_level_self_organizing_map%find_best_match_unit float float proc~find_best_match_unit~2->float none~distance kohonen_prototype%distance proc~find_best_match_unit~2->none~distance calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: debug_option integer, public :: idbg integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: number_variables real(kind=wp), public :: dist Source Code subroutine find_best_match_unit ( kohonen_map , current_prototype , ihit , jhit , khit , dist_hit ) !======================================================================================== !!    Subroutine to calculate the best match unit class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_prototype ), intent ( inout ) :: current_prototype !! A `kohonen_prototype` object integer , intent ( out ) :: ihit , jhit , khit !! Integer variables real ( kind = wp ), intent ( out ) :: dist_hit !! A real variable integer :: debug_option , idbg , ix , iy , iz , number_variables real ( kind = wp ) :: dist ! idbg = kohonen_map % parameters ( 1 )% idbg ; debug_option = kohonen_map % parameters ( 1 )% debug_level ; number_variables = kohonen_map % parameters ( 1 )% number_variables1 * kohonen_map % parameters ( 1 )% number_variables2 ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e6 ; do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); if ( debug_option . gt . 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ) write ( idbg , * ) ix , iy , iz , dist endif dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix jhit = iy khit = iz !write(*,*)' fbmu= ',ihit,jhit,khit,dist endif enddo !ix enddo !iy enddo !iz ! return ! end subroutine find_best_match_unit","tags":"","loc":"proc\\find_best_match_unit~2.html"},{"title":"update_weights – KohonenF08","text":"public  subroutine update_weights(kohonen_map, current_values, ihit, jhit, khit, maximum_radius, iteration) Subroutine to update the weights Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: current_values A real array integer, intent(inout) :: ihit Integer variables integer, intent(inout) :: jhit Integer variables integer, intent(inout) :: khit Integer variables real(kind=wp), intent(inout) :: maximum_radius A real variable with the maximum radius integer, intent(inout) :: iteration Integer variables Calls proc~~update_weights~2~~CallsGraph proc~update_weights~2 two_level_self_organizing_map%update_weights none~get_prototype kohonen_prototype%get_prototype proc~update_weights~2->none~get_prototype none~set_prototype kohonen_prototype%set_prototype proc~update_weights~2->none~set_prototype proc~index2position~2 index2position proc~update_weights~2->proc~index2position~2 proc~position2index~2 position2index proc~update_weights~2->proc~position2index~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: prototype_values real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: winner_values real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: term1 real(kind=wp), public, dimension(size(current_values,1),size(current_values,2)) :: term2 integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: debug_option integer, public :: ic integer, public :: current_pos integer, public :: ineigh integer, public :: jneigh integer, public :: kneigh integer, public :: idbg real(kind=wp), public :: time_factor real(kind=wp), public :: current_radius real(kind=wp), public :: alpha real(kind=wp), public :: sigma2 real(kind=wp), public :: h_neighborhood real(kind=wp), public :: real_distance real(kind=wp), public :: term3 real(kind=wp), public :: distance_ratio real(kind=wp), public :: geometric_distance2 real(kind=wp), public :: eps real(kind=wp), public :: current_distance real(kind=wp), public :: lambda Source Code subroutine update_weights ( kohonen_map , current_values , ihit , jhit , khit ,& maximum_radius , iteration ) !======================================================================================== !!    Subroutine to update the weights class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: current_values !! A real array integer , intent ( inout ) :: ihit , jhit , khit , iteration !! Integer variables real ( kind = wp ), intent ( inout ) :: maximum_radius !! A real variable with the maximum radius real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: prototype_values real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: winner_values , term1 , term2 integer :: nx , ny , nz , debug_option , ic , current_pos , ineigh , jneigh , kneigh , idbg real ( kind = wp ) :: time_factor , current_radius , alpha , sigma2 , h_neighborhood , real_distance , term3 real ( kind = wp ) :: distance_ratio , geometric_distance2 , eps , current_distance , lambda ! nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; debug_option = kohonen_map % parameters ( 1 )% debug_level ; idbg = kohonen_map % parameters ( 1 )% idbg ; lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); time_factor = 1.0_wp - dble ( iteration ) / & dble ( kohonen_map % parameters ( 1 )% number_epochs * kohonen_map % parameters ( 1 )% number_patterns ); !current_radius = max(maximum_radius*real(1001-iteration)/1000.0 + 0.9999999999,4.0_wp); current_radius = max ( maximum_radius * time_factor , 4.0_wp ); !alpha = max(kohonen_map%parameters%learning_rate*(1.0_wp-real(iteration)/1000.0),0.01_wp); alpha = max ( kohonen_map % parameters ( 1 )% learning_rate * time_factor , 0.01_wp ); sigma2 = current_radius ** 2 ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance . lt . current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters ( 1 )% neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * exp ( - 0.5 * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option . gt . 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters ( 1 )% som_type )) case ( 'normal_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ) case ( 'visom' ) !write(*,*) trim(kohonen_map%parameters%som_type) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh . eq . ihit ) . and . ( jneigh . eq . jhit ) . and . ( kneigh . eq . khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); eps = max ( 1.0_wp * time_factor , 0.0_wp ); term3 = 1.0_wp ; !((1.0_wp-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * ( distance_ratio - 1.0_wp ) * term3 ); endif !write(*,*) iteration,dsqrt(real_distance),dsqrt(geometric_distance2)*lambda,distance_ratio call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo !ic end subroutine update_weights","tags":"","loc":"proc\\update_weights~2.html"},{"title":"calculate_distance_between_prototypes – KohonenF08","text":"public  subroutine calculate_distance_between_prototypes(kohonen_map) Subroutine to calculate distance between prototypes Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object Calls proc~~calculate_distance_between_prototypes~2~~CallsGraph proc~calculate_distance_between_prototypes~2 two_level_self_organizing_map%calculate_distance_between_prototypes proc~position2index~2 position2index proc~calculate_distance_between_prototypes~2->proc~position2index~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_distance_between_prototypes~2~~CalledByGraph proc~calculate_distance_between_prototypes~2 two_level_self_organizing_map%calculate_distance_between_prototypes proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_grid_layer->proc~calculate_distance_between_prototypes~2 proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~train_grid_layer proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ix1 integer, public :: iy1 integer, public :: iz1 integer, public :: pos integer, public :: pos1 type( kohonen_prototype ), public :: current_prototype type( kohonen_prototype ), public :: current_prototype1 logical, public :: testop A logical variable Source Code subroutine calculate_distance_between_prototypes ( kohonen_map ) !======================================================================================== !!    Subroutine to calculate distance between prototypes class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: nx , ny , ix , iy , iz , ix1 , iy1 , iz1 , pos , pos1 type ( kohonen_prototype ) :: current_prototype , current_prototype1 logical :: testop !! A logical variable nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_prototype = kohonen_map % grid ( ix , iy , iz ); pos = position2index ( ix , iy , iz , nx , ny ); do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); pos1 = position2index ( ix1 , iy1 , iz1 , nx , ny ) current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); kohonen_map % distance ( pos , pos1 ) = current_prototype1 % distance ( current_prototype ,& kohonen_map % distance_function ); enddo !ix1 enddo !iy1 enddo !iz1 enddo !ix enddo !iy enddo !iz ! do ix = 1 , size ( kohonen_map % distance , 1 ) write ( kohonen_map % parameters ( 1 )% idist , * ) ( kohonen_map % distance ( ix , iy ), iy = 1 , size ( kohonen_map % distance , 2 )); enddo !ix ! end subroutine calculate_distance_between_prototypes","tags":"","loc":"proc\\calculate_distance_between_prototypes~2.html"},{"title":"calculate_u_matrix – KohonenF08","text":"public  subroutine calculate_u_matrix(kohonen_map) Subroutine to calculate  the u_matrix Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object Calls proc~~calculate_u_matrix~2~~CallsGraph proc~calculate_u_matrix~2 two_level_self_organizing_map%calculate_u_matrix none~distance kohonen_prototype%distance proc~calculate_u_matrix~2->none~distance calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_u_matrix~2~~CalledByGraph proc~calculate_u_matrix~2 two_level_self_organizing_map%calculate_u_matrix proc~train_grid_layer two_level_self_organizing_map%train_grid_layer proc~train_grid_layer->proc~calculate_u_matrix~2 proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~train_grid_layer proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), public :: type_ integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: nt integer, public :: ierr integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: cx integer, public :: cy integer, public :: cz integer, public :: nxu integer, public :: nyu integer, public :: nzu real(kind=wp), public :: dist real(kind=wp), public :: u_temp logical, public :: testop Source Code subroutine calculate_u_matrix ( kohonen_map ) !======================================================================================== !!    Subroutine to calculate  the u_matrix class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object character ( len = 50 ) :: type_ integer :: nx , ny , nz , nt , ierr , ix , iy , iz , cx , cy , cz , nxu , nyu , nzu real ( kind = wp ) :: dist , u_temp logical :: testop ! type_ = kohonen_map % parameters ( 1 )% node_type ; nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; ! nxu = size ( kohonen_map % u_matrix , 1 ); nyu = size ( kohonen_map % u_matrix , 2 ); nzu = size ( kohonen_map % u_matrix , 3 ); ! select case ( trim ( type_ )) ! case ( 'rectangular' ) ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); ! horizontal if ( ix < nx ) then cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif !vertical if ( iy < ny ) then cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; endif ! if ( iz < nz ) then cx = ix ; cy = iy ; cz = iz + 1 ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! Diagonal if ( ix < nx . and . iy < ny ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = dist + kohonen_map % grid ( ix , cy , iz )% distance ( kohonen_map % grid ( cx , iy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; endif enddo enddo enddo ! do iz = 1 , size ( kohonen_map % u_matrix , 3 ), 2 do iy = 1 , size ( kohonen_map % u_matrix , 2 ), 2 do ix = 1 , size ( kohonen_map % u_matrix , 1 ), 2 u_temp = 0.0_wp ; if ( ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 ) . and . & iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == 1 . and . ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( iy == size ( kohonen_map % u_matrix , 2 ) . and . ix > 1 . and .& ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == 1 . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = 0.0_wp ; endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! case ( 'hexagonal' ) ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); if ( ix < nx ) then !horizontal cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! if ( iy < ny ) then !diagonals cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; if ( mod ( iy , 2 ) == 0 . and . ix < nx ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; elseif ( mod ( iy , 2 ) == 1 . and . ix > 1 ) then cx = ix - 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 2 , 2 * iy , 2 * iz - 1 ) = dist ; endif endif enddo enddo enddo ! do iz = 1 , nzu , 2 ; do iy = 1 , nyu , 2 ; do ix = 1 , nxu , 2 ; u_temp = 0.0_wp ; if ( ix > 1 . and . iy > 1 . and . ix < nxu . and . iy < nyu ) then !middle part of the map u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); endif nt = 6 ; elseif ( iy == 1 . and . ix > 1 . and . ix < nxu ) then ! upper edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == nyu . and . ix > 1 . and . ix < nxu ) then ! lower edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); endif nt = 4 ; elseif ( ix == 1 . and . iy > 1 . and . iy < nyu ) then ! left edge u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); nt = 5 ; endif elseif ( ix == nxu . and . iy > 1 . and . iy < nyu ) then ! right edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ); nt = 5 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; endif elseif ( ix == 1 . and . iy == 1 ) then ! top left corner u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == nxu . and . iy == 1 ) then ! top right corner u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == nyu ) then ! bottom left corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); nt = 3 ; endif ; elseif ( ix == nxu . and . iy == nyu ) then ! bottom right corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ); nt = 3 ; else u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; endif endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! end select ! inquire ( unit = kohonen_map % parameters ( 1 )% iumat , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % u_matrix , 3 ); write ( kohonen_map % parameters ( 1 )% iumat , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % u_matrix , 1 ); write ( kohonen_map % parameters ( 1 )% iumat , '(100f10.5)' ) ( kohonen_map % u_matrix ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % u_matrix , 2 )); enddo enddo endif ! end subroutine calculate_u_matrix","tags":"","loc":"proc\\calculate_u_matrix~2.html"},{"title":"assign_input_to_clusters – KohonenF08","text":"public  subroutine assign_input_to_clusters(kohonen_map, input_patterns) Subroutine to assign input to clusters Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_patterns A kohonen_pattern array Calls proc~~assign_input_to_clusters~~CallsGraph proc~assign_input_to_clusters two_level_self_organizing_map%assign_input_to_clusters none~distance kohonen_prototype%distance proc~assign_input_to_clusters->none~distance proc~kohonen_pattern_accessor kohonen_pattern%kohonen_pattern_accessor proc~assign_input_to_clusters->proc~kohonen_pattern_accessor calculate calculate none~distance->calculate none~get_prototype kohonen_prototype%get_prototype none~distance->none~get_prototype Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~assign_input_to_clusters~~CalledByGraph proc~assign_input_to_clusters two_level_self_organizing_map%assign_input_to_clusters proc~train_2lsom two_level_self_organizing_map%train_2lsom proc~train_2lsom->proc~assign_input_to_clusters proc~train_two_level_som train_two_level_som proc~train_two_level_som->proc~train_2lsom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( kohonen_prototype ), public :: current_prototype type( kohonen_prototype ), public :: current_prototype1 integer, public :: ipattern integer, public :: ic integer, public :: i_hit integer, public :: current_pos real(kind=wp), public :: dist_min real(kind=wp), public :: dist Source Code subroutine assign_input_to_clusters ( kohonen_map , input_patterns ) !======================================================================================== !!    Subroutine to assign input to clusters class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_patterns !! A `kohonen_pattern` array type ( kohonen_prototype ) :: current_prototype , current_prototype1 integer :: ipattern , ic , i_hit , current_pos real ( kind = wp ) :: dist_min , dist ! ! write(*,*) 'assign= ',size(input_patterns) do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns call input_patterns ( ipattern )% get ( current_prototype ); !    write(*,*) 'ipat= ',ipattern dist_min = 1.0d5 ; do ic = 1 , size ( kohonen_map % cluster_layer ) current_prototype1 = kohonen_map % cluster_layer ( ic ) dist = current_prototype1 % distance ( current_prototype , kohonen_map % distance_function ); if ( dist < dist_min ) then i_hit = ic ; dist_min = dist ; !         write(*,*) 'ic= ',ipattern,i_hit endif enddo kohonen_map % number_cluster_samples ( i_hit ) = kohonen_map % number_cluster_samples ( i_hit ) + 1 ; current_pos = kohonen_map % number_cluster_samples ( i_hit ); !    write(*,*)' ic,pos= ',ic,i_hit,current_pos,allocated(kohonen_map%number_cluster_samples),& !                         size(kohonen_map%number_cluster_samples) !    write(*,*) kohonen_map%number_cluster_samples kohonen_map % index_cluster_samples ( i_hit , current_pos ) = ipattern ; enddo !ipattern1 ! !  do ic=1,size(kohonen_map%cluster_layer) !     write(*,*) ic,kohonen_map%number_cluster_samples(ic),(kohonen_map%index_cluster_samples(ic,1:5)) !  enddo ! end subroutine assign_input_to_clusters","tags":"","loc":"proc\\assign_input_to_clusters.html"},{"title":"external_train_map – KohonenF08","text":"public  subroutine external_train_map(x, nvar, npat, som_type, nx1, ny1, nepoch1, alpha1, grid_type1, distance_type1, neigh_type1, toroidal1, nx2, nepoch2, alpha2, grid_type2, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_2lsom\") Uses iso_c_binding proc~~external_train_map~2~~UsesGraph proc~external_train_map~2 two_level_self_organizing_map%external_train_map iso_c_binding iso_c_binding proc~external_train_map~2->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutine to connect the two_level_self_organizing_map module to R o C\nUse iso_c_binding module Type Bound two_level_self_organizing_map Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real variables integer(kind=c_int), intent(in) :: nvar Integere variables integer(kind=c_int), intent(in) :: npat Integere variables integer(kind=c_int), intent(in) :: som_type Integere variables integer(kind=c_int), intent(in) :: nx1 Integere variables integer(kind=c_int), intent(in) :: ny1 Integere variables integer(kind=c_int), intent(in) :: nepoch1 Integere variables real(kind=c_double), intent(in) :: alpha1 Real variables integer(kind=c_int), intent(in) :: grid_type1 Integer variables integer(kind=c_int), intent(in) :: distance_type1 Integer variables integer(kind=c_int), intent(in) :: neigh_type1 Integer variables integer(kind=c_int), intent(in) :: toroidal1 Integere variables integer(kind=c_int), intent(in) :: nx2 Integer variables integer(kind=c_int), intent(in) :: nepoch2 Integer variables real(kind=c_double), intent(in) :: alpha2 Real variables integer(kind=c_int), intent(in) :: grid_type2 Integer variables real(kind=c_double), intent(out) :: prot (nx1*ny1,nvar) Real variables real(kind=c_double), intent(out) :: distortion (nepoch1) Real variables real(kind=c_double), intent(out) :: u_matrix (2*nx1-1,2*ny1-1) Real variables real(kind=c_double), intent(out) :: coords (nx1*ny1,3) Real variables integer(kind=c_int), intent(out) :: number_patterns (nx1,ny1) Integer variables integer(kind=c_int), intent(out) :: node_index (npat,3) Integer variables Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: version = 0.1_wp Subroutine Version character(len=*), public, parameter :: program_name = \"2lsom_train\" Subroutine name type( two_level_self_organizing_map ), public :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: parameters real(kind=wp), public, dimension(nvar,1) :: var integer, public :: i integer, public :: j integer, public :: k integer, public :: ierr integer, public :: pos integer, public :: ihit integer, public :: jhit integer, public :: khit integer, public :: nx1a integer, public :: ny1a type( kohonen_pattern ), public, allocatable :: input_patterns (:) real(kind=wp), public, dimension(nx1*ny1,nvar) :: prototypes real(kind=wp), public, dimension(nvar,1) :: temp Source Code subroutine external_train_map ( x , nvar , npat , som_type , nx1 , ny1 , nepoch1 , alpha1 , grid_type1 ,& distance_type1 , neigh_type1 , toroidal1 , nx2 , nepoch2 , alpha2 , grid_type2 ,& prot , distortion , u_matrix , coords , number_patterns ,& node_index ) bind ( C , name = \"train_2lsom\" ) !======================================================================================== !!    Subroutine to connect the two_level_self_organizing_map module to R o C use , intrinsic :: iso_c_binding , only : c_double , c_int , c_char !! Use iso_c_binding module real ( kind = wp ), parameter :: version = 0.1_wp !! Subroutine Version character ( len =* ), parameter :: program_name = \"2lsom_train\" !! Subroutine name integer ( c_int ), intent ( in ) :: nvar , npat , som_type , nx1 , ny1 , nepoch1 , toroidal1 !! Integere variables real ( c_double ), intent ( out ) :: prot ( nx1 * ny1 , nvar ), distortion ( nepoch1 ) !! Real variables real ( c_double ), intent ( out ) :: u_matrix ( 2 * nx1 - 1 , 2 * ny1 - 1 ), coords ( nx1 * ny1 , 3 ) !! Real variables integer ( c_int ), intent ( out ) :: number_patterns ( nx1 , ny1 ), node_index ( npat , 3 ) !! Integer variables real ( c_double ), intent ( in ) :: x ( npat , nvar ) !! Real variables real ( c_double ), intent ( in ) :: alpha1 , alpha2 !! Real variables integer ( c_int ), intent ( in ) :: grid_type1 , distance_type1 , neigh_type1 !! Integer variables integer ( c_int ), intent ( in ) :: nx2 , grid_type2 , nepoch2 !,distance_type1,neigh_type2 !! Integer variables type ( two_level_self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters real ( kind = wp ), dimension ( nvar , 1 ) :: var integer :: i , j , k , ierr , pos , ihit , jhit , khit , nx1a , ny1a type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), dimension ( nx1 * ny1 , nvar ) :: prototypes real ( kind = wp ), dimension ( nvar , 1 ) :: temp ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx1 ; parameters ( 1 )% number_nodes_ny = ny1 ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = nepoch1 ; parameters ( 1 )% learning_rate = alpha1 ; parameters ( 1 )% random_seed_ = 12345 ; ! select case ( grid_type1 ) case ( 0 ) parameters ( 1 )% node_type = \"rectangular\" ; case ( 1 ) parameters ( 1 )% node_type = \"hexagonal\" ; end select ! parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" ; parameters ( 1 )% pattern_file = \"NOFILE\" ; parameters ( 1 )% output_file = \"NOFILE\" ; parameters ( 1 )% distance_type = \"euclidean\" ; !\"euclidean\" !euclidean, manhattan, correlation, correlation2 ! select case ( neigh_type1 ) case ( 0 ) parameters ( 1 )% neighborhood_type = \"bubble\" ; case ( 1 ) parameters ( 1 )% neighborhood_type = \"gaussian\" ; end select ! select case ( som_type ) case ( 0 ) parameters ( 1 )% som_type = \"normal_som\" ; !,visom, robust_som case ( 1 ) parameters ( 1 )% som_type = \"visom\" ; case ( 2 ) parameters ( 1 )% som_type = \"robust_som\" ; end select ! if ( toroidal1 == 1 ) then parameters ( 1 )% toroidal_grid = . TRUE .; else parameters ( 1 )% toroidal_grid = . FALSE .; endif ! end subroutine external_train_map","tags":"","loc":"proc\\external_train_map~2.html"},{"title":"mt19937_64 – KohonenF08","text":"NOTE: genrand64_int64 is kept private, as it generates different numbers\n      compared to the original C code. This is because the original C code\n      uses unsigned integers, while Fortran relies on signed integers.\n      This, however, has no impact on the generation of real numbers\n      (they are identical to those produced by the original C code). Uses iso_fortran_env module~~mt19937_64~~UsesGraph module~mt19937_64 mt19937_64 iso_fortran_env iso_fortran_env module~mt19937_64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mt19937_64~~UsedByGraph module~mt19937_64 mt19937_64 module~random_number_generator_utilities random_number_generator_utilities module~random_number_generator_utilities->module~mt19937_64 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function genrand64_real1 () Generates a random number on [0,1]-real-interval Arguments None Return Value real(kind=r64) public  function genrand64_real2 () Generates a random number on [0,1)-real-interval Arguments None Return Value real(kind=r64) public  function genrand64_real3 () Generates a random number on (0,1)-real-interval Arguments None Return Value real(kind=r64) Subroutines public  subroutine init_genrand64 (seed) Initializes mt(nn) with a seed Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: seed public  subroutine init_by_array64 (init_key) Initializes by an array with array-length\n  init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: init_key (:)","tags":"","loc":"module\\mt19937_64.html"},{"title":"kohonen_prototype_utilities – KohonenF08","text":"Uses distance_base_utilities error_handling precision_utilities constants_utilities module~~kohonen_prototype_utilities~~UsesGraph module~kohonen_prototype_utilities kohonen_prototype_utilities error_handling error_handling module~kohonen_prototype_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_prototype_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~kohonen_prototype_utilities->module~precision_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_prototype_utilities~~UsedByGraph module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~kohonen_prototype_utilities module~som_predict_variables->module~kohonen_pattern_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~self_organizing_map_utilities module~som_train_variables->module~kohonen_map_base_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~kohonen_prototype_utilities module~two_level_som_estimate_variables->module~kohonen_pattern_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~kohonen_prototype_utilities module~two_level_som_train_variables->module~kohonen_pattern_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kohonen_prototype Class to store a prototype inside a Kohonen map Type-Bound Procedures procedure, public :: create => kohonen_prototype_constructor procedure, public :: destroy => kohonen_prototype_destructor procedure, public :: get_prototype => kohonen_prototype_accessor procedure, public :: set_prototype => kohonen_prototype_mutator procedure, public :: print => kohonen_prototype_print procedure, public :: distance => kohonen_prototype_distance procedure, public :: get_nrow => kohonen_prototype_nrow procedure, public :: get_ncol => kohonen_prototype_ncol","tags":"","loc":"module\\kohonen_prototype_utilities.html"},{"title":"two_level_som_train_variables – KohonenF08","text":"Uses kohonen_pattern_utilities precision_utilities kohonen_prototype_utilities two_level_self_organizing_map_utilities kohonen_layer_parameters_utilities kohonen_map_base_utilities constants_utilities module~~two_level_som_train_variables~~UsesGraph module~two_level_som_train_variables two_level_som_train_variables module~constants_utilities constants_utilities module~two_level_som_train_variables->module~constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~two_level_som_train_variables->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~two_level_som_train_variables->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~two_level_som_train_variables->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~two_level_som_train_variables->module~precision_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities module~constants_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~two_level_self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~precision_utilities module~two_level_self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~random_generator_base_utilities random_generator_base_utilities module~two_level_self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~two_level_self_organizing_map_utilities->module~rkiss05_generator_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine train_two_level_som (parameter_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: parameter_file","tags":"","loc":"module\\two_level_som_train_variables.html"},{"title":"kohonen_layer_utilities – KohonenF08","text":"This module defines a class that represents a layer in a self-organizing map Uses random_generator_base_utilities kohonen_pattern_utilities error_handling kohonen_map_base_utilities precision_utilities distance_base_utilities kohonen_prototype_utilities factory_distance_utilities quicksort_utilities kohonen_layer_parameters_utilities rkiss05_generator_utilities constants_utilities module~~kohonen_layer_utilities~~UsesGraph module~kohonen_layer_utilities kohonen_layer_utilities error_handling error_handling module~kohonen_layer_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~kohonen_layer_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~kohonen_layer_utilities->module~precision_utilities module~quicksort_utilities quicksort_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~kohonen_layer_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~kohonen_prototype_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module\\kohonen_layer_utilities.html"},{"title":"general_utilities – KohonenF08","text":"This module includes general purpose functions used in several parts of the library Uses precision_utilities module~~general_utilities~~UsesGraph module~general_utilities general_utilities module~precision_utilities precision_utilities module~general_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface maximum private  subroutine maximum_only(a, mx) Subroutine to calculate the maximum of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a real(kind=wp) :: mx private  subroutine maximum_position(a, mx, p) Subroutine to find the position of the maximum value of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a A real array real(kind=wp) :: mx A real value with the maximum integer :: p An integer value with the position of the maximum Functions public  function minimum (a) result(mn) Function to calculate the minimum of an array Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(:) :: a Real array Return Value real(kind=wp) Real value with the minimum public  function mean (a) result(mn) Function to calculate the mean of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real value with the calculated mean public  function variance (a) result(v) Function to calculate the variance of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated variance public  function std (a) result(s) Function to calculate the standard deviation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated standard deviation public  function coefficient_of_variation (a) result(cov) Function to calculate the coefficient of variation of a real array Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: a A real array Return Value real(kind=wp) A real variable with the calculated coefficient of variation","tags":"","loc":"module\\general_utilities.html"},{"title":"som_train_variables – KohonenF08","text":"This module defines the variables for the program som_train Uses kohonen_pattern_utilities error_handling kohonen_map_base_utilities precision_utilities kohonen_prototype_utilities logger_utilities self_organizing_map_utilities kohonen_layer_parameters_utilities constants_utilities module~~som_train_variables~~UsesGraph module~som_train_variables som_train_variables error_handling error_handling module~som_train_variables->error_handling module~constants_utilities constants_utilities module~som_train_variables->module~constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~som_train_variables->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~som_train_variables->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~som_train_variables->module~kohonen_prototype_utilities module~logger_utilities logger_utilities module~som_train_variables->module~logger_utilities module~precision_utilities precision_utilities module~som_train_variables->module~precision_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~som_train_variables->module~self_organizing_map_utilities module~constants_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~logger_utilities->module~constants_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~self_organizing_map_utilities->error_handling module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~precision_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~quicksort_utilities quicksort_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine train_som (parameter_file) Subroutine to train the SOM Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: parameter_file A character variable with the name of the parameter file","tags":"","loc":"module\\som_train_variables.html"},{"title":"som_predict_variables – KohonenF08","text":"Uses kohonen_pattern_utilities error_handling precision_utilities kohonen_prototype_utilities self_organizing_map_utilities kohonen_layer_parameters_utilities kohonen_map_base_utilities constants_utilities module~~som_predict_variables~~UsesGraph module~som_predict_variables som_predict_variables error_handling error_handling module~som_predict_variables->error_handling module~constants_utilities constants_utilities module~som_predict_variables->module~constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~som_predict_variables->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~som_predict_variables->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~som_predict_variables->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~som_predict_variables->module~precision_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~som_predict_variables->module~self_organizing_map_utilities module~constants_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~self_organizing_map_utilities->error_handling module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~precision_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~quicksort_utilities quicksort_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( self_organizing_map ), public, save :: my_som type( kohonen_layer_parameters ), public, dimension(1) :: som_parameters type( kohonen_pattern ), public, allocatable :: input_patterns (:) integer, public, allocatable :: map_output (:,:) character(len=NUMCHAR), public :: parfl character(len=NUMCHAR), public :: som_parameter_file character(len=NUMCHAR), public :: prototype_file Subroutines public  subroutine initialize_variables (par_file) Arguments Type Intent Optional Attributes Name character(len=*) :: par_file public  subroutine release_variables () Arguments None","tags":"","loc":"module\\som_predict_variables.html"},{"title":"quicksort_utilities – KohonenF08","text":"Uses sort_base_utilities precision_utilities module~~quicksort_utilities~~UsesGraph module~quicksort_utilities quicksort_utilities module~precision_utilities precision_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~quicksort_utilities~~UsedByGraph module~quicksort_utilities quicksort_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( sort_base ) :: quicksort class that encapsulates the quicksort algorithm Type-Bound Procedures procedure, public, pass :: sort => quick_sort","tags":"","loc":"module\\quicksort_utilities.html"},{"title":"distance_base_utilities – KohonenF08","text":"This module defines an abstract class to represent an abstract function to calculate distance Uses precision_utilities module~~distance_base_utilities~~UsesGraph module~distance_base_utilities distance_base_utilities module~precision_utilities precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~distance_base_utilities~~UsedByGraph module~distance_base_utilities distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~distance_base_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~distance_base_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~distance_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~distance_base_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~kohonen_prototype_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_predict_variables->module~kohonen_pattern_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~self_organizing_map_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_map_base_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~kohonen_prototype_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_estimate_variables->module~kohonen_pattern_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~kohonen_prototype_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables->module~kohonen_pattern_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  function distance_function1(distance, vector1, vector2) result(d) Template for the calculate function\nImport section Arguments Type Intent Optional Attributes Name class( distance_base ) :: distance A distance_base object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance Derived Types type, public, abstract :: distance_base Abstract class distance_base Type-Bound Procedures procedure( distance_function1 ), public, deferred :: calculate","tags":"","loc":"module\\distance_base_utilities.html"},{"title":"dataframe_utilities – KohonenF08","text":"This module defines a data structure called dataframe Uses error_handling precision_utilities constants_utilities module~~dataframe_utilities~~UsesGraph module~dataframe_utilities dataframe_utilities error_handling error_handling module~dataframe_utilities->error_handling module~constants_utilities constants_utilities module~dataframe_utilities->module~constants_utilities module~precision_utilities precision_utilities module~dataframe_utilities->module~precision_utilities module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: dataframe Type-Bound Procedures procedure, public :: create => create_dataframe procedure, public :: destroy => destroy_dataframe procedure, public :: add_variable","tags":"","loc":"module\\dataframe_utilities.html"},{"title":"rkiss05_generator_utilities – KohonenF08","text":"Define the class rkiss05_generator that represents a random number generator\n  based on the rkiss method Uses random_generator_base_utilities precision_utilities module~~rkiss05_generator_utilities~~UsesGraph module~rkiss05_generator_utilities rkiss05_generator_utilities module~precision_utilities precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~random_generator_base_utilities random_generator_base_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~random_generator_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~rkiss05_generator_utilities~~UsedByGraph module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~rkiss05_generator_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~rkiss05_generator_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( random_generator_base ) :: rkiss05_generator Class to represent a random number generator that implements the rkiss method Type-Bound Procedures procedure, public :: create => create_rkiss05_generator procedure, public :: destroy => destroy_rkiss05_generator procedure, public :: generate => generate_rkiss05_generator","tags":"","loc":"module\\rkiss05_generator_utilities.html"},{"title":"neighborhood_function_base_utilities – KohonenF08","text":"This module defines an abstract class to define neighborhood functions Uses precision_utilities module~~neighborhood_function_base_utilities~~UsesGraph module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~precision_utilities precision_utilities module~neighborhood_function_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~neighborhood_function_base_utilities~~UsedByGraph module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~cauchy_neighborhood_function_utilities cauchy_neighborhood_function_utilities module~cauchy_neighborhood_function_utilities->module~neighborhood_function_base_utilities module~gaussian_neighborhood_function_utilities gaussian_neighborhood_function_utilities module~gaussian_neighborhood_function_utilities->module~neighborhood_function_base_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  function neighborhood_function_calculate(my_neigh_fn, geometric_distance) result(n) Subroutine template to calculate function\nImport section Arguments Type Intent Optional Attributes Name class( neighborhood_function_base ) :: my_neigh_fn A neighborhood_function_base object real(kind=wp), intent(inout) :: geometric_distance A real variable with the geometric or grid distance of a SOM unit Return Value real(kind=wp) A real variable with the value of the neighborhood function Derived Types type, public, abstract :: neighborhood_function_base Abstract class used to derive classes that calculates the effect of the input on the \nunits of a SOM (neighborhood function) Type-Bound Procedures procedure( neighborhood_function_calculate ), public, deferred :: calculate","tags":"","loc":"module\\neighborhood_function_base_utilities.html"},{"title":"self_organizing_map_utilities – KohonenF08","text":"This module defines a class for simple self_organizing_map (one kohonen layer) Uses random_generator_base_utilities kohonen_pattern_utilities error_handling kohonen_map_base_utilities precision_utilities distance_base_utilities kohonen_prototype_utilities factory_distance_utilities quicksort_utilities kohonen_layer_parameters_utilities rkiss05_generator_utilities constants_utilities module~~self_organizing_map_utilities~~UsesGraph module~self_organizing_map_utilities self_organizing_map_utilities error_handling error_handling module~self_organizing_map_utilities->error_handling module~constants_utilities constants_utilities module~self_organizing_map_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~self_organizing_map_utilities->module~precision_utilities module~quicksort_utilities quicksort_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~constants_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~kohonen_layer_parameters_utilities->error_handling module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~kohonen_prototype_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities module~sort_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~self_organizing_map_utilities~~UsedByGraph module~self_organizing_map_utilities self_organizing_map_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( kohonen_map_base ) :: self_organizing_map Class to represent a self_organizing_map Type-Bound Procedures procedure, public :: create => create_som procedure, public :: destroy => destroy_som procedure, public :: train => train_som_data procedure, public :: predict => predict_som procedure, public :: print => print_som procedure, public :: read => read_som procedure, public :: get_count => get_count_som procedure, public :: query => query_som procedure, public :: get_prototypes procedure, public :: get_u_matrix => get_u_matrix_som procedure, public, nopass :: external_train_map procedure, public, nopass :: external_predict_map Functions public  function position2index (ix, iy, iz, nx, ny) result(index_) Function to calculate the index inside a rectangular grid from position ix,iy,iz Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix Integer variables integer, intent(in) :: iy Integer variables integer, intent(in) :: iz Integer variables integer, intent(in) :: nx Integer variables integer, intent(in) :: ny Integer variables Return Value integer Integer variable with the required index public  function calculate_sigma (kohonen_map, input_data, seed) result(sigma) Function to calculate the scaling factor sigma Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_data A real array with the input data integer, intent(inout), optional :: seed An integer with the random seed Return Value real(kind=wp) A real variable with the value of sigma Subroutines public  subroutine create_som (kohonen_map, training_parameters) Constructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object public  subroutine destroy_som (kohonen_map) Destructor for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine create_random_sample (kohonen_map, input) Subroutine to generate random values that serve as inputs to the SOM Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: input A real array with the initial values of the prototypes public  subroutine train_som_data (kohonen_map, input_data) Training function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data public  subroutine predict_som (kohonen_map, input_data, map_output) Function for Prediction of a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data integer, intent(out), dimension(:,:) :: map_output An integer array with the map output public  subroutine print_som (kohonen_map, unit_) Print function for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), optional :: unit_ public  subroutine get_count_som (kohonen_map, count_) Function to get count matrix for self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map integer, intent(inout), dimension(:,:,:) :: count_ public  subroutine query_som (kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map real(kind=wp), intent(inout), dimension(:,:) :: input_pattern integer, allocatable :: sample_index (:) public  subroutine read_som (kohonen_map, som_fl) Subroutine to read the prototypes to define a self_organizing_map Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object character(len=*) :: som_fl A character variable with the name of the file public  subroutine index2position (index_, nx, ny, nz, cx, cy, cz) Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index Arguments Type Intent Optional Attributes Name integer, intent(in) :: index_ Integer variable representing the index integer, intent(in) :: nx Integer variables representing the dimensions of the kohonen map integer, intent(in) :: ny Integer variables representing the dimensions of the kohonen map integer, intent(in) :: nz Integer variables representing the dimensions of the kohonen map integer, intent(inout) :: cx Integer variables representing the position of the node integer, intent(inout) :: cy Integer variables representing the position of the node integer, intent(inout) :: cz Integer variables representing the position of the node public  subroutine calculate_distance_matrix (coordinates, distance_matrix, grid_type, toroidal) Subroutine to calculate the distance between the units inside a kohonen layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: coordinates Real array with the coordinates real(kind=wp), intent(inout), dimension(:,:) :: distance_matrix Real array with the distance_matrix character(len=*) :: grid_type Character variable with the grid type logical :: toroidal Logical variable for toroidal grid public  subroutine calculate_coordinates (current_index, ix, iy, iz, nx, ny, nz, coordinates, node_type) Subroutine to calculate the coordinates of the units inside a kohonen layer Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_index integer, intent(in) :: ix integer, intent(in) :: iy integer, intent(in) :: iz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz real(kind=wp), intent(out), dimension(:,:) :: coordinates character(len=*), intent(in) :: node_type public  subroutine find_best_match_unit (kohonen_map, current_prototype, ihit, jhit, khit, dist_hit) Subroutine to calculate the best match unit Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_prototype ), intent(inout) :: current_prototype A kohonen_prototype object integer, intent(out) :: ihit Integer variables for the coordinates of the BMU integer, intent(out) :: jhit Integer variables for the coordinates of the BMU integer, intent(out) :: khit Integer variables for the coordinates of the BMU real(kind=wp), intent(out) :: dist_hit Real variable with the distance to the BMU public  subroutine update_weights (kohonen_map, current_values, ihit, jhit, khit, maximum_radius, iteration) Subroutine to update the weights Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: current_values A real array with the values of the current unit integer, intent(inout) :: ihit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: jhit Integer variables with the coordinates of the unit (neuron) to be modified integer, intent(inout) :: khit Integer variables with the coordinates of the unit (neuron) to be modified real(kind=wp), intent(inout) :: maximum_radius Real variable with the maximum radius of the neighborhood integer, intent(inout) :: iteration Integer variables with the coordinates of the unit (neuron) to be modified public  subroutine calculate_distance_between_prototypes (kohonen_map) Subroutine to calculate the distance between the prototypes Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine find_bmu_grid (kohonen_map, input_data) Subroutine to calculate the best match unit over the grid Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array with the input data public  subroutine calculate_u_matrix (kohonen_map) Subroutine to calculate  the u_matrix Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine calculate_u_matrix_hexagonal (kohonen_map) Subroutine to calculate the u_matrix for an hexagonal grid Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine calculate_u_matrix_rectangular (kohonen_map) Subroutine to calculate the u_matix for a rectangular grid Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object public  subroutine get_u_matrix_som (kohonen_map, u_matrix) Subroutine to get the u_matrix from a SOM Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:,:) :: u_matrix A real array to return the u_matrix public  subroutine get_prototypes (kohonen_map, prototypes) Subroutine to get SOM prototypes Arguments Type Intent Optional Attributes Name class( self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: prototypes A real array to return the values of the SOM prototypes public  subroutine external_train_map (x, nvar, npat, nx, ny, nepoch, alpha, grid_type, distance_type, neigh_type, toroidal, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_som\") Subroutine to connect the self_organizing_map module to R o C\nImport section Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real array with the input patterns integer(kind=c_int), intent(in) :: nvar Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: npat Integer variables to indicate the number of variables and patterns integer(kind=c_int), intent(in) :: nx Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: ny Integer variables to indicate the number of nodes of the SOM integer(kind=c_int), intent(in) :: nepoch Integer variables to indicate the number of epochs for training real(kind=c_double), intent(in) :: alpha Real value with the initial learning rate integer(kind=c_int), intent(in) :: grid_type Integer variable to indicate the type of grid integer(kind=c_int), intent(in) :: distance_type Integer variable to indicate the distance type integer(kind=c_int), intent(in) :: neigh_type Integer variable to indicate the neighborhood type integer(kind=c_int), intent(in) :: toroidal Integer variable to indicate if a toroidal grid is used real(kind=c_double), intent(out) :: prot (nx*ny,nvar) Real array for the prototypes real(kind=c_double), intent(out) :: distortion (nepoch) Real array for the distortion measure (error during training) real(kind=c_double), intent(out) :: u_matrix (2*nx-1,2*ny-1) Real array for the u_matrix real(kind=c_double), intent(out) :: coords (nx*ny,3) Real array for the grid coordinates of the SOM integer(kind=c_int), intent(out) :: number_patterns (nx,ny) Integer array with the number of hits for each neuron integer(kind=c_int), intent(out) :: node_index (npat,3) Integer array with the index node for all the neurons of the SOM public  subroutine external_predict_map (prot, nx, ny, new_pat, npat, nvar, node_index) bind(C, name=\"predict_som\") Subroutine to connect this module to R Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: prot (nx*ny,nvar) integer(kind=c_int), intent(in) :: nx integer(kind=c_int), intent(in) :: ny real(kind=c_double), intent(in) :: new_pat (npat,nvar) integer(kind=c_int), intent(in) :: npat integer(kind=c_int), intent(in) :: nvar integer(kind=c_int), intent(out) :: node_index (npat,3)","tags":"","loc":"module\\self_organizing_map_utilities.html"},{"title":"kohonen_map_base_utilities – KohonenF08","text":"This module defines an abstract class for kohonen maps Uses kohonen_layer_parameters_utilities kohonen_pattern_utilities precision_utilities module~~kohonen_map_base_utilities~~UsesGraph module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~precision_utilities precision_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~constants_utilities->module~precision_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~distance_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_map_base_utilities~~UsedByGraph module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~kohonen_map_base_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~self_organizing_map_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine kohonen_map_constructor(kohonen_map, training_parameters) Template function for the constructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters object abstract interface public  subroutine kohonen_map_destructor(kohonen_map) Template function for the destructor of a kohonen map\nImport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object abstract interface public  subroutine kohonen_map_function1(kohonen_map, input_data) Template function for the training function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects abstract interface public  subroutine kohonen_map_function2(kohonen_map, input_data, map_output) Template function for the prediction function of a kohonen map\nimport section Arguments Type Intent Optional Attributes Name class( kohonen_map_base ) :: kohonen_map A kohonen_map_base object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data An array of kohonen_pottern objects integer, intent(out), dimension(:,:) :: map_output An integer array Derived Types type, public, abstract :: kohonen_map_base Abstract Class to represent a template for a kohonen map Type-Bound Procedures procedure( kohonen_map_constructor ), public, deferred :: create procedure( kohonen_map_destructor ), public, deferred :: destroy procedure( kohonen_map_function1 ), public, deferred :: train procedure( kohonen_map_function2 ), public, deferred :: predict","tags":"","loc":"module\\kohonen_map_base_utilities.html"},{"title":"random_generator_base_utilities – KohonenF08","text":"Uses precision_utilities module~~random_generator_base_utilities~~UsesGraph module~random_generator_base_utilities random_generator_base_utilities module~precision_utilities precision_utilities module~random_generator_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~random_generator_base_utilities~~UsedByGraph module~random_generator_base_utilities random_generator_base_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~random_generator_base_utilities module~two_level_self_organizing_map_utilities->module~rkiss05_generator_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~rkiss05_generator_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  function random_generator_generate(generator) result(r) Template of the function used to generate realizations of the random numbers in the \nclasses derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Return Value real(kind=wp) r: A real number abstract interface public  subroutine random_generator_constructor(generator, iseed) Template of the constructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object integer, intent(in), optional :: iseed iseed: An integer with the seed of the random generator. abstract interface public  subroutine random_generator_destructor(generator) Template of the destructor of the classes derived from the random_generator class.\nrandom_generator_base Arguments Type Intent Optional Attributes Name class( random_generator_base ) :: generator generator: A random_generator_base object Derived Types type, public, abstract :: random_generator_base Abstract class to derive random number generator classes Type-Bound Procedures procedure( random_generator_constructor ), public, deferred :: create procedure( random_generator_destructor ), public, deferred :: destroy procedure( random_generator_generate ), public, deferred :: generate","tags":"","loc":"module\\random_generator_base_utilities.html"},{"title":"sort_base_utilities – KohonenF08","text":"Uses precision_utilities module~~sort_base_utilities~~UsesGraph module~sort_base_utilities sort_base_utilities module~precision_utilities precision_utilities module~sort_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~sort_base_utilities~~UsedByGraph module~sort_base_utilities sort_base_utilities module~quicksort_utilities quicksort_utilities module~quicksort_utilities->module~sort_base_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine sort_procedure(my_sort, list, order) Subroutine to sort an array\nimport sort_base Arguments Type Intent Optional Attributes Name class( sort_base ), intent(inout) :: my_sort my_sort: A sort_base object real(kind=wp), intent(inout), dimension(:) :: list list: A real vector integer, intent(inout), dimension(:) :: order order: An integer vector Derived Types type, public, abstract :: sort_base Abstract class to represent a generic sort algoritm Type-Bound Procedures procedure( sort_procedure ), public, deferred, pass :: sort","tags":"","loc":"module\\sort_base_utilities.html"},{"title":"logger_utilities – KohonenF08","text":"Uses constants_utilities module~~logger_utilities~~UsesGraph module~logger_utilities logger_utilities module~constants_utilities constants_utilities module~logger_utilities->module~constants_utilities module~precision_utilities precision_utilities module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~logger_utilities~~UsedByGraph module~logger_utilities logger_utilities module~som_train_variables som_train_variables module~som_train_variables->module~logger_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( logger ), public :: global_logger Derived Types type, public :: logger The Logger class is used to store all the variables related to the units of \nfiles used to store or print messages during the development (debugging ) or \nrunning Type-Bound Procedures procedure, public :: create => create_logger procedure, public :: destroy => destroy_logger procedure, public :: startup procedure, public :: shutdown procedure, public :: is_initialized procedure, public :: message procedure, public :: write generic, public :: configure => configure_logical, configure_integer, configure_character procedure, public :: get_unit procedure, public :: delimiter procedure, public :: get_delimiter procedure, public :: reset procedure, public :: error","tags":"","loc":"module\\logger_utilities.html"},{"title":"kohonen_pattern_utilities – KohonenF08","text":"This module defines a class called kohonen_pattern to store the input patterns Uses kohonen_prototype_utilities error_handling precision_utilities constants_utilities module~~kohonen_pattern_utilities~~UsesGraph module~kohonen_pattern_utilities kohonen_pattern_utilities error_handling error_handling module~kohonen_pattern_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~kohonen_pattern_utilities->module~precision_utilities module~constants_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~distance_base_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_pattern_utilities~~UsedByGraph module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~kohonen_pattern_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~self_organizing_map_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~kohonen_pattern_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~kohonen_pattern_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kohonen_pattern Class to represent a container for input data to  a kohonen map Type-Bound Procedures procedure, public :: create => kohonen_pattern_create procedure, public :: destroy => kohonen_pattern_destroy procedure, public :: get => kohonen_pattern_accessor procedure, public :: set => kohonen_pattern_mutator procedure, public :: print => kohonen_pattern_print procedure, public :: get_nrow => kohonen_pattern_nrow procedure, public :: get_ncol => kohonen_pattern_ncol Functions public  function kohonen_pattern_nrow (current_pattern) result(nr) Function to calculate the number of rows (samples) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of rows (samples) in a pattern public  function kohonen_pattern_ncol (current_pattern) result(nc) Function to calculate the number of columns (variables) in a pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object Return Value integer An integer with the number of columns (variables) in a pattern Subroutines public  subroutine kohonen_pattern_create (current_pattern, input, name) Kohonen pattern constructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object real(kind=wp), intent(inout), dimension(:,:) :: input A real array character(len=*), optional :: name A character string with the name of the pattern public  subroutine kohonen_pattern_destroy (current_pattern) Kohonen pattern destructor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object public  subroutine kohonen_pattern_accessor (current_pattern, pattern_value) Kohonen pattern accessor Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value public  subroutine kohonen_pattern_mutator (current_pattern, pattern_value) kohonen_pattern_mutator Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object type( kohonen_prototype ), intent(inout) :: pattern_value public  subroutine kohonen_pattern_print (current_pattern, unit_) Subroutine to print a Kohonen pattern Arguments Type Intent Optional Attributes Name class( kohonen_pattern ) :: current_pattern A kohonen_pattern object integer, intent(inout), optional :: unit_ An integer variable with the number of the unit where the patterns will be printed","tags":"","loc":"module\\kohonen_pattern_utilities.html"},{"title":"factory_distance_utilities – KohonenF08","text":"This module defines a factory to create distance objects Uses max_distance_utilities euclidean_distance_utilities distance_base_utilities manhattan_distance_utilities module~~factory_distance_utilities~~UsesGraph module~factory_distance_utilities factory_distance_utilities module~distance_base_utilities distance_base_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~precision_utilities precision_utilities module~distance_base_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~factory_distance_utilities~~UsedByGraph module~factory_distance_utilities factory_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: factory_distance Class to represent a distance factory Type-Bound Procedures procedure, public :: create_distance Subroutines public  subroutine create_distance (factory, type_, dist) Class constructor Arguments Type Intent Optional Attributes Name class( factory_distance ) :: factory A factory_distance object character(len=*) :: type_ A character string with the type of distance to be instantiated class( distance_base ), allocatable :: dist An allocatable distance_base object","tags":"","loc":"module\\factory_distance_utilities.html"},{"title":"kohonen_layer_parameters_utilities – KohonenF08","text":"Uses tomlf error_handling precision_utilities constants_utilities module~~kohonen_layer_parameters_utilities~~UsesGraph module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~precision_utilities precision_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~kohonen_layer_parameters_utilities~~UsedByGraph module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~kohonen_layer_parameters_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~self_organizing_map_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~kohonen_layer_parameters_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~kohonen_layer_parameters_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kohonen_layer_parameters Components Type Visibility Attributes Name Initial integer, public :: train_option integer, public :: number_nodes_nx integer, public :: number_nodes_ny integer, public :: number_nodes_nz integer, public :: number_patterns integer, public :: number_variables1 integer, public :: number_variables2 integer, public :: number_variables integer, public, allocatable :: column_var (:) integer, public :: number_epochs integer, public :: debug_level integer, public, dimension(1) :: random_seed_ real(kind=wp), public :: learning_rate character(len=NUMCHAR), public :: node_type character(len=NUMCHAR), public :: debug_file character(len=NUMCHAR), public :: pattern_file character(len=NUMCHAR), public :: output_file character(len=NUMCHAR), public :: distance_type character(len=NUMCHAR), public :: neighborhood_type character(len=NUMCHAR), public :: som_type character(len=NUMCHAR), public :: m_estimator logical, public :: toroidal_grid integer, public :: idbg integer, public :: iout integer, public :: iindex integer, public :: iprot integer, public :: ihit integer, public :: idist integer, public :: iumat integer, public :: ipar integer, public :: isam integer, public :: iclus integer, public :: icen integer, public :: iclus1 integer, public :: idisto integer, public :: iout1 integer, public :: imeas logical, public :: view_flag integer, public :: ireal Type-Bound Procedures procedure, public :: print => print_parameters procedure, public :: read_parameters procedure, public :: read_parameters_toml","tags":"","loc":"module\\kohonen_layer_parameters_utilities.html"},{"title":"manhattan_distance_utilities – KohonenF08","text":"This module defines a class to calculate the Manhattan distance between kohonen prototypes Uses distance_base_utilities precision_utilities module~~manhattan_distance_utilities~~UsesGraph module~manhattan_distance_utilities manhattan_distance_utilities module~distance_base_utilities distance_base_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~manhattan_distance_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~manhattan_distance_utilities~~UsedByGraph module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( distance_base ) :: manhattan_distance Class to calculate the Manhattan distance Type-Bound Procedures procedure, public :: calculate => calculate_manhattan_distance","tags":"","loc":"module\\manhattan_distance_utilities.html"},{"title":"two_level_som_estimate_variables – KohonenF08","text":"Uses kohonen_pattern_utilities precision_utilities kohonen_prototype_utilities two_level_self_organizing_map_utilities kohonen_layer_parameters_utilities rkiss05_generator_utilities kohonen_map_base_utilities constants_utilities module~~two_level_som_estimate_variables~~UsesGraph module~two_level_som_estimate_variables two_level_som_estimate_variables module~constants_utilities constants_utilities module~two_level_som_estimate_variables->module~constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~two_level_som_estimate_variables->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~two_level_som_estimate_variables->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~two_level_som_estimate_variables->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~two_level_som_estimate_variables->module~precision_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~two_level_som_estimate_variables->module~rkiss05_generator_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~constants_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~distance_base_utilities distance_base_utilities module~kohonen_prototype_utilities->module~distance_base_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~rkiss05_generator_utilities->module~precision_utilities module~random_generator_base_utilities random_generator_base_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~two_level_self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~precision_utilities module~two_level_self_organizing_map_utilities->module~rkiss05_generator_utilities module~two_level_self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~two_level_self_organizing_map_utilities->module~random_generator_base_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~random_generator_base_utilities->module~precision_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( two_level_self_organizing_map ), public, save :: my_som type( kohonen_layer_parameters ), public, dimension(2) :: som_parameters type( kohonen_pattern ), public, allocatable :: input_patterns (:) integer, public :: ipattern integer, public :: number_clusters_evaluations integer, public :: iseed integer, public :: ic integer, public :: current_cluster integer, public :: neval integer, public :: i integer, public :: j character(len=NUMCHAR), public :: parfl character(len=NUMCHAR), public :: matrix_fl integer, public, allocatable :: seeds (:) integer, public, allocatable :: clusters (:) integer, public, dimension(3) :: min_nodes integer, public, dimension(3) :: max_nodes real(kind=wp), public, dimension(3) :: results real(kind=wp), public, allocatable :: total_results (:,:,:) real(kind=wp), public, allocatable :: association_matrix (:,:) integer, public :: number_nodes integer, public :: p integer, public :: min_cluster integer, public :: number_clusters type( rkiss05_generator ), public :: rgrator Subroutines public  subroutine initialize_variables (par_file) Arguments Type Intent Optional Attributes Name character(len=*) :: par_file public  subroutine release_variables () Arguments None","tags":"","loc":"module\\two_level_som_estimate_variables.html"},{"title":"random_number_generator_utilities – KohonenF08","text":"This module defines the random_number_generator class that is used to generate random numbers \nin several procedures across ATALIB. Uses precision_utilities mt19937_64 module~~random_number_generator_utilities~~UsesGraph module~random_number_generator_utilities random_number_generator_utilities module~mt19937_64 mt19937_64 module~random_number_generator_utilities->module~mt19937_64 module~precision_utilities precision_utilities module~random_number_generator_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~mt19937_64->iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: random_number_generator The random_number_generator class is used to encapsulate a generator or random numbers\nAn object of this class is defined through the specification of the random seed or seeds Type-Bound Procedures generic, public :: create => create_random_number_grator_single, create_random_number_grator_array procedure, public :: destroy => destroy_random_number_grator procedure, public :: generate","tags":"","loc":"module\\random_number_generator_utilities.html"},{"title":"max_distance_utilities – KohonenF08","text":"This module defines a class to calculate the Max distance between kohonen prototypes Uses distance_base_utilities precision_utilities module~~max_distance_utilities~~UsesGraph module~max_distance_utilities max_distance_utilities module~distance_base_utilities distance_base_utilities module~max_distance_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~max_distance_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~max_distance_utilities~~UsedByGraph module~max_distance_utilities max_distance_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( distance_base ) :: max_distance Class to calculate the Max distance Type-Bound Procedures procedure, public :: calculate => calculate_max_distance","tags":"","loc":"module\\max_distance_utilities.html"},{"title":"cauchy_neighborhood_function_utilities – KohonenF08","text":"This module defines the Cauchy neighborhood function Uses neighborhood_function_base_utilities precision_utilities module~~cauchy_neighborhood_function_utilities~~UsesGraph module~cauchy_neighborhood_function_utilities cauchy_neighborhood_function_utilities module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~cauchy_neighborhood_function_utilities->module~neighborhood_function_base_utilities module~precision_utilities precision_utilities module~cauchy_neighborhood_function_utilities->module~precision_utilities module~neighborhood_function_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( neighborhood_function_base ) :: cauchy_neighborhood_function Class that implements the Cauchy Neighborhood Function Type-Bound Procedures procedure, public :: create => create_cauchy_neighborhood procedure, public :: calculate => calculate_cauchy_neighborhood","tags":"","loc":"module\\cauchy_neighborhood_function_utilities.html"},{"title":"gaussian_neighborhood_function_utilities – KohonenF08","text":"This module defines the Gaussian neighborhood function Uses neighborhood_function_base_utilities precision_utilities module~~gaussian_neighborhood_function_utilities~~UsesGraph module~gaussian_neighborhood_function_utilities gaussian_neighborhood_function_utilities module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~gaussian_neighborhood_function_utilities->module~neighborhood_function_base_utilities module~precision_utilities precision_utilities module~gaussian_neighborhood_function_utilities->module~precision_utilities module~neighborhood_function_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( neighborhood_function_base ) :: gaussian_neighborhood_function Class that implements the Gaussian Neighborhood Function Type-Bound Procedures procedure, public :: create => create_gaussian_neighborhood procedure, public :: calculate => calculate_gaussian_neighborhood","tags":"","loc":"module\\gaussian_neighborhood_function_utilities.html"},{"title":"precision_utilities – KohonenF08","text":"Uses iso_fortran_env module~~precision_utilities~~UsesGraph module~precision_utilities precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~precision_utilities~~UsedByGraph module~precision_utilities precision_utilities module~cauchy_neighborhood_function_utilities cauchy_neighborhood_function_utilities module~cauchy_neighborhood_function_utilities->module~precision_utilities module~neighborhood_function_base_utilities neighborhood_function_base_utilities module~cauchy_neighborhood_function_utilities->module~neighborhood_function_base_utilities module~constants_utilities constants_utilities module~constants_utilities->module~precision_utilities module~dataframe_utilities dataframe_utilities module~dataframe_utilities->module~precision_utilities module~dataframe_utilities->module~constants_utilities module~distance_base_utilities distance_base_utilities module~distance_base_utilities->module~precision_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~euclidean_distance_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~gaussian_neighborhood_function_utilities gaussian_neighborhood_function_utilities module~gaussian_neighborhood_function_utilities->module~precision_utilities module~gaussian_neighborhood_function_utilities->module~neighborhood_function_base_utilities module~general_utilities general_utilities module~general_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~precision_utilities module~kohonen_layer_utilities->module~constants_utilities module~kohonen_layer_utilities->module~distance_base_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~quicksort_utilities quicksort_utilities module~kohonen_layer_utilities->module~quicksort_utilities module~random_generator_base_utilities random_generator_base_utilities module~kohonen_layer_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~kohonen_layer_utilities->module~rkiss05_generator_utilities module~factory_distance_utilities factory_distance_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~manhattan_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~max_distance_utilities max_distance_utilities module~max_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~neighborhood_function_base_utilities->module~precision_utilities module~quicksort_utilities->module~precision_utilities module~sort_base_utilities sort_base_utilities module~quicksort_utilities->module~sort_base_utilities module~random_generator_base_utilities->module~precision_utilities module~random_number_generator_utilities random_number_generator_utilities module~random_number_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~precision_utilities module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~distance_base_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~quicksort_utilities module~self_organizing_map_utilities->module~random_generator_base_utilities module~self_organizing_map_utilities->module~rkiss05_generator_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~precision_utilities module~som_predict_variables->module~constants_utilities module~som_predict_variables->module~kohonen_layer_parameters_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~som_predict_variables->module~kohonen_pattern_utilities module~som_predict_variables->module~kohonen_prototype_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~precision_utilities module~som_train_variables->module~constants_utilities module~som_train_variables->module~kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_map_base_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~self_organizing_map_utilities module~logger_utilities logger_utilities module~som_train_variables->module~logger_utilities module~sort_base_utilities->module~precision_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~precision_utilities module~two_level_self_organizing_map_utilities->module~distance_base_utilities module~two_level_self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~random_generator_base_utilities module~two_level_self_organizing_map_utilities->module~rkiss05_generator_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~precision_utilities module~two_level_som_estimate_variables->module~constants_utilities module~two_level_som_estimate_variables->module~kohonen_layer_parameters_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_som_estimate_variables->module~kohonen_pattern_utilities module~two_level_som_estimate_variables->module~kohonen_prototype_utilities module~two_level_som_estimate_variables->module~rkiss05_generator_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~precision_utilities module~two_level_som_train_variables->module~constants_utilities module~two_level_som_train_variables->module~kohonen_layer_parameters_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables->module~kohonen_pattern_utilities module~two_level_som_train_variables->module~kohonen_prototype_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities module~factory_distance_utilities->module~distance_base_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~logger_utilities->module~constants_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = real32 Single precision integer, public, parameter :: dp = wp Double precision integer, public, parameter :: ep = wp Extended precision integer, public, parameter :: i8 = int8 Integer (short) integer, public, parameter :: i16 = int16 Integer (short) integer, public, parameter :: i32 = int32 Integer (long) integer, public, parameter :: i64 = int64 Integer (long)","tags":"","loc":"module\\precision_utilities.html"},{"title":"euclidean_distance_utilities – KohonenF08","text":"This module defines a class to calculate the Euclidean distance between kohonen prototypes Uses distance_base_utilities precision_utilities module~~euclidean_distance_utilities~~UsesGraph module~euclidean_distance_utilities euclidean_distance_utilities module~distance_base_utilities distance_base_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~precision_utilities precision_utilities module~euclidean_distance_utilities->module~precision_utilities module~distance_base_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~euclidean_distance_utilities~~UsedByGraph module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities factory_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~factory_distance_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~factory_distance_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~self_organizing_map_utilities module~som_train_variables som_train_variables module~som_train_variables->module~self_organizing_map_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( distance_base ) :: euclidean_distance Class to calculate the euclidean distance Type-Bound Procedures procedure, public :: calculate => calculate_euclidean_distance Functions public  function calculate_euclidean_distance (distance, vector1, vector2) result(d) Function to calculate euclidean distance between vectors Arguments Type Intent Optional Attributes Name class( euclidean_distance ) :: distance A euclidean_distance object real(kind=wp), intent(inout), dimension(:,:) :: vector1 A real vector real(kind=wp), intent(inout), dimension(:,:) :: vector2 A real vector Return Value real(kind=wp) A real variable with the distance","tags":"","loc":"module\\euclidean_distance_utilities.html"},{"title":"two_level_self_organizing_map_utilities – KohonenF08","text":"This module defines a class that represents a two layer self_organizing_map  for clustering Uses kohonen_pattern_utilities random_generator_base_utilities precision_utilities distance_base_utilities kohonen_prototype_utilities factory_distance_utilities kohonen_layer_parameters_utilities rkiss05_generator_utilities kohonen_map_base_utilities module~~two_level_self_organizing_map_utilities~~UsesGraph module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~distance_base_utilities distance_base_utilities module~two_level_self_organizing_map_utilities->module~distance_base_utilities module~factory_distance_utilities factory_distance_utilities module~two_level_self_organizing_map_utilities->module~factory_distance_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~two_level_self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~precision_utilities precision_utilities module~two_level_self_organizing_map_utilities->module~precision_utilities module~random_generator_base_utilities random_generator_base_utilities module~two_level_self_organizing_map_utilities->module~random_generator_base_utilities module~rkiss05_generator_utilities rkiss05_generator_utilities module~two_level_self_organizing_map_utilities->module~rkiss05_generator_utilities module~distance_base_utilities->module~precision_utilities module~factory_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities euclidean_distance_utilities module~factory_distance_utilities->module~euclidean_distance_utilities module~manhattan_distance_utilities manhattan_distance_utilities module~factory_distance_utilities->module~manhattan_distance_utilities module~max_distance_utilities max_distance_utilities module~factory_distance_utilities->module~max_distance_utilities module~kohonen_layer_parameters_utilities->module~precision_utilities error_handling error_handling module~kohonen_layer_parameters_utilities->error_handling module~constants_utilities constants_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities tomlf tomlf module~kohonen_layer_parameters_utilities->tomlf module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~kohonen_map_base_utilities->module~precision_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_pattern_utilities->module~precision_utilities module~kohonen_pattern_utilities->error_handling module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_prototype_utilities->module~distance_base_utilities module~kohonen_prototype_utilities->module~precision_utilities module~kohonen_prototype_utilities->error_handling module~kohonen_prototype_utilities->module~constants_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env module~random_generator_base_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~precision_utilities module~rkiss05_generator_utilities->module~random_generator_base_utilities module~constants_utilities->module~precision_utilities module~euclidean_distance_utilities->module~distance_base_utilities module~euclidean_distance_utilities->module~precision_utilities module~manhattan_distance_utilities->module~distance_base_utilities module~manhattan_distance_utilities->module~precision_utilities module~max_distance_utilities->module~distance_base_utilities module~max_distance_utilities->module~precision_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~two_level_self_organizing_map_utilities~~UsedByGraph module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( kohonen_map_base ) :: two_level_self_organizing_map Class to represent a two level self_organized_map Type-Bound Procedures procedure, public :: create => create_2lsom procedure, public :: destroy => destroy_2lsom procedure, public :: train => train_2lsom procedure, public :: predict => predict_2lsom procedure, public :: train_grid_layer procedure, public :: train_cluster_layer procedure, public :: print => print_2lsom procedure, public :: query => query_2lsom procedure, public :: set_cluster_layer procedure, public :: set_parameters procedure, public :: read_som_layer procedure, public :: calculate_sum2_clusters_samples => evaluate_2lsom procedure, public :: get_cluster_samples procedure, public :: calculate_sum2_clusters_grid procedure, public, nopass :: external_train_map Read more… Functions public  function position2index (ix, iy, iz, nx, ny) result(index_) Function to calculate the index inside a rectangular grid from position ix,iy,iz Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix Integer variables ix,iy,iz,nx,ny integer, intent(in) :: iy Integer variables ix,iy,iz,nx,ny integer, intent(in) :: iz Integer variables ix,iy,iz,nx,ny integer, intent(in) :: nx Integer variables ix,iy,iz,nx,ny integer, intent(in) :: ny Integer variables ix,iy,iz,nx,ny Return Value integer Integer variable with the index Subroutines public  subroutine create_2lsom (kohonen_map, training_parameters) Constructor of a two_level self_organized_map class Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_layer_parameters ), dimension(:) :: training_parameters A kohonen_layer_parameters structure public  subroutine destroy_2lsom (kohonen_map) Destructor of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object public  subroutine create_random_sample (kohonen_map, input) Subroutine to generate random values that serve as inputs to the SOM Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A self_organizing_map object real(kind=wp), intent(out), dimension(:,:) :: input A real array with the initial values of the prototypes public  subroutine train_2lsom (kohonen_map, input_data) Subroutine to train a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array public  subroutine predict_2lsom (kohonen_map, input_data, map_output) Subroutine to make a prediction from a trained two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array integer, intent(out), dimension(:,:) :: map_output An integer array public  subroutine train_grid_layer (kohonen_map, input_data) Subroutine to train the grid layer of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array public  subroutine train_cluster_layer (kohonen_map) Subroutine to train the cluster layer of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object public  subroutine print_2lsom (kohonen_map, unit_) Subroutine to print the layers of a two_level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer, optional :: unit_ An integer variable with the unit public  subroutine set_cluster_layer (kohonen_map, seed) Subroutine to initialize the cluster layer of a Two Level Self-Organizing Map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer :: seed An integer variable with the random seed public  subroutine set_parameters (kohonen_map, training_parameters) Subroutine to set parameters Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_layer_parameters ), dimension(2) :: training_parameters public  subroutine evaluate_2lsom (kohonen_map, input_data, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_data A kohonen_pattern array real(kind=wp), optional, dimension(:) :: results A real array public  subroutine calculate_sum2_clusters_grid (kohonen_map, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), optional, dimension(:) :: results A real array public  subroutine calculate_cluster_measures (kohonen_map, results) Subroutine to calculate some clustering statistics of a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), dimension(:,:,:) :: results A real array public  subroutine read_som_layer (kohonen_map, som_fl, layer_type) Subroutine to read the prototypes of the first/seconf layer of a two level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object character(len=*) :: som_fl A character variable character(len=*) :: layer_type A character variable public  subroutine query_2lsom (kohonen_map, input_pattern, sample_index) Function to find the input samples associated with specific vector Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: input_pattern A real array integer, allocatable :: sample_index (:) An integer array public  subroutine get_cluster_samples (kohonen_map, clusters) Accessor to cluster results obtained using a two-level self_organized_map Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object integer, intent(inout), dimension(:) :: clusters An integer array public  subroutine index2position (index_, nx, ny, nz, cx, cy, cz) Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index Arguments Type Intent Optional Attributes Name integer, intent(in) :: index_ Integer variables, index_,nx,ny,nz integer, intent(in) :: nx Integer variables, index_,nx,ny,nz integer, intent(in) :: ny Integer variables, index_,nx,ny,nz integer, intent(in) :: nz Integer variables, index_,nx,ny,nz integer, intent(inout) :: cx Integer variables cx,cy,cz integer, intent(inout) :: cy Integer variables cx,cy,cz integer, intent(inout) :: cz Integer variables cx,cy,cz public  subroutine calculate_distance_matrix (coordinates, distance_matrix, grid_type, toroidal) Subroutine to calculate the distance between the units inside a kohonen layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: coordinates A real array real(kind=wp), intent(inout), dimension(:,:) :: distance_matrix A real array character(len=*) :: grid_type A character varaible logical :: toroidal A logical variableS public  subroutine calculate_coordinates (current_index, ix, iy, iz, nx, ny, nz, coordinates, node_type) Subroutine to calculate the coordinates of the units inside a kohonen layer Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_index Integer variables integer, intent(in) :: ix Integer variables integer, intent(in) :: iy Integer variables integer, intent(in) :: iz Integer variables integer, intent(in) :: nx Integer variables integer, intent(in) :: ny Integer variables integer, intent(in) :: nz Integer variables real(kind=wp), intent(out), dimension(:,:) :: coordinates Real array character(len=*), intent(in) :: node_type Character variable public  subroutine find_best_match_unit (kohonen_map, current_prototype, ihit, jhit, khit, dist_hit) Subroutine to calculate the best match unit Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_prototype ), intent(inout) :: current_prototype A kohonen_prototype object integer, intent(out) :: ihit Integer variables integer, intent(out) :: jhit Integer variables integer, intent(out) :: khit Integer variables real(kind=wp), intent(out) :: dist_hit A real variable public  subroutine update_weights (kohonen_map, current_values, ihit, jhit, khit, maximum_radius, iteration) Subroutine to update the weights Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object real(kind=wp), intent(inout), dimension(:,:) :: current_values A real array integer, intent(inout) :: ihit Integer variables integer, intent(inout) :: jhit Integer variables integer, intent(inout) :: khit Integer variables real(kind=wp), intent(inout) :: maximum_radius A real variable with the maximum radius integer, intent(inout) :: iteration Integer variables public  subroutine calculate_distance_between_prototypes (kohonen_map) Subroutine to calculate distance between prototypes Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object public  subroutine calculate_u_matrix (kohonen_map) Subroutine to calculate  the u_matrix Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object public  subroutine assign_input_to_clusters (kohonen_map, input_patterns) Subroutine to assign input to clusters Arguments Type Intent Optional Attributes Name class( two_level_self_organizing_map ) :: kohonen_map A two_level_self_organizing_map object type( kohonen_pattern ), intent(inout), dimension(:) :: input_patterns A kohonen_pattern array public  subroutine external_train_map (x, nvar, npat, som_type, nx1, ny1, nepoch1, alpha1, grid_type1, distance_type1, neigh_type1, toroidal1, nx2, nepoch2, alpha2, grid_type2, prot, distortion, u_matrix, coords, number_patterns, node_index) bind(C, name=\"train_2lsom\") Subroutine to connect the two_level_self_organizing_map module to R o C\nUse iso_c_binding module Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: x (npat,nvar) Real variables integer(kind=c_int), intent(in) :: nvar Integere variables integer(kind=c_int), intent(in) :: npat Integere variables integer(kind=c_int), intent(in) :: som_type Integere variables integer(kind=c_int), intent(in) :: nx1 Integere variables integer(kind=c_int), intent(in) :: ny1 Integere variables integer(kind=c_int), intent(in) :: nepoch1 Integere variables real(kind=c_double), intent(in) :: alpha1 Real variables integer(kind=c_int), intent(in) :: grid_type1 Integer variables integer(kind=c_int), intent(in) :: distance_type1 Integer variables integer(kind=c_int), intent(in) :: neigh_type1 Integer variables integer(kind=c_int), intent(in) :: toroidal1 Integere variables integer(kind=c_int), intent(in) :: nx2 Integer variables integer(kind=c_int), intent(in) :: nepoch2 Integer variables real(kind=c_double), intent(in) :: alpha2 Real variables integer(kind=c_int), intent(in) :: grid_type2 Integer variables real(kind=c_double), intent(out) :: prot (nx1*ny1,nvar) Real variables real(kind=c_double), intent(out) :: distortion (nepoch1) Real variables real(kind=c_double), intent(out) :: u_matrix (2*nx1-1,2*ny1-1) Real variables real(kind=c_double), intent(out) :: coords (nx1*ny1,3) Real variables integer(kind=c_int), intent(out) :: number_patterns (nx1,ny1) Integer variables integer(kind=c_int), intent(out) :: node_index (npat,3) Integer variables","tags":"","loc":"module\\two_level_self_organizing_map_utilities.html"},{"title":"constants_utilities – KohonenF08","text":"Uses precision_utilities module~~constants_utilities~~UsesGraph module~constants_utilities constants_utilities module~precision_utilities precision_utilities module~constants_utilities->module~precision_utilities iso_fortran_env iso_fortran_env module~precision_utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~constants_utilities~~UsedByGraph module~constants_utilities constants_utilities module~dataframe_utilities dataframe_utilities module~dataframe_utilities->module~constants_utilities module~kohonen_layer_parameters_utilities kohonen_layer_parameters_utilities module~kohonen_layer_parameters_utilities->module~constants_utilities module~kohonen_layer_utilities kohonen_layer_utilities module~kohonen_layer_utilities->module~constants_utilities module~kohonen_layer_utilities->module~kohonen_layer_parameters_utilities module~kohonen_pattern_utilities kohonen_pattern_utilities module~kohonen_layer_utilities->module~kohonen_pattern_utilities module~kohonen_prototype_utilities kohonen_prototype_utilities module~kohonen_layer_utilities->module~kohonen_prototype_utilities module~kohonen_map_base_utilities kohonen_map_base_utilities module~kohonen_layer_utilities->module~kohonen_map_base_utilities module~kohonen_pattern_utilities->module~constants_utilities module~kohonen_pattern_utilities->module~kohonen_prototype_utilities module~kohonen_prototype_utilities->module~constants_utilities module~logger_utilities logger_utilities module~logger_utilities->module~constants_utilities module~self_organizing_map_utilities self_organizing_map_utilities module~self_organizing_map_utilities->module~constants_utilities module~self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~self_organizing_map_utilities->module~kohonen_pattern_utilities module~self_organizing_map_utilities->module~kohonen_prototype_utilities module~self_organizing_map_utilities->module~kohonen_map_base_utilities module~som_predict_variables som_predict_variables module~som_predict_variables->module~constants_utilities module~som_predict_variables->module~kohonen_layer_parameters_utilities module~som_predict_variables->module~kohonen_pattern_utilities module~som_predict_variables->module~kohonen_prototype_utilities module~som_predict_variables->module~self_organizing_map_utilities module~som_predict_variables->module~kohonen_map_base_utilities module~som_train_variables som_train_variables module~som_train_variables->module~constants_utilities module~som_train_variables->module~kohonen_layer_parameters_utilities module~som_train_variables->module~kohonen_pattern_utilities module~som_train_variables->module~kohonen_prototype_utilities module~som_train_variables->module~logger_utilities module~som_train_variables->module~self_organizing_map_utilities module~som_train_variables->module~kohonen_map_base_utilities module~two_level_som_estimate_variables two_level_som_estimate_variables module~two_level_som_estimate_variables->module~constants_utilities module~two_level_som_estimate_variables->module~kohonen_layer_parameters_utilities module~two_level_som_estimate_variables->module~kohonen_pattern_utilities module~two_level_som_estimate_variables->module~kohonen_prototype_utilities module~two_level_som_estimate_variables->module~kohonen_map_base_utilities module~two_level_self_organizing_map_utilities two_level_self_organizing_map_utilities module~two_level_som_estimate_variables->module~two_level_self_organizing_map_utilities module~two_level_som_train_variables two_level_som_train_variables module~two_level_som_train_variables->module~constants_utilities module~two_level_som_train_variables->module~kohonen_layer_parameters_utilities module~two_level_som_train_variables->module~kohonen_pattern_utilities module~two_level_som_train_variables->module~kohonen_prototype_utilities module~two_level_som_train_variables->module~kohonen_map_base_utilities module~two_level_som_train_variables->module~two_level_self_organizing_map_utilities module~kohonen_map_base_utilities->module~kohonen_layer_parameters_utilities module~kohonen_map_base_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_layer_parameters_utilities module~two_level_self_organizing_map_utilities->module~kohonen_pattern_utilities module~two_level_self_organizing_map_utilities->module~kohonen_prototype_utilities module~two_level_self_organizing_map_utilities->module~kohonen_map_base_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: PI = 4.0_wp*atan(1.0_wp) real(kind=wp), public, parameter :: LN2 = log(2.0_wp) real(kind=wp), public, parameter :: PIEP = 4.0_EP*atan(1.0_EP) real(kind=wp), public, parameter :: INVPIEP = 0.25_EP/atan(1.0_EP) real(kind=wp), public, parameter :: TWOPIEP = 8.0_EP*atan(1.0_EP) real(kind=wp), public, parameter :: PIOV2EP = 2.0_EP*atan(1.0_EP) real(kind=EP), public, parameter :: PIOV4EP = atan(1.0_EP) complex(kind=wp), public, parameter :: EYE = (0.0_wp, 1.0_wp) complex(kind=wp), public, parameter :: I_ = (0.0_wp, 1.0_wp) real(kind=wp), public, parameter :: E = exp(1.0_EP) real(kind=wp), public, parameter :: SQRT2 = sqrt(2.0_EP) real(kind=wp), public, parameter :: UNEST = -999.999999_EP real(kind=wp), public, parameter :: EPSILON = 1.0d-10 real(kind=wp), public, parameter :: TOLERANCE = 1.0d-6 real(kind=wp), public, parameter :: DEG2RAD = PI/180.0_wp integer, public, parameter :: NUMCHAR = 128 integer, public, parameter :: MAXNST = 10","tags":"","loc":"module\\constants_utilities.html"},{"title":"kohonen_layer_base_utilities – KohonenF08","text":"","tags":"","loc":"module\\kohonen_layer_base_utilities.html"},{"title":"mt19937_64.f90 – KohonenF08","text":"This is a Fortran translation of the 64-bit version of\n   the Mersenne Twister pseudorandom number generator Before using, initialize the state by using\n       call init_genrand64(seed)\n   or\n       call init_by_array64(init_key) Translated from C-program for MT19937-64 (2004/9/29 version)\n   originally coded by Takuji Nishimura and Makoto Matsumoto\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html Fortran translation by Rémi Piatek\n   The University of Copenhagen\n   Department of Economics\n   email: {first}.{last}@econ.ku.dk A C-program for MT19937-64 (2004/9/29 version).\n   Coded by Takuji Nishimura and Makoto Matsumoto. This is a 64-bit version of Mersenne Twister pseudorandom number\n   generator. Before using, initialize the state by using init_genrand64(seed) or init_by_array64(init_key, key_length). Copyright (C) 2004, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved. Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met: 1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n 3. The names of its contributors may not be used to endorse or promote \n    products derived from this software without specific prior written \n    permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER\n   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. References:\n   T. Nishimura, Tables of 64-bit Mersenne Twisters''\n     ACM Transactions on Modeling and \n     Computer Simulation 10. (2000) 348--357.\n   M. Matsumoto and T. Nishimura, Mersenne Twister: a 623-dimensionally equidistributed\n       uniform pseudorandom number generator''\n     ACM Transactions on Modeling and \n     Computer Simulation 8. (Jan. 1998) 3--30. Any feedback is very welcome.\n   http://www.math.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove spaces) Files dependent on this one sourcefile~~mt19937_64.f90~~AfferentGraph sourcefile~mt19937_64.f90 mt19937_64.f90 sourcefile~random_number_generator_utilities.f90 random_number_generator_utilities.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~mt19937_64.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!------------------------------------------------------------------------------- !!   This is a Fortran translation of the 64-bit version of !!   the Mersenne Twister pseudorandom number generator !! !!   Before using, initialize the state by using !!       call init_genrand64(seed) !!   or !!       call init_by_array64(init_key) !! !!   Translated from C-program for MT19937-64 (2004/9/29 version) !!   originally coded by Takuji Nishimura and Makoto Matsumoto !!   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html !! !!   Fortran translation by Rémi Piatek !!   The University of Copenhagen !!   Department of Economics !!   email: {first}.{last}@econ.ku.dk !! !!------------------------------------------------------------------------------- !!   A C-program for MT19937-64 (2004/9/29 version). !!   Coded by Takuji Nishimura and Makoto Matsumoto. !! !!   This is a 64-bit version of Mersenne Twister pseudorandom number !!   generator. !! !!   Before using, initialize the state by using init_genrand64(seed) !!   or init_by_array64(init_key, key_length). !! !!   Copyright (C) 2004, Makoto Matsumoto and Takuji Nishimura, !!   All rights reserved. !! !!   Redistribution and use in source and binary forms, with or without !!   modification, are permitted provided that the following conditions !!   are met: !! !!     1. Redistributions of source code must retain the above copyright !!        notice, this list of conditions and the following disclaimer. !! !!     2. Redistributions in binary form must reproduce the above copyright !!        notice, this list of conditions and the following disclaimer in the !!        documentation and/or other materials provided with the distribution. !! !!     3. The names of its contributors may not be used to endorse or promote !!        products derived from this software without specific prior written !!        permission. !! !!   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS !!   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT !!   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR !!   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER !!   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, !!   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, !!   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR !!   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF !!   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING !!   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !!   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !! !!   References: !!   T. Nishimura, ``Tables of 64-bit Mersenne Twisters'' !!     ACM Transactions on Modeling and !!     Computer Simulation 10. (2000) 348--357. !!   M. Matsumoto and T. Nishimura, !!     ``Mersenne Twister: a 623-dimensionally equidistributed !!       uniform pseudorandom number generator'' !!     ACM Transactions on Modeling and !!     Computer Simulation 8. (Jan. 1998) 3--30. !! !!   Any feedback is very welcome. !!   http://www.math.hiroshima-u.ac.jp/~m-mat/MT/emt.html !!   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove spaces) !------------------------------------------------------------------------------- module mt19937_64 use , intrinsic :: iso_fortran_env implicit none private public :: init_genrand64 public :: init_by_array64 public :: genrand64_real1 public :: genrand64_real2 public :: genrand64_real3 !! NOTE: genrand64_int64 is kept private, as it generates different numbers !!       compared to the original C code. This is because the original C code !!       uses unsigned integers, while Fortran relies on signed integers. !!       This, however, has no impact on the generation of real numbers !!       (they are identical to those produced by the original C code). integer , parameter :: r64 = real64 integer , parameter :: i64 = int64 integer ( i64 ), parameter :: nn = 312_i64 integer ( i64 ), parameter :: mm = 156_i64 integer ( i64 ), parameter :: seed_def = 5489_i64 integer ( i64 ), parameter :: matrix_a = - 5403634167711393303_i64 integer ( i64 ), parameter :: um = - 2147483648_i64 ! most significant 33 bits integer ( i64 ), parameter :: lm = 2147483647_i64 ! least significant 31 bits real ( r64 ), parameter :: pi253_1 = 1._r64 / ( 2._r64 ** 53 - 1._r64 ) real ( r64 ), parameter :: pi253 = 1._r64 / ( 2._r64 ** 53 ) real ( r64 ), parameter :: pi252 = 1._r64 / ( 2._r64 ** 52 ) integer ( i64 ) :: mt ( nn ) ! array for the state vector integer :: mti = nn + 1 ! mti==nn+1 means mt(nn) is not initialized contains !----------------------------------------------------------------------------- ! Initializes mt(nn) with a seed subroutine init_genrand64 ( seed ) !! Initializes mt(nn) with a seed implicit none integer ( i64 ), intent ( in ) :: seed integer :: i mt ( 1 ) = seed do i = 1 , nn - 1 mt ( i + 1 ) = 6364136223846793005_i64 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 )) + i end do mti = nn end subroutine init_genrand64 !----------------------------------------------------------------------------- ! Initializes by an array with array-length !   init_key is the array for initializing keys subroutine init_by_array64 ( init_key ) !! Initializes by an array with array-length !!   init_key is the array for initializing keys implicit none integer ( i64 ), intent ( in ) :: init_key (:) integer ( i64 ), parameter :: c1 = 3935559000370003845_i64 integer ( i64 ), parameter :: c2 = 2862933555777941757_i64 integer ( i64 ) :: i , j , k , kk , key_length call init_genrand64 ( 19650218_i64 ) key_length = size ( init_key ) i = 1_i64 ; j = 0_i64 k = max ( nn , key_length ) do kk = 1 , k mt ( i + 1 ) = ieor ( mt ( i + 1 ), c1 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) & + init_key ( j + 1 ) + j i = i + 1 ; j = j + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if if ( j >= key_length ) j = 0 end do do kk = 1 , nn - 1 mt ( i + 1 ) = ieor ( mt ( i + 1 ), c2 * ieor ( mt ( i ), ishft ( mt ( i ), - 62 ))) - i i = i + 1 if ( i >= nn ) then mt ( 1 ) = mt ( nn ) i = 1 end if end do mt ( 1 ) = ishft ( 1_i64 , 63 ) ! MSB is 1; assuring non-zero initial array end subroutine init_by_array64 !----------------------------------------------------------------------------- ! Generates a random number on [-2&#94;63, 2&#94;63-1]-interval integer ( r64 ) function genrand64_int64 () !! Generates a random number on [-2&#94;63, 2&#94;63-1]-interval implicit none integer ( i64 ) :: mag01 ( 0 : 1 ) = ( / 0_i64 , matrix_a / ) integer ( i64 ) :: x integer :: i if ( mti >= nn ) then ! generate nn words at one time ! if init_genrand64() has not been called, a default initial seed is used if ( mti == nn + 1 ) call init_genrand64 ( seed_def ) do i = 1 , nn - mm x = ior ( iand ( mt ( i ), um ), iand ( mt ( i + 1 ), lm )) mt ( i ) = ieor ( ieor ( mt ( i + mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i64 ))) end do do i = nn - mm + 1 , nn - 1 x = ior ( iand ( mt ( i ), um ), iand ( mt ( i + 1 ), lm )) mt ( i ) = ieor ( ieor ( mt ( i + mm - nn ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i64 ))) end do x = ior ( iand ( mt ( nn ), um ), iand ( mt ( 1 ), lm )) mt ( nn ) = ieor ( ieor ( mt ( mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i64 ))) mti = 0 end if mti = mti + 1 x = mt ( mti ) x = ieor ( x , iand ( ishft ( x , - 29 ), 6148914691236517205_i64 )) x = ieor ( x , iand ( ishft ( x , 17 ), 8202884508482404352_i64 )) x = ieor ( x , iand ( ishft ( x , 37 ), - 2270628950310912_i64 )) x = ieor ( x , ishft ( x , - 43 )) genrand64_int64 = x end function genrand64_int64 !----------------------------------------------------------------------------- ! Generates a random number on [0,1]-real-interval real ( r64 ) function genrand64_real1 () !! Generates a random number on [0,1]-real-interval implicit none genrand64_real1 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253_1 end function genrand64_real1 !----------------------------------------------------------------------------- ! Generates a random number on [0,1)-real-interval real ( r64 ) function genrand64_real2 () !! Generates a random number on [0,1)-real-interval implicit none genrand64_real2 = real ( ishft ( genrand64_int64 (), - 11 ), kind = r64 ) * pi253 end function genrand64_real2 !----------------------------------------------------------------------------- ! Generates a random number on (0,1)-real-interval real ( r64 ) function genrand64_real3 () !! Generates a random number on (0,1)-real-interval implicit none genrand64_real3 = real ( ishft ( genrand64_int64 (), - 12 ), kind = r64 ) genrand64_real3 = ( genrand64_real3 + 0.5_r64 ) * pi252 end function genrand64_real3 end module mt19937_64","tags":"","loc":"sourcefile\\mt19937_64.f90.html"},{"title":"kohonen_prototype_utilities.f90 – KohonenF08","text":"This module defines a class for kohonen prototype (units inside kohonen layers) This file depends on sourcefile~~kohonen_prototype_utilities.f90~~EfferentGraph sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_prototype_utilities.f90~~AfferentGraph sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !!  This module defines a class for kohonen prototype (units inside kohonen layers) module kohonen_prototype_utilities ! use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use distance_base_utilities , only : distance_base ; ! implicit none ! private ; ! type kohonen_prototype !!   Class to store a prototype inside a Kohonen map private real ( kind = wp ), allocatable :: data_ (:,:) integer :: number_rows , number_columns contains ! procedure :: create => kohonen_prototype_constructor procedure :: destroy => kohonen_prototype_destructor procedure :: get_prototype => kohonen_prototype_accessor procedure :: set_prototype => kohonen_prototype_mutator procedure :: print => kohonen_prototype_print procedure :: distance => kohonen_prototype_distance procedure :: get_nrow => kohonen_prototype_nrow procedure :: get_ncol => kohonen_prototype_ncol ! end type kohonen_prototype ! public :: kohonen_prototype ; ! contains !======================================================================================== subroutine kohonen_prototype_constructor ( prototype , input_data ) !======================================================================================== !! Class Constructor class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object real ( kind = wp ), dimension (:,:) :: input_data !! A real array integer :: ierr character ( len = NUMCHAR ) :: message ! prototype % number_rows = size ( input_data , 1 ); prototype % number_columns = size ( input_data , 2 ); allocate ( prototype % data_ ( prototype % number_rows , prototype % number_columns ), stat = ierr ); prototype % data_ = input_data ; ! end subroutine kohonen_prototype_constructor !======================================================================================== subroutine kohonen_prototype_destructor ( prototype ) !======================================================================================== !! Class Destructor class ( kohonen_prototype ), intent ( inout ) :: prototype !! A `kohonen_prototype` object if ( allocated ( prototype % data_ )) then !           write(*,*) 'Prototype, ',allocated(prototype%data_),size(prototype%data_,1),size(prototype%data_,2) deallocate ( prototype % data_ ); !           write(*,*) 'Prototype release' endif end subroutine kohonen_prototype_destructor !======================================================================================== subroutine kohonen_prototype_accessor ( prototype , d ) !======================================================================================== !! Acccessor class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object real ( kind = wp ), dimension ( prototype % number_rows , prototype % number_columns ) :: d !! A real variable with the value of the prototype if ( allocated ( prototype % data_ )) then !           write(*,*) 'ACCESOR' d = prototype % data_ ; else stop endif ! end subroutine kohonen_prototype_accessor !======================================================================================== subroutine kohonen_prototype_mutator ( prototype , new_data ) !======================================================================================== !! Mutator class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: new_data ! if ( ( size ( new_data , 1 ) == prototype % number_rows ) . and . & ( size ( new_data , 2 ) == prototype % number_columns ) ) then prototype % data_ = new_data ; endif ! end subroutine kohonen_prototype_mutator !======================================================================================== subroutine kohonen_prototype_print ( prototype , unit_ ) !======================================================================================== !!  Function to print a kohonen prototype class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object integer , intent ( inout ), optional :: unit_ !! An integer variable with the number of the unit integer :: ix , iy ! if ( present ( unit_ )) then write ( unit_ , * ) 'Prototype' if ( size ( prototype % data_ , 2 ) /= 1 ) then do ix = 1 , size ( prototype % data_ , 1 ) write ( unit_ , * ) ( prototype % data_ ( ix , iy ), iy = 1 , size ( prototype % data_ , 2 )); enddo !ix else write ( unit_ , * ) ( prototype % data_ ( ix , 1 ), ix = 1 , size ( prototype % data_ , 1 )); endif else write ( * , * ) 'Prototype' , size ( prototype % data_ , 1 ), size ( prototype % data_ , 2 ); do ix = 1 , size ( prototype % data_ , 1 ) write ( * , * ) ( prototype % data_ ( ix , iy ), iy = 1 , size ( prototype % data_ , 2 )); enddo !ix endif ! end subroutine kohonen_prototype_print !======================================================================================== function kohonen_prototype_distance ( prototype , prototype1 , f ) result ( d ) !======================================================================================== !! Function to calculate the distance between two prototypes class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object type ( kohonen_prototype ) :: prototype1 !! A `kohonen_prototype` object class ( distance_base ), allocatable :: f !! real ( kind = wp ) :: d !! A real variable with the distance between prototypes real ( kind = wp ), dimension ( prototype % number_rows , prototype % number_columns ) :: prot1 , prot2 d = 0.0_wp ; call prototype % get_prototype ( prot1 ); call prototype1 % get_prototype ( prot2 ); d = f % calculate ( prot1 , prot2 ); ! end function kohonen_prototype_distance !======================================================================================== function kohonen_prototype_nrow ( prototype ) result ( nr ) !======================================================================================== !! Function to get the number of rows of the prototype class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object integer :: nr !! Integer variable with the number of rows nr = size ( prototype % data_ , 1 ); ! end function kohonen_prototype_nrow !======================================================================================== function kohonen_prototype_ncol ( prototype ) result ( nc ) !======================================================================================== !! Function to get the number of columns of the prototype class ( kohonen_prototype ) :: prototype !! A `kohonen_prototype` object integer :: nc !! Integer variable with the number of columns nc = size ( prototype % data_ , 2 ); ! end function kohonen_prototype_ncol ! end module kohonen_prototype_utilities","tags":"","loc":"sourcefile\\kohonen_prototype_utilities.f90.html"},{"title":"two_level_som_train_variables.f90 – KohonenF08","text":"This file depends on sourcefile~~two_level_som_train_variables.f90~~EfferentGraph sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module two_level_som_train_variables ! use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use kohonen_pattern_utilities , only : kohonen_pattern ; use two_level_self_organizing_map_utilities , only : two_level_self_organizing_map ; ! implicit none ; ! private ; ! type ( two_level_self_organizing_map ), save :: my_som type ( kohonen_layer_parameters ), dimension ( 2 ) :: som_parameters type ( kohonen_pattern ), allocatable :: input_patterns (:) integer :: ipattern character ( len = NUMCHAR ) :: parfl ! public :: train_two_level_som ; ! contains !============================================================================== subroutine initialize_variables ( par_file ) !============================================================================== character ( len =* ) :: par_file ! integer :: idata , ipattern , ivar , ierr , number_variables , i , j , ipar , train_option integer :: K , iprint , itoroidal , layer_ind real ( kind = wp ), allocatable :: var (:,:) logical :: testfl , testop character ( len = NUMCHAR ) :: current_line character ( len = NUMCHAR ) :: current_file character ( len = NUMCHAR ), allocatable :: pattern_files (:) ! idata = 1 ; ipar = 2 ; ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR: parameter file does not exist' endif open ( ipar , file = trim ( par_file ), status = 'unknown' , access = 'sequential' , action = 'read' ); write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'TWO_LEVEL_SOM_TRAIN_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo do while ( trim ( current_line ) . ne . 'LAYER1' ) read ( ipar , '(A)' ) current_line enddo write ( * , * ) write ( * , * ) 'LAYER 1: Reading parameters...' ; write ( * , * ) read ( ipar , * ) train_option write ( * , * ) 'Train option= ' , train_option som_parameters ( 1 )% train_option = train_option read ( ipar , '(A40)' ) som_parameters ( 1 )% pattern_file write ( * , * ) 'Pattern file= ' , trim ( som_parameters ( 1 )% pattern_file ) read ( ipar , * ) som_parameters ( 1 )% number_patterns ; write ( * , * ) 'Number patterns= ' , som_parameters ( 1 )% number_patterns ; read ( ipar , * ) som_parameters ( 1 )% number_variables1 !,& som_parameters ( 1 )% number_variables2 = 1 ; number_variables = som_parameters ( 1 )% number_variables1 * & som_parameters ( 1 )% number_variables2 ; som_parameters ( 1 )% number_variables = number_variables ; write ( * , * ) 'nvar1,nvar2,nvar= ' , som_parameters ( 1 )% number_variables1 ,& som_parameters ( 1 )% number_variables2 ,& number_variables ; allocate ( var ( som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 ), stat = ierr ); allocate ( som_parameters ( 1 )% column_var ( number_variables ), stat = ierr ); if ( train_option . eq . 0 ) then if ( number_variables . le . 10 ) then read ( ipar , * ) ( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); write ( * , * ) 'columns= ' ,( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); else read ( ipar , * ) write ( * , * ) 'WARNING: Assigning columns internally' do ivar = 1 , number_variables som_parameters ( 1 )% column_var ( ivar ) = ivar ; enddo endif else read ( ipar , * ) endif read ( ipar , '(A40)' ) som_parameters ( 1 )% som_type write ( * , * ) 'SOM type= ' , trim ( som_parameters ( 1 )% som_type ); read ( ipar , * ) som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz read ( ipar , * ) som_parameters ( 1 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 1 )% number_epochs read ( ipar , * ) som_parameters ( 1 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 1 )% learning_rate read ( ipar , * ) som_parameters ( 1 )% random_seed_ ( 1 ) write ( * , * ) 'random seed= ' , som_parameters ( 1 )% random_seed_ ( 1 ) read ( ipar , '(A40)' ) som_parameters ( 1 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 1 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 1 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 1 )% neighborhood_type ) read ( ipar , * ) som_parameters ( 1 )% debug_level write ( * , * ) 'debug level= ' , som_parameters ( 1 )% debug_level read ( ipar , '(A40)' ) som_parameters ( 1 )% debug_file write ( * , * ) 'debug file= ' , trim ( som_parameters ( 1 )% debug_file ); read ( ipar , '(A40)' ) som_parameters ( 1 )% output_file write ( * , * ) 'output file base= ' , trim ( som_parameters ( 1 )% output_file ) read ( ipar , * ) iprint som_parameters ( 1 )% view_flag = . FALSE . if ( iprint . eq . 1 ) som_parameters ( 1 )% view_flag = . TRUE .; write ( * , * ) 'Print Training Results= ' , iprint read ( ipar , * ) itoroidal som_parameters ( 1 )% toroidal_grid = . FALSE .; if ( itoroidal . eq . 1 ) som_parameters ( 1 )% toroidal_grid = . TRUE .; write ( * , * ) 'Toroidal grid= ' , itoroidal write ( * , * ) write ( * , * ) 'LAYER 1: Reading parameters...finished' ; write ( * , * ) current_line = '' ; do while ( trim ( current_line ) . ne . 'LAYER2' ) read ( ipar , '(A)' ) current_line enddo write ( * , * ) write ( * , * ) 'LAYER 2: Reading parameters...' ; write ( * , * ) read ( ipar , * ) som_parameters ( 2 )% number_nodes_nx ,& som_parameters ( 2 )% number_nodes_ny ,& som_parameters ( 2 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 2 )% number_nodes_nx ,& som_parameters ( 2 )% number_nodes_ny ,& som_parameters ( 2 )% number_nodes_nz read ( ipar , * ) som_parameters ( 2 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 2 )% number_epochs read ( ipar , * ) som_parameters ( 2 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 2 )% learning_rate read ( ipar , * ) som_parameters ( 2 )% random_seed_ write ( * , * ) 'random seed= ' , som_parameters ( 2 )% random_seed_ read ( ipar , '(A40)' ) som_parameters ( 2 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 2 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 2 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 2 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 2 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 2 )% neighborhood_type ) write ( * , * ) write ( * , * ) 'LAYER 2: Reading parameters...finished' ; write ( * , * ) ! ! ! write ( * , * ) 'Reading parameter file...finished' close ( ipar ); inquire ( file = trim ( som_parameters ( 1 )% pattern_file ), exist = testfl ) if (. not . testfl ) then stop 'ERROR: input file does not exist' endif ! ! Assigning units to output files ! som_parameters ( 1 )% idbg = 10 ; som_parameters ( 1 )% iout = 11 ; som_parameters ( 1 )% iindex = 12 ; som_parameters ( 1 )% iprot = 13 ; som_parameters ( 1 )% ihit = 14 ; som_parameters ( 1 )% idist = 15 ; som_parameters ( 1 )% iumat = 16 ; som_parameters ( 1 )% ipar = 17 ; som_parameters ( 1 )% isam = 18 ; som_parameters ( 1 )% iclus = 19 ; som_parameters ( 1 )% icen = 20 ; som_parameters ( 1 )% iclus1 = 21 ; !   som_parameters(1)%view_flag=.TRUE.; ! !   K=1; !   call random_seed(size=K); !   call random_seed(put=som_parameters(1)%random_seed_(1:K)); ! allocate ( input_patterns ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( train_option . eq . 0 ) then ! write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' ); do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' elseif ( train_option . eq . 1 ) then allocate ( pattern_files ( som_parameters ( 1 )% number_patterns ), stat = ierr ); write ( * , * ) 'Reading pattern files...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' ); do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , '(A)' , err = 90 ) pattern_files ( ipattern ); enddo !ipattern write ( * , * ) 'Reading pattern files...finished!' ; ! write ( * , * ) 'Reading patterns...' ; do ipattern = 1 , som_parameters ( 1 )% number_patterns inquire ( file = trim ( pattern_files ( ipattern )), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the file ' , trim ( pattern_files ( ipattern )), ' does not exist' stop endif if ( som_parameters ( 1 )% view_flag ) then write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )); endif open ( idata , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' , access = 'sequential' ); do i = 1 , size ( var , 1 ) read ( idata , * , err = 91 ) ( var ( i , j ), j = 1 , size ( var , 2 )); enddo !ix close ( idata ); if ( som_parameters ( 1 )% view_flag ) then write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )), ' finished' ; endif call input_patterns ( ipattern )% create ( var ); enddo !ipattern write ( * , * ) 'Reading patterns...finished!' ; endif ! if ( som_parameters ( 1 )% debug_level . gt . 0 ) then open ( som_parameters ( 1 )% idbg , file = trim ( som_parameters ( 1 )% debug_file ),& status = 'unknown' , access = 'sequential' , action = 'write' ); endif ! write ( * , * ) 'Opening output files...' ; ! parameter file current_file = trim ( som_parameters ( 1 )% output_file ) // '_parameters.som' ; open ( som_parameters ( 1 )% ipar , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ) layer_ind = 1 ; call som_parameters ( 1 )% print ( layer_ind , som_parameters ( 1 )% ipar ); ! som_parameters ( 2 )% output_file = 'NOFILE' ; som_parameters ( 2 )% pattern_file = 'NOFILE' ; som_parameters ( 2 )% debug_file = 'NOFILE' ; som_parameters ( 2 )% som_type = 'NOTYPE' ; ! layer_ind = 2 ; call som_parameters ( 2 )% print ( layer_ind , som_parameters ( 1 )% ipar ); close ( som_parameters ( 1 )% ipar ) ! neuron indices current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out' ; open ( som_parameters ( 1 )% iindex , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); !    write(som_parameters(1)%iindex,'(A)') 'KOHONEN MAP PATTERN INDICES' !    write(som_parameters(1)%iindex,'(A17,1X,2I6)') 'Number Patterns= ',& !          som_parameters(1)%number_patterns,3; write ( som_parameters ( 1 )% iindex , '(A22)' ) 'PatternNumber ix iy iz' ! neuron prototypes current_file = trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out' ; open ( som_parameters ( 1 )% iprot , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% iprot , '(A)' ) 'KOHONEN MAP PROTOTYPES' write ( som_parameters ( 1 )% iprot , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( som_parameters ( 1 )% iprot , '(A21,1X,2I6)' ) 'number of variables= ' ,& som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 !rectangular !hexagonal write ( som_parameters ( 1 )% iprot , '(A25,1X,A11,1X,L4)' ) 'node_type,toroidal_grid= ' ,& trim ( som_parameters ( 1 )% node_type ), som_parameters ( 1 )% toroidal_grid ! neuron hit current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_hit.out' ; open ( som_parameters ( 1 )% ihit , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% ihit , '(A)' ) 'KOHONEN MAP NEURON HITS' write ( som_parameters ( 1 )% ihit , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! neuron distances current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out' ; open ( som_parameters ( 1 )% idist , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% idist , '(A)' ) 'KOHONEN MAP DISTANCE MATRIX' write ( som_parameters ( 1 )% idist , '(A17,1X,2I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ! u-matrix current_file = trim ( som_parameters ( 1 )% output_file ) // '_u-matrix.out' ; open ( som_parameters ( 1 )% iumat , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% iumat , '(A)' ) 'KOHONEN MAP U-MATRIX' write ( som_parameters ( 1 )% iumat , '(A17,1X,3I6)' ) 'number of nodes= ' ,& 2 * som_parameters ( 1 )% number_nodes_nx - 1 ,& 2 * som_parameters ( 1 )% number_nodes_ny - 1 ,& 2 * som_parameters ( 1 )% number_nodes_nz - 1 ! current_file = trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out' ; open ( som_parameters ( 1 )% isam , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% isam , '(A)' ) 'KOHONEN MAP SAMPLE LOCATION' write ( som_parameters ( 1 )% isam , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! current_file = trim ( som_parameters ( 1 )% output_file ) // '_clusters.out' ; open ( som_parameters ( 1 )% iclus , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% iclus , '(A)' ) 'KOHONEN MAP CLUSTERS' write ( som_parameters ( 1 )% iclus , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! current_file = trim ( som_parameters ( 1 )% output_file ) // '_cluster_centers.out' ; open ( som_parameters ( 1 )% icen , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% icen , '(A)' ) 'KOHONEN MAP CLUSTER CENTERS' write ( som_parameters ( 1 )% icen , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( som_parameters ( 2 )% iprot , '(A21,1X,2I6)' ) 'number of variables= ' ,& som_parameters ( 2 )% number_variables1 , som_parameters ( 2 )% number_variables2 ! current_file = trim ( som_parameters ( 1 )% output_file ) // '_cluster_samples.out' ; open ( som_parameters ( 1 )% iclus1 , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); write ( som_parameters ( 1 )% iclus1 , '(A)' ) 'KOHONEN MAP CLUSTER SAMPLES' !   write(som_parameters(1)%icen,'(A17,1X,3I6)') 'number of nodes= ',& !        som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !        som_parameters(1)%number_nodes_nz write ( som_parameters ( 1 )% iclus1 , '(2I6)' ) som_parameters ( 1 )% number_patterns , 5 ! write ( * , * ) 'Opening output files...finished!!!' ; ! deallocate ( var ); ! return ; ! 90 stop 'ERROR while reading pattern file' 91 stop 'ERROR while reading pattern sample file' ! end subroutine initialize_variables !============================================================================== subroutine release_variables () !============================================================================== integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( som_parameters ( 1 )% column_var )) then deallocate ( som_parameters ( 1 )% column_var ) endif ! inquire ( unit = som_parameters ( 1 )% iindex , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iindex ); endif ! inquire ( unit = som_parameters ( 1 )% iprot , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iprot ); endif ! inquire ( unit = som_parameters ( 1 )% ihit , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% ihit ); endif ! inquire ( unit = som_parameters ( 1 )% idist , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idist ); endif ! inquire ( unit = som_parameters ( 1 )% iumat , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iumat ); endif ! inquire ( unit = som_parameters ( 1 )% isam , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% isam ); endif ! inquire ( unit = som_parameters ( 1 )% iclus , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iclus ); endif ! inquire ( unit = som_parameters ( 1 )% icen , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% icen ); endif ! inquire ( unit = som_parameters ( 1 )% iclus1 , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iclus1 ); endif ! inquire ( file = trim ( som_parameters ( 1 )% debug_file ), opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idbg ); endif ! end subroutine release_variables !============================================================================== subroutine train_two_level_som ( parameter_file ) !============================================================================== character ( len =* ), intent ( inout ) :: parameter_file ! call initialize_variables ( parameter_file ); ! call my_som % create ( som_parameters ); ! call my_som % train ( input_patterns ); ! if ( som_parameters ( 1 )% train_option == 0 ) then call my_som % calculate_sum2_clusters_grid (); endif ! call my_som % destroy (); ! call release_variables (); end subroutine train_two_level_som ! end module two_level_som_train_variables","tags":"","loc":"sourcefile\\two_level_som_train_variables.f90.html"},{"title":"kohonen_layer_utilities.f90 – KohonenF08","text":"This module defines a class that represents a layer in a self-organizing map This file depends on sourcefile~~kohonen_layer_utilities.f90~~EfferentGraph sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/05/2025 !! version: 0.1 !! This module defines a class that represents a layer in a self-organizing map module kohonen_layer_utilities !! This module defines a class that represents a layer in a self-organizing map use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use random_generator_base_utilities , only : random_generator_base ; use rkiss05_generator_utilities , only : rkiss05_generator ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use kohonen_pattern_utilities , only : kohonen_pattern ; use distance_base_utilities , only : distance_base ; use factory_distance_utilities , only : factory_distance ; !use influence_function_utilities; use quicksort_utilities , only : quicksort ; ! implicit none ; ! end module kohonen_layer_utilities","tags":"","loc":"sourcefile\\kohonen_layer_utilities.f90.html"},{"title":"general_utilities.f90 – KohonenF08","text":"This module includes general purpose functions used in several parts of the library This file depends on sourcefile~~general_utilities.f90~~EfferentGraph sourcefile~general_utilities.f90 general_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~general_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module includes general purpose functions used in several parts of the library module general_utilities !! This module includes general purpose functions used in several parts of the library use precision_utilities , only : wp ; ! implicit none ; ! private ! interface maximum module procedure maximum_only , maximum_position end interface ! public :: minimum , maximum , mean , variance , std public :: coefficient_of_variation ! contains !=================================================================================================== function minimum ( a ) result ( mn ) !=================================================================================================== !! Function to calculate the minimum of an array real ( kind = wp ), dimension (:) :: a !! Real array real ( kind = wp ) :: mn !! Real value with the minimum integer :: i , number_elements mn = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . lt . mn ) then mn = a ( i ) endif enddo ! end function minimum !=================================================================================================== subroutine maximum_only ( a , mx ) !=================================================================================================== !! Subroutine to calculate the maximum of a real array real ( kind = wp ), dimension (:) :: a !! real ( kind = wp ) :: mx !! integer :: i , number_elements mx = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . gt . mx ) then mx = a ( i ) endif enddo ! end subroutine maximum_only !============================================================================================= subroutine maximum_position ( a , mx , p ) !============================================================================================= !! Subroutine to find the position of the maximum value of a real array real ( kind = wp ), dimension (:) :: a !! A real array real ( kind = wp ) :: mx !! A real value with the maximum integer :: p !! An integer value with the position of the maximum integer :: i , number_elements mx = a ( 1 ) number_elements = size ( a ) do i = 2 , number_elements if ( a ( i ) . gt . mx ) then mx = a ( i ); p = i ; endif enddo ! end subroutine maximum_position !============================================================================================= function mean ( a ) result ( mn ) !============================================================================================= !! Function to calculate the mean of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: mn !! A real value with the calculated mean mn = sum ( a ) / float ( size ( a )); ! end function mean !============================================================================================= function variance ( a ) result ( v ) !============================================================================================= !! Function to calculate the variance of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: v !! A real variable with the calculated variance real ( kind = wp ), dimension ( size ( a )) :: a2 ! a2 = a ** 2 ; v = mean ( a2 ) - ( mean ( a )) ** 2 ; ! end function variance !============================================================================================= function std ( a ) result ( s ) !============================================================================================= !! Function to calculate the standard deviation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: s !! A real variable with the calculated standard deviation real ( kind = wp ) :: v ! v = variance ( a ); s = sqrt ( v ); ! end function std !============================================================================================ function coefficient_of_variation ( a ) result ( cov ) !============================================================================================ !! Function to calculate the coefficient of variation of a real array real ( kind = wp ), dimension (:), intent ( inout ) :: a !! A real array real ( kind = wp ) :: cov !! A real variable with the calculated coefficient of variation cov = std ( a ) / mean ( a ); end function coefficient_of_variation ! end module general_utilities","tags":"","loc":"sourcefile\\general_utilities.f90.html"},{"title":"som_train_variables.f90 – KohonenF08","text":"This module defines the variables for the program som_train This file depends on sourcefile~~som_train_variables.f90~~EfferentGraph sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/12/2025 !! version: 0.1 !! This module defines the variables for the program som_train module som_train_variables !! This module defines the variables for the program som_train use error_handling , only : error_stop , error_t ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use logger_utilities , only : global_logger ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use self_organizing_map_utilities , only : self_organizing_map ; use kohonen_pattern_utilities , only : kohonen_pattern ; ! implicit none ; ! private ; ! type ( self_organizing_map ), save :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: som_parameters type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), allocatable :: distance_matrix (:,:) integer :: ipattern character ( len = NUMCHAR ) :: parfl ! public :: train_som ; ! contains ! ! Outputs: !  - neuron indices for each input pattern !  - neuron prototypes !  - neuron hit count !  - distance matrix between neuron prototypes (for clustering) !  - u-matrix ! !============================================================================== subroutine initialize_variables ( par_file ) !============================================================================== !! Subroutine that initilizes the variables of the som_train program character ( len =* ) :: par_file !! A character variable with the name of the parameter_file ! integer :: idata , ipattern , ivar , ierr , number_variables , i , j , ipar , toroidal integer :: layer_ind , ferr real ( kind = wp ), allocatable :: var (:,:) logical :: testfl , testop character ( len = NUMCHAR ) :: current_line character ( len = NUMCHAR ) :: current_file !integer,allocatable :: column_var(:) character ( len = NUMCHAR ), allocatable :: pattern_files (:) character ( len = NUMCHAR ) :: base_message , message ! idata = 1 ; ipar = 2 ; base_message = \"SOM_TRAIN_VARIABLES ERROR\" ; call global_logger % create (); call global_logger % startup ( 'som_train.log' , append_ = . false .); write ( * , * ) 'logger initialized= ' , global_logger % is_initialized (); call global_logger % configure ( 'timestamp' ,. true .); call global_logger % delimiter ( 'volume' ); call global_logger % message ( 'SOM_TRAIN program started' ); ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then message = trim ( base_message ) // \"The parameter file does not exist\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif open ( ipar , file = trim ( par_file ), status = 'unknown' , access = 'sequential' ,& action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \"while opening \" // trim ( par_file ) // \" file\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif call global_logger % message ( 'Start to read parameter file' ); write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'SOM_TRAIN_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo read ( ipar , * ) som_parameters ( 1 )% train_option write ( * , * ) 'Train option= ' , som_parameters ( 1 )% train_option read ( ipar , '(A40)' ) som_parameters ( 1 )% pattern_file write ( * , * ) 'Pattern file= ' , trim ( som_parameters ( 1 )% pattern_file ) read ( ipar , * ) som_parameters ( 1 )% number_patterns ; write ( * , * ) 'Number patterns= ' , som_parameters ( 1 )% number_patterns ; read ( ipar , * ) som_parameters ( 1 )% number_variables1 som_parameters ( 1 )% number_variables2 = 1 ; number_variables = som_parameters ( 1 )% number_variables1 * & som_parameters ( 1 )% number_variables2 ; som_parameters ( 1 )% number_variables = number_variables ; write ( * , * ) 'nvar= ' , som_parameters ( 1 )% number_variables ; allocate ( var ( som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for var array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif allocate ( som_parameters ( 1 )% column_var ( number_variables ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for column_var array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif if ( som_parameters ( 1 )% train_option . eq . 0 ) then if ( number_variables . le . 10 ) then read ( ipar , * ) ( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); write ( * , * ) 'columns= ' ,( som_parameters ( 1 )% column_var ( ivar ), ivar = 1 , number_variables ); else read ( ipar , * ) write ( * , * ) 'Columns read' do ivar = 1 , number_variables som_parameters ( 1 )% column_var ( ivar ) = ivar ; enddo write ( * , * ) som_parameters ( 1 )% column_var ( 1 : number_variables ); endif else read ( ipar , * ) endif read ( ipar , '(A40)' ) som_parameters ( 1 )% som_type write ( * , * ) 'SOM type= ' , trim ( som_parameters ( 1 )% som_type ); read ( ipar , * ) som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz read ( ipar , * ) som_parameters ( 1 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 1 )% number_epochs read ( ipar , * ) som_parameters ( 1 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 1 )% learning_rate read ( ipar , * ) som_parameters ( 1 )% random_seed_ write ( * , * ) 'random seed= ' , som_parameters ( 1 )% random_seed_ read ( ipar , '(A40)' ) som_parameters ( 1 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 1 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 1 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 1 )% neighborhood_type ) read ( ipar , * ) som_parameters ( 1 )% debug_level write ( * , * ) 'debug level= ' , som_parameters ( 1 )% debug_level read ( ipar , '(A40)' ) som_parameters ( 1 )% debug_file write ( * , * ) 'debug file= ' , trim ( som_parameters ( 1 )% debug_file ); read ( ipar , '(A40)' ) som_parameters ( 1 )% output_file write ( * , * ) 'output file base= ' , trim ( som_parameters ( 1 )% output_file ) read ( ipar , * ) toroidal write ( * , * ) 'Toroidal grid= ' , toroidal if ( toroidal . eq . 1 ) then som_parameters ( 1 )% toroidal_grid = . true .; else som_parameters ( 1 )% toroidal_grid = . false .; endif write ( * , * ) 'Reading parameter file...finished' close ( ipar ); call global_logger % message ( 'Reading parameter file finished' ); ! inquire ( file = trim ( som_parameters ( 1 )% pattern_file ), exist = testfl ) if (. not . testfl ) then message = trim ( base_message ) // 'the file ' // trim ( som_parameters ( 1 )% pattern_file ) // ' does not exist' ; !call global_logger%message(message); !call global_logger%delimiter('volume'); call error_stop ( message ); endif ! som_parameters ( 1 )% idbg = 10 ; !debugging som_parameters ( 1 )% iout = 11 ; !output som_parameters ( 1 )% iindex = 12 ; !SOM output by index som_parameters ( 1 )% iprot = 13 ; !SOM prototpyes som_parameters ( 1 )% ihit = 14 ; !SOM neuron_hit som_parameters ( 1 )% idist = 15 ; !neuron_distances som_parameters ( 1 )% iumat = 16 ; ! umatrix som_parameters ( 1 )% ipar = 17 ; som_parameters ( 1 )% isam = 18 ; ! som_parameters ( 1 )% idisto = 19 ; !save distortion ! !   call random_seed ! allocate ( input_patterns ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for input_patterns array\" ; !call global_logger%message(message); !call global_logger%delimiter('volume'); call error_stop ( message ); endif if ( som_parameters ( 1 )% train_option . eq . 0 ) then ! call global_logger % message ( 'Reading patterns' ); write ( * , * ) 'Reading patterns...' ; open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // \" file\" ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' ; call global_logger % message ( 'Reading patterns finished' ); elseif ( som_parameters ( 1 )% train_option . eq . 1 ) then allocate ( pattern_files ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for pattern_files array\" ; call error_stop ( message ); endif call global_logger % message ( 'Reading pattern files' ); write ( * , * ) 'Reading pattern files...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // \" file\" ; call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , '(A)' , err = 90 ) pattern_files ( ipattern ); enddo !ipattern write ( * , * ) 'Reading pattern files...finished!' ; call global_logger % message ( 'Reading pattern files finished' ); ! call global_logger % message ( 'Reading patterns' ); write ( * , * ) 'Reading patterns...' ; do ipattern = 1 , som_parameters ( 1 )% number_patterns inquire ( file = trim ( pattern_files ( ipattern )), exist = testfl ); if (. not . testfl ) then message = trim ( base_message ) // \"the file \" // trim ( pattern_files ( ipattern )) // ' does not exist' ; call error_stop ( message ); endif write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )); call global_logger % message ( 'Currently reading ' // trim ( pattern_files ( ipattern ))); open ( idata , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' ,& access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( pattern_files ( ipattern )) // ' file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif do i = 1 , size ( var , 1 ) read ( idata , * , err = 91 ) ( var ( i , j ), j = 1 , size ( var , 2 )); enddo !ix close ( idata ); write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )), ' finished' ; call global_logger % message ( 'Currently reading ' // trim ( pattern_files ( ipattern )) // ' finished' ); call input_patterns ( ipattern )% create ( var ); enddo !ipattern write ( * , * ) 'Reading patterns...finished!' ; call global_logger % message ( 'Reading patterns finished!' ); call global_logger % delimiter ( 'volume' ); ! elseif ( som_parameters ( 1 )% train_option . eq . 2 ) then write ( * , * ) 'Reading patterns...' ; call global_logger % message ( 'Reading patterns...' ); open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // ' file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' ; call global_logger % message ( 'Reading patterns...OK!!!' ); ! write ( * , * ) 'Reading distance matrix....' ; allocate ( distance_matrix ( som_parameters ( 1 )% number_patterns , som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // \"while allocating memory for distance_matrix array\" ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% pattern_file ) // ' file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif do i = 1 , som_parameters ( 1 )% number_patterns read ( idata , * ) ( distance_matrix ( i , j ), j = 1 , som_parameters ( 1 )% number_patterns ); enddo write ( * , * ) 'Reading distance matrix....finished!' ; call global_logger % message ( 'Reading distance matrix....finished!' ); endif ! if ( som_parameters ( 1 )% debug_level . gt . 0 ) then open ( som_parameters ( 1 )% idbg , file = trim ( som_parameters ( 1 )% debug_file ),& status = 'unknown' , access = 'sequential' , action = 'write' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% debug_file ) // ' file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif endif ! if ( som_parameters ( 1 )% train_option < 3 ) then write ( * , * ) 'Opening output files...' ; ! parameter file current_file = trim ( som_parameters ( 1 )% output_file ) // '_parameters.som' ; open ( som_parameters ( 1 )% ipar , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_parameter.som file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif layer_ind = 1 ; call som_parameters ( 1 )% print ( layer_ind , som_parameters ( 1 )% ipar ); close ( som_parameters ( 1 )% ipar ) ! neuron indices current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out' ; open ( som_parameters ( 1 )% iindex , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_indices.out file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif !   write(som_parameters(1)%iindex,'(A)') 'KOHONEN MAP PATTERN INDICES' !   write(som_parameters(1)%iindex,'(A17,1X,2I6)') 'Number Patterns= ',& !         som_parameters(1)%number_patterns,3; write ( som_parameters ( 1 )% iindex , '(A22)' ) 'PatternNumber ix iy iz' ! neuron prototypes current_file = trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out' ; open ( som_parameters ( 1 )% iprot , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_prototypes.out file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif write ( som_parameters ( 1 )% iprot , '(A)' ) 'KOHONEN MAP PROTOTYPES' write ( som_parameters ( 1 )% iprot , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( som_parameters ( 1 )% iprot , '(A21,1X,2I6)' ) 'number of variables= ' ,& som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 !rectangular !hexagonal write ( som_parameters ( 1 )% iprot , '(A25,1X,A11,1X,L4)' ) 'node_type,toroidal_grid= ' ,& trim ( som_parameters ( 1 )% node_type ), som_parameters ( 1 )% toroidal_grid ! neuron hit current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_hit.out' ; open ( som_parameters ( 1 )% ihit , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_hits.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% ihit , '(A)' ) 'KOHONEN MAP NEURON HITS' write ( som_parameters ( 1 )% ihit , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! neuron distances current_file = trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out' ; open ( som_parameters ( 1 )% idist , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_neuron_distances.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% idist , '(A)' ) 'KOHONEN MAP DISTANCE MATRIX' write ( som_parameters ( 1 )% idist , '(A17,1X,2I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ,& som_parameters ( 1 )% number_nodes_nx * som_parameters ( 1 )% number_nodes_ny * & som_parameters ( 1 )% number_nodes_nz ! u-matrix current_file = trim ( som_parameters ( 1 )% output_file ) // '_u-matrix.out' ; open ( som_parameters ( 1 )% iumat , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_u_matrix.out file' ; call global_logger % message ( message ); call global_logger % delimiter ( 'volume' ); call error_stop ( message ); endif write ( som_parameters ( 1 )% iumat , '(A)' ) 'KOHONEN MAP U-MATRIX' write ( som_parameters ( 1 )% iumat , '(A17,1X,3I6)' ) 'number of nodes= ' ,& 2 * som_parameters ( 1 )% number_nodes_nx - 1 , 2 * som_parameters ( 1 )% number_nodes_ny - 1 ,& 2 * som_parameters ( 1 )% number_nodes_nz - 1 ! map_samples current_file = trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out' ; open ( som_parameters ( 1 )% isam , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_map_samples.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% isam , '(A)' ) 'KOHONEN MAP SAMPLE LOCATION' write ( som_parameters ( 1 )% isam , '(A17,1X,3I6)' ) 'number of nodes= ' ,& som_parameters ( 1 )% number_nodes_nx , som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz ! SOM distortion current_file = trim ( som_parameters ( 1 )% output_file ) // '_distortion.out' ; open ( som_parameters ( 1 )% idisto , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' , iostat = ferr ); if ( ferr /= 0 ) then message = trim ( base_message ) // \" while opening the \" // trim ( som_parameters ( 1 )% output_file ) // '_distortion.out file' ; call error_stop ( message ); endif write ( som_parameters ( 1 )% idisto , '(A)' ) 'KOHONEN MAP DISTORTION' ! write ( * , * ) 'Opening output files...finished!!!' ; endif ! deallocate ( var ); return ! 90 stop 'ERROR while reading pattern file' 91 stop 'ERROR while reading pattern sample file' ! end subroutine initialize_variables !============================================================================== subroutine release_variables () !============================================================================== !! Subroutine used to deallocate all the memory used in the initialization of the !! variables used in the som_train program integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( distance_matrix )) then deallocate ( distance_matrix ); endif ! if ( allocated ( som_parameters ( 1 )% column_var )) then deallocate ( som_parameters ( 1 )% column_var ) endif ! inquire ( unit = som_parameters ( 1 )% iindex , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iindex ); endif ! inquire ( unit = som_parameters ( 1 )% iprot , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iprot ); endif ! inquire ( unit = som_parameters ( 1 )% ihit , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% ihit ); endif ! inquire ( unit = som_parameters ( 1 )% idist , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idist ); endif ! inquire ( unit = som_parameters ( 1 )% iumat , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iumat ); endif ! inquire ( unit = som_parameters ( 1 )% isam , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% isam ); endif ! inquire ( file = trim ( som_parameters ( 1 )% debug_file ), opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idbg ); endif ! inquire ( unit = som_parameters ( 1 )% idisto , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% idisto ); endif ! call global_logger % shutdown (); call global_logger % destroy (); ! end subroutine release_variables !============================================================================== subroutine train_som ( parameter_file ) !============================================================================== !! Subroutine to train the SOM character ( len =* ), intent ( inout ) :: parameter_file !! A character variable with the name of the parameter file call initialize_variables ( parameter_file ); ! call my_som % create ( som_parameters ); ! call my_som % train ( input_patterns ); ! call my_som % destroy (); ! call release_variables (); ! end subroutine train_som ! end module som_train_variables","tags":"","loc":"sourcefile\\som_train_variables.f90.html"},{"title":"som_predict_variables.f90 – KohonenF08","text":"This file depends on sourcefile~~som_predict_variables.f90~~EfferentGraph sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module som_predict_variables ! use error_handling , only : error_stop , error_t ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use self_organizing_map_utilities , only : self_organizing_map ; use kohonen_pattern_utilities , only : kohonen_pattern ; ! implicit none ! type ( self_organizing_map ), save :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: som_parameters type ( kohonen_pattern ), allocatable :: input_patterns (:) integer , allocatable :: map_output (:,:) character ( len = NUMCHAR ) :: parfl , som_parameter_file , prototype_file ! contains ! subroutine initialize_variables ( par_file ) ! character ( len =* ) :: par_file ! logical :: testfl integer :: ipar , ipat , isom , iout , ierr , number_patterns , train_option integer :: ipattern , nvar1 , nvar2 , ivar , i , j character ( len = NUMCHAR ) :: input_file , output_file , current_line character ( len = NUMCHAR ) :: current_file real ( kind = wp ), allocatable :: var (:,:) character ( len = NUMCHAR ), allocatable :: pattern_files (:) ! ipar = 1 ; ipat = 2 ; isom = 3 ; ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR: the som predict parameter file does not exist' endif open ( ipar , file = trim ( par_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'SOM_PREDICT_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo read ( ipar , * , err = 90 ) train_option read ( ipar , '(A40)' , err = 90 ) som_parameter_file read ( ipar , '(A40)' , err = 90 ) prototype_file read ( ipar , '(A40)' , err = 90 ) input_file read ( ipar , * , err = 90 ) number_patterns read ( ipar , * , err = 90 ) nvar1 , nvar2 read ( ipar , '(A40)' , err = 90 ) output_file close ( ipar ); write ( * , * ) 'Reading parameter file...finished!' ! inquire ( file = trim ( som_parameter_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the som parameter file does not exist' ; endif write ( * , * ) 'Reading SOM parameter file...' ; open ( isom , file = trim ( som_parameter_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); call som_parameters ( 1 )% read_parameters ( isom ); close ( isom ); write ( * , * ) 'Reading SOM parameter file...OK!' ; ! som_parameters ( 1 )% idbg = 10 ; som_parameters ( 1 )% iout = 11 ; som_parameters ( 1 )% iindex = 12 ; som_parameters ( 1 )% iprot = 13 ; som_parameters ( 1 )% ihit = 14 ; som_parameters ( 1 )% idist = 15 ; som_parameters ( 1 )% iumat = 16 ; som_parameters ( 1 )% ipar = 17 ; ! inquire ( file = trim ( prototype_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the prototype file does not exist' ; endif allocate ( input_patterns ( number_patterns ), stat = ierr ); allocate ( map_output ( number_patterns , 3 ), stat = ierr ); allocate ( var ( nvar1 , nvar2 ), stat = ierr ); ! if ( train_option . eq . 0 ) then write ( * , * ) 'Reading input file...' ; inquire ( file = trim ( input_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the input pattern file does not exist' ; endif open ( ipat , file = trim ( input_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); do ipattern = 1 , number_patterns read ( ipat , * , err = 91 ) ( var ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ) call input_patterns ( ipattern )% create ( var ); enddo !ipatterh close ( ipar ) write ( * , * ) 'Reading input file...finished!' ; elseif ( train_option . eq . 1 ) then allocate ( pattern_files ( number_patterns ), stat = ierr ); write ( * , * ) 'Reading input file names...' ; inquire ( file = trim ( input_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR the input pattern file with names does not exist' ; endif open ( ipar , file = trim ( input_file ), status = 'unknown' , action = 'read' , access = 'sequential' ); do ipattern = 1 , number_patterns read ( ipar , '(A)' , err = 91 ) pattern_files ( ipattern ); enddo close ( ipar ); ! do ipattern = 1 , number_patterns open ( ipat , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' , access = 'sequential' ); do i = 1 , nvar1 read ( ipat , * , err = 92 ) ( var ( i , j ), j = 1 , nvar2 ); enddo close ( ipat ); enddo write ( * , * ) 'Reading input file names...finished!' ; endif ! current_file = trim ( output_file ); open ( som_parameters ( 1 )% iout , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); ! deallocate ( var ); if ( allocated ( pattern_files )) deallocate ( pattern_files ) ! return 90 stop 'ERROR while reading parameter file' 91 stop 'ERROR while reading pattern file' 92 stop 'ERROR while reading a input pattern file' ! end subroutine initialize_variables ! subroutine release_variables () ! integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( map_output )) then !do i=1,size(map_output) !   call map_output(i)%destroy(); !enddo deallocate ( map_output ); endif ! inquire ( unit = som_parameters ( 1 )% iout , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iout ) endif ! end subroutine release_variables end module som_predict_variables","tags":"","loc":"sourcefile\\som_predict_variables.f90.html"},{"title":"quicksort_utilities.f90 – KohonenF08","text":"This module includes the definition of a class called quicksort\nthat is used to encapsulate the quicksorting algorithm. This \nalgorithm is highly efficient. This file depends on sourcefile~~quicksort_utilities.f90~~EfferentGraph sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~quicksort_utilities.f90~~AfferentGraph sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/10/2023 !! version: 0.1 !!  This module includes the definition of a class called quicksort !!  that is used to encapsulate the quicksorting algorithm. This !!  algorithm is highly efficient. module quicksort_utilities ! use precision_utilities , only : wp ; use sort_base_utilities , only : sort_base ; ! implicit none ; ! private ; ! type , extends ( sort_base ) :: quicksort !!  class that encapsulates the quicksort algorithm contains procedure , pass :: sort => quick_sort end type quicksort ! public :: quicksort ; ! contains !=============================================================================================================== recursive subroutine quick_sort ( my_sort , list , order ) !=============================================================================================================== !! main subroutine of the quick sort algorithm. implicit none class ( quicksort ), intent ( inout ) :: my_sort !! A quicksort object real ( kind = wp ), dimension (:), intent ( inout ) :: list !! A real vector with the values to be sorted. integer , dimension (:), intent ( inout ) :: order !! An integer vector with the positions of the ordered samples. !! quick sort routine from: !! brainerd, w.s., goldberg, c.h. & adams, j.c. (1990) \"programmer's guide to !! fortran 90\", mcgraw-hill  isbn 0-07-000248-7, pages 149-150. !! modified by alan miller to include an associated integer array which gives !! the positions of the elements in the original order. ! local variable integer :: i !write(*,*) size(list) do i = 1 , size ( list ) order ( i ) = i end do call quick_sort_1 ( 1 , size ( list )) contains recursive subroutine quick_sort_1 ( left_end , right_end ) integer , intent ( in ) :: left_end , right_end !***** !     local variables integer :: i , j , itemp real ( kind = wp ) :: reference , temp integer , parameter :: max_simple_sort_size = 6 if ( right_end < left_end + max_simple_sort_size ) then ! use interchange sort for small lists call interchange_sort ( left_end , right_end ) else ! use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 do ! scan list from left end until element >= reference is found do i = i + 1 if ( list ( i ) >= reference ) exit end do ! scan list from right end until element <= reference is found do j = j - 1 if ( list ( j ) <= reference ) exit end do if ( i < j ) then ! swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp else if ( i == j ) then i = i + 1 exit else exit end if end do if ( left_end < j ) call quick_sort_1 ( left_end , j ) if ( i < right_end ) call quick_sort_1 ( i , right_end ) end if end subroutine quick_sort_1 !=============================================================================================================== subroutine interchange_sort ( left_end , right_end ) !=============================================================================================================== !! subroutine to interchange elements integer , intent ( in ) :: left_end , right_end !! left_end, right_end: integer variables with the positiions to be interchanged !     local variables integer :: i , j , itemp real ( kind = wp ) :: temp do i = left_end , right_end - 1 do j = i + 1 , right_end if ( list ( i ) > list ( j )) then temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp end if end do end do end subroutine interchange_sort ! end subroutine quick_sort ! end module quicksort_utilities","tags":"","loc":"sourcefile\\quicksort_utilities.f90.html"},{"title":"distance_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class called distance_base used as a template to \nderive classes used in the calculation of distances between input patterns This file depends on sourcefile~~distance_base_utilities.f90~~EfferentGraph sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~distance_base_utilities.f90~~AfferentGraph sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines an abstract class called `distance_base` used as a template to !! derive classes used in the calculation of distances between input patterns module distance_base_utilities ! use precision_utilities , only : wp ; !!   This module defines an abstract class to represent an abstract function to calculate distance implicit none ! type , abstract :: distance_base !! Abstract class `distance_base` contains procedure ( distance_function1 ), deferred :: calculate end type distance_base !***** abstract interface !======================================================================================== function distance_function1 ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Template for the calculate function import :: distance_base import :: wp !! Import section class ( distance_base ) :: distance !! A `distance_base` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 !! A real vector real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector2 !! A real vector real ( kind = wp ) :: d !! A real variable with the distance end function distance_function1 ! end interface end module distance_base_utilities","tags":"","loc":"sourcefile\\distance_base_utilities.f90.html"},{"title":"multilayer_self_organizing_map_utilities.f – KohonenF08","text":"This module defines a class that represents a multilayer self_organized_map \ndefined using several kohonen layers \nThis module defines a class that represents a multilayer self_organized_map Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/05/2025 !! version: 0.1 !! This module defines a class that represents a multilayer self_organized_map !! defined using several kohonen layers modul e multilayer_self_organizing_map_utilities !! This module defines a class that represents a multilayer self_organized_map use e r ror_handling , only : error_stop , error_t ; use p r ecision_utilities , only : wp ; use c o nstants_utilities , only : NUMCHAR ; use r a ndom_generator_base_utilities , only : random_generator_base ; use r k iss05_generator_utilities , only : rkiss05_generator ; use k o honen_layer_parameters_utilities , only : kohonen_layer_parameters ; use k o honen_map_base_utilities , only : kohonen_map_base ; use k o honen_prototype_utilities , only : kohonen_prototype ; use k o honen_pattern_utilities , only : kohonen_pattern ; use d i stance_base_utilities , only : distance_base ; use f a ctory_distance_utilities , only : factory_distance ; !use influence_function_utilities; end m o dule multilayer_self_organizing_map_utilities","tags":"","loc":"sourcefile\\multilayer_self_organizing_map_utilities.f.html"},{"title":"dataframe_utilities.f90 – KohonenF08","text":"This module defines a data structure called dataframe This file depends on sourcefile~~dataframe_utilities.f90~~EfferentGraph sourcefile~dataframe_utilities.f90 dataframe_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~dataframe_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~dataframe_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/52/2025 !! version: 0.1 !! This module defines a data structure called dataframe module dataframe_utilities !! This module defines a data structure called dataframe use error_handling , only : error use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; implicit none ; private ; ! type :: variable integer :: data_type !1=real,2=integer,3=character integer :: number_samples character ( len = NUMCHAR ) :: name real ( kind = wp ), allocatable :: real_data (:) integer , allocatable :: integer_data (:) character ( len = :), allocatable :: character_data (:) end type variable ! type :: dataframe private character ( len = NUMCHAR ) :: base_message integer :: number_variables type ( variable ), allocatable :: variables (:) character ( len = :), allocatable :: variable_names (:) logical :: initialized , has_variable_names contains procedure , public :: create => create_dataframe procedure , public :: destroy => destroy_dataframe procedure , public :: add_variable ! procedure,public :: remove_variable ! procedure,public :: is_initialized ! procedure,public :: summary ! procedure,public :: nrow ! procedure,public :: ncol ! procedure,public :: size => size_dataframe ! procedure,public :: normalize end type dataframe public :: dataframe ! contains !======================================================================================== subroutine create_dataframe ( df , data_ , varnames ) !======================================================================================== !! Class constructor class ( dataframe ) :: df !! A `dataframe` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: data_ character ( len = :), dimension (:), intent ( inout ) :: varnames ! integer :: ivar , ierr , nvar , ndat character ( len = NUMCHAR ) :: message real ( kind = wp ), allocatable :: tmp_data (:) ! df & base_message = 'DATAFRAME ERROR' ; allocate ( df % variable_names , source = varnames , stat = ierr ); if ( ierr /= 0 ) then message = trim ( df % base_message ) // ' while allocating memory for variable_names array' ; call error ( message ); endif ndat = size ( data_ , 1 ); nvar = size ( data_ , 2 ); allocate ( tmp_data ( ndat ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( df % base_message ) // ' while allocating memory for tmp_data array' ; call error ( message ); endif do ivar = 1 , nvar ; tmp_data ( 1 : ndat ) = data_ (:, ivar : ivar ); call df % add_variable ( tmp_data ); end do deallocate ( tmp_data ); ! end subroutine create_dataframe !======================================================================================== subroutine destroy_dataframe ( df ) !======================================================================================== !! Class destructor class ( dataframe ) :: df !! A `dataframe` object integer :: i , current_type ! if ( allocated ( df % variable_names )) deallocate ( df % variable_names ); do i = 1 , size ( df % variables ); if ( allocated ( df % variables ( i ))) then current_type = df % variables ( i )% data_type ; select case ( current_type ) case ( 1 ) deallocate ( df % variables ( i )% real_data ); case ( 2 ) deallocate ( df % variables ( i )% integer_data ); case ( 3 ) deallocate ( df % variables ( i )% character_data ); end select df % variables ( i )% name = '' ; df % variables ( i )% number_samples = 0 ; deallocate ( df % variables ( i )); endif end do end subroutine destroy_dataframe !======================================================================================== subroutine add_variable ( df , data_ , varname_ ) !======================================================================================== class ( dataframe ) :: df class ( * ) :: data_ character ( len =* ) :: varname_ end subroutine add_variable end module dataframe_utilities","tags":"","loc":"sourcefile\\dataframe_utilities.f90.html"},{"title":"rkiss05_generator_utilities.f90 – KohonenF08","text":"This module includes the definition of a class called rkiss05_generator \nthat is used to generate random numbers with an uniform disitribution\nusing the rkiss approach This file depends on sourcefile~~rkiss05_generator_utilities.f90~~EfferentGraph sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~rkiss05_generator_utilities.f90~~AfferentGraph sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/06/2023 !! version: 0.1 !!  This module includes the definition of a class called rkiss05_generator !!  that is used to generate random numbers with an uniform disitribution !!  using the rkiss approach !! module rkiss05_generator_utilities !!  Define the class rkiss05_generator that represents a random number generator !!  based on the rkiss method use precision_utilities , only : wp ; use random_generator_base_utilities , only : random_generator_base ; ! implicit none ; ! private ; type , extends ( random_generator_base ) :: rkiss05_generator private !! Class to represent a random number generator that implements the rkiss method integer :: seed integer :: x , y , w , z contains !  * constructor procedure , public :: create => create_rkiss05_generator !  * destructor procedure , public :: destroy => destroy_rkiss05_generator !  * generate procedure , public :: generate => generate_rkiss05_generator ! end type rkiss05_generator !***** public :: rkiss05_generator ; ! contains !======================================================================================== subroutine create_rkiss05_generator ( generator , iseed ) !======================================================================================== !! Constructor of the rkiss05_generator class. In this class random seed is assigned to the !! random number generator and the internal state of the corresponding generator  is !! initialized. class ( rkiss05_generator ) :: generator !!  generator: A rkiss05_generator object integer , intent ( in ), optional :: iseed !! iseed: An integer with the seed of the random number generator if ( present ( iseed )) then generator % seed = iseed ; else generator % seed = 12345 ; endif generator % x = iseed ; generator % y = iseed + 1 ; generator % z = iseed + 2 ; generator % w = iseed + 3 ; ! end subroutine create_rkiss05_generator !======================================================================================== subroutine destroy_rkiss05_generator ( generator ) !======================================================================================== !! Destructor of the rkiss05_generator class. In this class, the random seed is set to 0 class ( rkiss05_generator ) :: generator !! generator: A rkiss05_generator object if ( generator % seed > 0 ) then generator % seed = 0 ; endif ! end subroutine destroy_rkiss05_generator !======================================================================================== function generate_rkiss05_generator ( generator ) result ( r ) !======================================================================================== !!  Function used to generate realizations of the random numbers with the rkiss05_generator class. class ( rkiss05_generator ) :: generator !! generator: A rkiss05_generator object real ( kind = wp ), parameter :: am = 4.656612873077392578d-10 ! multiplier 1/2&#94;31 !! Multiplier real ( kind = wp ) :: r !! r: A real variable with the generated random number real ( kind = wp ) :: rkiss05 integer :: kiss !          integer          :: x,y,z,w              ! working variables for the four generators !common /kisscom/x,y,z,w ! generator % x = 69069 * generator % x + 1327217885 generator % y = ieor ( generator % y , ishft ( generator % y , 13 )); generator % y = ieor ( generator % y , ishft ( generator % y , - 17 )); generator % y = ieor ( generator % y , ishft ( generator % y , 5 )) generator % z = 18000 * iand ( generator % z , 65535 ) + ishft ( generator % z , - 16 ) generator % w = 30903 * iand ( generator % w , 65535 ) + ishft ( generator % w , - 16 ) kiss = ishft ( generator % x + generator % y + ishft ( generator % z , 16 ) + generator % w , - 1 ) rkiss05 = kiss * am r = rkiss05 end function generate_rkiss05_generator ! end module rkiss05_generator_utilities","tags":"","loc":"sourcefile\\rkiss05_generator_utilities.f90.html"},{"title":"neighborhood_function_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class to define neighborhood functions This file depends on sourcefile~~neighborhood_function_base_utilities.f90~~EfferentGraph sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~neighborhood_function_base_utilities.f90~~AfferentGraph sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90 cauchy_neighborhood_function_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90->sourcefile~neighborhood_function_base_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90 gaussian_neighborhood_function_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90->sourcefile~neighborhood_function_base_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/16/2025 !! version: 0.2 !! This module defines an abstract class to define neighborhood functions module neighborhood_function_base_utilities !! This module defines an abstract class to define neighborhood functions use precision_utilities , only : wp ; implicit none ; ! type , abstract :: neighborhood_function_base !! Abstract class used to derive classes that calculates the effect of the input on the !! units of a SOM (neighborhood function) contains procedure ( neighborhood_function_calculate ), deferred :: calculate end type neighborhood_function_base ! abstract interface function neighborhood_function_calculate ( my_neigh_fn , geometric_distance ) result ( n ) !! Subroutine template to calculate function import :: neighborhood_function_base import :: wp !! Import section class ( neighborhood_function_base ) :: my_neigh_fn !! A `neighborhood_function_base` object real ( kind = wp ), intent ( inout ) :: geometric_distance !! A real variable with the geometric or grid distance of a SOM unit real ( kind = wp ) :: n !! A real variable with the value of the neighborhood function end function neighborhood_function_calculate ! end interface ! end module neighborhood_function_base_utilities","tags":"","loc":"sourcefile\\neighborhood_function_base_utilities.f90.html"},{"title":"self_organizing_map_utilities.f90 – KohonenF08","text":"This module defines a class for simple self_organizing_map (one kohonen layer) This file depends on sourcefile~~self_organizing_map_utilities.f90~~EfferentGraph sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~self_organizing_map_utilities.f90~~AfferentGraph sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !!  This module defines a class for simple self_organizing_map (one kohonen layer) module self_organizing_map_utilities !!  This module defines a class for simple self_organizing_map (one kohonen layer) !$  use omp_lib use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use random_generator_base_utilities , only : random_generator_base ; use rkiss05_generator_utilities , only : rkiss05_generator ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use kohonen_pattern_utilities , only : kohonen_pattern ; use distance_base_utilities , only : distance_base ; use factory_distance_utilities , only : factory_distance ; !use influence_function_utilities; use quicksort_utilities , only : quicksort ; ! implicit none ; ! type , extends ( kohonen_map_base ) :: self_organizing_map !!   Class to represent a self_organizing_map private character ( len = NUMCHAR ) :: class_name = 'self_organizing_map' ; type ( kohonen_prototype ), allocatable :: grid (:,:,:) integer , allocatable :: number_patterns (:,:,:), cells_index (:,:) real ( kind = wp ), allocatable :: u_matrix (:,:,:), distance (:,:) real ( kind = wp ), allocatable :: cells_distances (:,:), coordinates (:,:) type ( kohonen_layer_parameters ) :: parameters type ( factory_distance ) :: factory class ( distance_base ), allocatable :: distance_function real ( kind = wp ), allocatable :: distortion (:) type ( rkiss05_generator ) :: rnumber_grator integer :: seed integer , allocatable :: grid_pattern_index (:,:,:), list_node_grid (:,:,:,:) contains procedure , public :: create => create_som procedure , public :: destroy => destroy_som procedure , private :: create_random_sample procedure , private :: train_som_data procedure , public :: train => train_som_data procedure , public :: predict => predict_som procedure , public :: print => print_som procedure , public :: read => read_som procedure , public :: get_count => get_count_som procedure , public :: query => query_som procedure , public :: get_prototypes !procedure,public :: get_index => get_index_som procedure , public :: get_u_matrix => get_u_matrix_som procedure , private :: find_best_match_unit procedure , private :: update_weights !procedure,private :: update_weights1 procedure , private :: find_bmu_grid procedure , private :: calculate_u_matrix procedure , private :: calculate_u_matrix_hexagonal procedure , private :: calculate_u_matrix_rectangular procedure , private :: calculate_sigma procedure , nopass , private :: position2index procedure , nopass , private :: index2position procedure , nopass , private :: calculate_distance_matrix procedure , nopass , private :: calculate_coordinates procedure , private :: calculate_distance_between_prototypes procedure , nopass , public :: external_train_map procedure , nopass , public :: external_predict_map ! end type self_organizing_map ! contains !======================================================================================== subroutine create_som ( kohonen_map , training_parameters ) !======================================================================================== !!   Constructor for self_organizing_map character ( len = NUMCHAR ), parameter :: fname = 'create_som' !! A character variable with the name of the function class ( self_organizing_map ) :: kohonen_map !! A  `self_organizing_map` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` object integer :: ierr , nx , ny , nz , ix , iy , iz , nvar1 , nvar2 , seed , current_index , nepoch integer :: i , j real ( kind = wp ), allocatable :: input (:,:) character ( len = NUMCHAR ) :: base_message , message ! base_message = trim ( kohonen_map % class_name ) // '_' // trim ( fname ) // '_ERROR' ; ! kohonen_map % parameters = training_parameters ( 1 ); nx = training_parameters ( 1 )% number_nodes_nx ; ny = training_parameters ( 1 )% number_nodes_ny ; nz = training_parameters ( 1 )% number_nodes_nz ; nvar1 = training_parameters ( 1 )% number_variables1 ; nvar2 = training_parameters ( 1 )% number_variables2 ; nepoch = training_parameters ( 1 )% number_epochs ; write ( * , * ) 'Create= ' , nx , ny , nz , nvar1 , nvar2 , nepoch ; allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % grid_pattern_index ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for grid_pattern_index array' ; call error_stop ( message ); endif ! allocate ( input ( nvar1 , nvar2 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for input array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % number_patterns ( nx , ny , nz ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for number_patterns array' ; call error_stop ( message ); endif ! allocate ( kohonen_map % cells_index ( training_parameters ( 1 )% number_patterns , 3 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for cell_index array' ; call error_stop ( message ); endif ! kohonen_map % number_patterns = 0 ; kohonen_map % cells_index = 0 ; allocate ( kohonen_map % u_matrix ( 2 * nx - 1 , 2 * ny - 1 , 2 * nz - 1 ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for u_matrix array' ; call error_stop ( message ); endif kohonen_map % u_matrix = 0.0_wp ; ! allocate ( kohonen_map % distance ( nx * ny , nx * ny ), stat = ierr ); if ( ierr /= 0 ) then message = trim ( base_message ) // '_allocating memory for distance array' ; call error_stop ( message ); endif kohonen_map % distance = 0.0_wp ; ! allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); kohonen_map % cells_distances = 0.0d0 ; allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); kohonen_map % coordinates = 0.0d0 ; allocate ( kohonen_map % distortion ( nepoch ), stat = ierr ); kohonen_map % distortion = 0.0d0 ; ! call kohonen_map % factory % create_distance ( training_parameters ( 1 )% distance_type ,& kohonen_map % distance_function ); ! kohonen_map % seed = training_parameters ( 1 )% random_seed_ ( 1 ); call kohonen_map % rnumber_grator % create ( kohonen_map % seed ); ! do i=1,nvar1; !     do j=1,nvar2; !         input(i,j)=kohonen_map%rnumber_grator%generate(); !         !write(*,*) 'input= ',input(i,j); !     enddo ! enddo ! write ( * , * ) 'SOM: Initializing grid...' , kohonen_map % seed ; do iz = 1 , nz ; do iy = 1 , ny ; do ix = 1 , nx ; !write(*,*) 'creating ',ix,iy,iz call kohonen_map % create_random_sample ( input ); call kohonen_map % grid ( ix , iy , iz )% create ( input ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , training_parameters ( 1 )% node_type ); enddo !ix enddo !iy enddo !iz deallocate ( input ); ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& training_parameters ( 1 )% node_type , training_parameters ( 1 )% toroidal_grid ); write ( * , * ) 'SOM: Initializing grid...OK' ; ! end subroutine create_som !======================================================================================== subroutine destroy_som ( kohonen_map ) !======================================================================================== !!   Destructor for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: ix , iy , iz ! !       write(*,*) 'SOM: Releasing memory...' if ( allocated ( kohonen_map % grid )) then do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif ! if ( allocated ( kohonen_map % number_patterns )) then deallocate ( kohonen_map % number_patterns ); endif ! if ( allocated ( kohonen_map % cells_index )) then deallocate ( kohonen_map % cells_index ); endif ! if ( allocated ( kohonen_map % u_matrix )) then deallocate ( kohonen_map % u_matrix ); endif ! if ( allocated ( kohonen_map % distance_function )) then deallocate ( kohonen_map % distance_function ); endif ! if ( allocated ( kohonen_map % distance )) then deallocate ( kohonen_map % distance ); endif ! if ( allocated ( kohonen_map % cells_distances )) then deallocate ( kohonen_map % cells_distances ); endif ! if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif ! if ( allocated ( kohonen_map % distortion )) then deallocate ( kohonen_map % distortion ) endif ! if ( allocated ( kohonen_map % grid_pattern_index )) then deallocate ( kohonen_map % grid_pattern_index ); endif ! if ( allocated ( kohonen_map % list_node_grid )) then deallocate ( kohonen_map % list_node_grid ); endif call kohonen_map % rnumber_grator % destroy (); ! !        write(*,*) 'SOM: Releasing memory...OK!' ! end subroutine destroy_som !======================================================================================== subroutine create_random_sample ( kohonen_map , input ) !======================================================================================== !! Subroutine to generate random values that serve as inputs to the SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: input !! A real array with the initial values of the prototypes integer :: nvar1 , nvar2 , i , j ! nvar1 = size ( input , 1 ); nvar2 = size ( input , 2 ); do i = 1 , nvar1 ; do j = 1 , nvar2 ; input ( i , j ) = kohonen_map % rnumber_grator % generate (); end do end do ! end subroutine create_random_sample !======================================================================================== subroutine train_som_data ( kohonen_map , input_data ) !======================================================================================== !!   Training function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: iteration , iepoch , ipattern , ix , iy , iz , jhit , ihit , khit , ineigh , jneigh integer :: kneigh , idbg , number_variables , idisto !neff, integer :: cx , cy , cz , i , j , k , number_nodes , debug_option , ix1 , iy1 , iz1 , pos , pos1 , max_pattern integer :: ierr , nx , ny , nz , ipos integer :: current_pos , ic , itemp real ( kind = wp ) :: distortion , dist , dist_hit , maximum_radius , minimum_radius real ( kind = wp ) :: current_radius , alpha , u_temp type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values integer , allocatable :: pattern_index (:,:,:,:), positions (:) ! ! ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; allocate ( positions ( nx * ny * nz ), stat = ierr ); idbg = kohonen_map % parameters % idbg ; idisto = kohonen_map % parameters % idisto ; debug_option = kohonen_map % parameters % debug_level ; if ( debug_option > 0 ) then open ( idbg , file = trim ( kohonen_map % parameters % debug_file ), status = 'unknown' ); endif iteration = 0 ; distortion = 0.0_wp ; number_variables = kohonen_map % parameters % number_variables1 * kohonen_map % parameters % number_variables2 ; maximum_radius = dble ( max ( kohonen_map % parameters % number_nodes_nx , kohonen_map % parameters % number_nodes_ny )); minimum_radius = 1.0_wp ; write ( * , * ) 'SOM: Training starting...' do iepoch = 1 , kohonen_map % parameters % number_epochs ; kohonen_map % distortion ( iepoch ) = distortion ; write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion ; if ( iepoch > 1 ) write ( idisto , * ) iepoch , distortion distortion = 0.0_wp ; do ipattern = 1 , kohonen_map % parameters % number_patterns ; iteration = iteration + 1 ; ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); call current_prototype % get_prototype ( current_values ); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); !write(*,*) 'Test= ',ipattern,ihit,jhit,khit,dist_hit if ( debug_option > 0 ) then write ( idbg , * ) 'Epoch,Current Pattern' , iepoch , ipattern ; call current_prototype % print ( idbg ); endif distortion = distortion + dist_hit ; if ( debug_option > 0 ) then write ( idbg , * ) 'Neighborhood,alpha= ' , alpha ; endif call kohonen_map % update_weights ( current_values , ihit , jhit , khit , maximum_radius , iteration ); ! enddo !ipattern enddo !iepoch !       write(*,*) 'SOM: Training finished' !       write(*,*) 'Total number of iterations= ',iteration !     print prototypes ! if(kohonen_map%parameters%train_option < 3) then ! do iz=1,size(kohonen_map%grid,3) !    !write(kohonen_map%parameters%iprot,'(A,I4)') 'Layer ',iz !    do iy=1,size(kohonen_map%grid,2); !       do ix=1,size(kohonen_map%grid,1); !          !write(kohonen_map%parameters%iprot,'(A6,1X,3I4)') 'node= ',ix,iy,iz !          call kohonen_map%grid(ix,iy,iz)%print(kohonen_map%parameters%iprot); !       enddo !    enddo ! enddo!ix ! endif !     calculate and print distance matrix call kohonen_map % calculate_distance_between_prototypes (); !     final best match !      call kohonen_map%find_bmu_grid(input_data); max_pattern = 0 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); call kohonen_map % find_best_match_unit ( current_prototype , ihit , jhit , khit , dist_hit ); kohonen_map % number_patterns ( ihit , jhit , khit ) = kohonen_map % number_patterns ( ihit , jhit , khit ) + 1 ; if ( kohonen_map % number_patterns ( ihit , jhit , khit ) > max_pattern ) then max_pattern = kohonen_map % number_patterns ( ihit , jhit , khit ); endif kohonen_map % cells_index ( ipattern , 1 ) = ihit ; kohonen_map % cells_index ( ipattern , 2 ) = jhit ; kohonen_map % cells_index ( ipattern , 3 ) = khit ; if ( debug_option > 0 ) then write ( idbg , * ) ipattern , ihit , jhit , khit ; endif !if(kohonen_map%parameters%train_option < 3) then !   write(kohonen_map%parameters%iindex,*) ipattern,ihit,jhit,khit !endif !         write(*,*) 'BMU= ',ipattern,ihit,jhit,khit,dist_hit ! enddo !ipattern ! allocate ( pattern_index ( size ( kohonen_map % grid , 1 ),& size ( kohonen_map % grid , 2 ), size ( kohonen_map % grid , 3 ),& max_pattern ), stat = ierr ); pattern_index =- 1 ; do ipattern = 1 , kohonen_map % parameters % number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); do i = 1 , max_pattern ; if ( pattern_index ( ix , iy , iz , i ) < 0 ) then pattern_index ( ix , iy , iz , i ) = ipattern ; exit ; endif enddo enddo !ipattern if ( kohonen_map % parameters % train_option < 3 ) then do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % isam , '(A,3I4)' ) 'Node= ' , ix1 , iy1 , iz1 if ( kohonen_map % number_patterns ( ix1 , iy1 , iz1 ) > 0 ) then write ( kohonen_map % parameters % isam , '(A,10000I5)' ) 'Sample ID= ' ,& pattern_index ( ix1 , iy1 , iz1 , 1 : kohonen_map % number_patterns ( ix1 , iy1 , iz1 )); else write ( kohonen_map % parameters % isam , '(A,I4)' ) 'Sample ID= ' , 0 endif enddo enddo enddo deallocate ( pattern_index ); endif ! if ( debug_option . gt . 0 ) then close ( idbg ); endif close ( idisto ); !     print hit counter if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % grid , 3 ) do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters % ihit , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % grid , 2 )); enddo !ix enddo endif call kohonen_map % calculate_u_matrix (); ! end subroutine train_som_data !======================================================================================== subroutine predict_som ( kohonen_map , input_data , map_output ) !======================================================================================== !! Function for Prediction of a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer , dimension (:,:), intent ( out ) :: map_output !! An integer array with the map output integer :: ipattern , ihit , jhit , khit , ix , iy , iz , number_variables , i , j , k real ( kind = wp ) :: dist_hit , dist type ( kohonen_prototype ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values ! number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ; ! !       write(*,*) 'SOM: Prediction starting...'; !       write(*,*) number_variables do ipattern = 1 , size ( input_data , 1 ) ihit = 0 ; jhit = 0 ; dist_hit = 10000 0.0_wp ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%print(); !write(*,*) ihit,jhit,dist_hit !call current_prototype%get_prototype(current_values); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; !write(*,*) ix,iy,dist !call kohonen_map%grid(ix,iy)%print(); dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo ! !$OMP end parallel do ! call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( current_values ); ! if(size(current_values,2) .eq. 1) then !   write(kohonen_map%parameters%iout,*) (current_values(i,1),& !         i=1,size(current_values,1)); ! else !   do i=1,size(current_values,1) !      write(kohonen_map%parameters%iout,*) (current_values(i,j),j=1,& !            size(current_values,2)) !   enddo ! endif !call map_output(ipattern)%create(current_values); map_output ( ipattern , 1 ) = ihit ; map_output ( ipattern , 2 ) = jhit ; map_output ( ipattern , 3 ) = khit ; !size(current_values,1),size(current_values,2) !write(*,*) current_values enddo !ipattern !       write(*,*) 'SOM: Prediction finished'; ! end subroutine predict_som !======================================================================================== subroutine print_som ( kohonen_map , unit_ ) !======================================================================================== !!   Print function for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , intent ( inout ), optional :: unit_ !! integer :: ix , iy , iz , unit1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif write ( unit1 , * ) 'SOM: Results' ; write ( unit1 , * ) call kohonen_map % parameters % print ( unit1 ); ! write(unit1,*) 'After' write ( unit1 , * ) write ( unit1 , * ) 'SOM: Grid nodes' ; write ( unit1 , * ) do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); call kohonen_map % grid ( ix , iy , iz )% print ( unit1 ); enddo enddo !iy enddo !ix write ( unit1 , * ) write ( unit1 , * ) 'SOM: Hit count' ; write ( unit1 , * ) write ( unit1 , * ) 'Pattern Numbers' ; do iz = 1 , size ( kohonen_map % number_patterns , 3 ); do ix = 1 , size ( kohonen_map % number_patterns , 1 ); write ( unit1 , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 ,& size ( kohonen_map % number_patterns , 2 )); enddo enddo write ( unit1 , * ) write ( * , * ) 'SOM: Pattern index' write ( unit1 , * ) write ( unit1 , * ) write ( unit1 , * ) 'Pattern #, ix   ,iy' ; do ix = 1 , size ( kohonen_map % cells_index , 1 ); write ( unit1 , '(100I5)' ) ix , ( kohonen_map % cells_index ( ix , iy ),& iy = 1 , size ( kohonen_map % cells_index , 2 )); enddo ! end subroutine print_som !======================================================================================== subroutine get_count_som ( kohonen_map , count_ ) !======================================================================================== !!   Function to get count matrix for self_organizing_map class ( self_organizing_map ) :: kohonen_map !! integer , dimension (:,:,:), intent ( inout ) :: count_ !! count_ = kohonen_map % number_patterns ; ! end subroutine get_count_som !======================================================================================== subroutine query_som ( kohonen_map , input_pattern , sample_index ) !,output_patterns) !======================================================================================== !!   Function to find the input samples associated with specific vector class ( self_organizing_map ) :: kohonen_map !! real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_pattern !! integer , allocatable :: sample_index (:) !! integer :: ix , iy , iz , ihit , jhit , khit , ivar1 , ivar2 , nvar1 , nvar2 , number_patterns , ipat , ierr integer :: number_selected , i , pos real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_values real ( kind = wp ) :: dist , dist_min integer , dimension ( size ( kohonen_map % cells_index , 1 )) :: position , real_position ! !(real_position(ix)=ix,ix=1,size(real_position)) do ix = 1 , size ( real_position ) real_position ( ix ) = ix ; enddo nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; dist_min = 1.0d10 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; call kohonen_map % grid ( ix , iy , iz )% get_prototype ( current_values ); do ivar1 = 1 , nvar1 ; do ivar2 = 1 , nvar2 ; if ( input_pattern ( ivar1 , ivar2 ) > 0.0_wp ) then dist = dist + ( input_pattern ( ivar1 , ivar2 ) - current_values ( ivar1 , ivar2 )) ** 2 ; endif enddo enddo if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo !$OMP end parallel do !         write(*,*) 'BMU' !         write(*,*) ihit,jhit,khit,dist_min ! position = 0 ; number_patterns = kohonen_map % number_patterns ( ihit , jhit , khit ); if ( number_patterns > 0 ) then where ( kohonen_map % cells_index (:, 1 ) == ihit . and . & kohonen_map % cells_index (:, 2 ) == jhit . and . & kohonen_map % cells_index (:, 3 ) == khit ) position = 1 ; !real_position; end where number_selected = sum ( position ); pos = 0 if ( number_selected > 0 ) then allocate ( sample_index ( number_selected ), stat = ierr ); do i = 1 , size ( real_position ) if ( position ( i ) == 1 ) then pos = pos + 1 ; sample_index ( pos ) = real_position ( i ); !write(*,*) 'Inside= ',i,real_position(i) endif enddo endif !write(*,*) kohonen_map%cells_index(118,1:3) else write ( * , * ) 'WARNING: Query has returned an empty result' return endif ! end subroutine query_som !======================================================================================== subroutine read_som ( kohonen_map , som_fl ) !======================================================================================== !! Subroutine to read the prototypes to define a self_organizing_map class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len =* ) :: som_fl !! A character variable with the name of the file logical :: testfl , toroidal_grid integer :: isom , nx , ny , nz , nvar1 , nvar2 , ierr , ix , iy , iz , ivar , current_index character ( len = 40 ) :: current_line , node_type real ( kind = wp ), allocatable :: Prototype_value (:,:) ! isom = 20 ; inquire ( file = trim ( som_fl ), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the som file does not exist' stop endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...' write ( * , * ) open ( isom , file = trim ( som_fl ), status = 'unknown' , action = 'read' , access = 'sequential' ); read ( isom , '(A)' ) current_line write ( * , * ) trim ( current_line ) read ( isom , '(A17,1X,3I6)' ) current_line , nx , ny , nz write ( * , * ) current_line , nx , ny , nz read ( isom , '(A21,1X,2I6)' ) current_line , nvar1 , nvar2 write ( * , * ) current_line , nvar1 , nvar2 read ( isom , '(A25,1X,A11,1X,L4)' ) current_line , node_type , toroidal_grid write ( * , * ) current_line , node_type , toroidal_grid allocate ( Prototype_value ( nvar1 * nvar2 , 1 ), stat = ierr ); ! if ( allocated ( kohonen_map % grid )) then do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); do iz = 1 , nz read ( isom , '(A)' ) current_line ; write ( * , * ) 'Reading ' , trim ( current_line ); do iy = 1 , ny do ix = 1 , nx ; read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , '(A)' ) current_line ; !                   write(*,*) current_line read ( isom , * ) ( Prototype_value ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ); !write(*,*) ix,iy,(Prototype_value(ivar,1),ivar=1,nvar1*nvar2) call kohonen_map % grid ( ix , iy , iz )% set_prototype ( Prototype_value ); current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz ,& kohonen_map % coordinates , node_type ); enddo enddo enddo close ( isom ) !write(*,*) 'Reading done' ! call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances ,& node_type , toroidal_grid ); ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...finished' write ( * , * ) ! end subroutine read_som !======================================================================================== function position2index ( ix , iy , iz , nx , ny ) result ( index_ ) !======================================================================================== !! Function to calculate the index inside a rectangular grid from position ix,iy,iz integer , intent ( in ) :: ix , iy , iz , nx , ny !! Integer variables integer :: index_ !! Integer variable with the required index index_ = ix + ( iy - 1 ) * nx + ( iz - 1 ) * nx * ny ; ! end function position2index !======================================================================================== subroutine index2position ( index_ , nx , ny , nz , cx , cy , cz ) !======================================================================================== !! Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index integer , intent ( in ) :: index_ !! Integer variable representing the index integer , intent ( in ) :: nx , ny , nz !! Integer variables representing the dimensions of the kohonen map integer , intent ( inout ) :: cx , cy , cz !! Integer variables representing the position of the node !  write(*,*) index_,nx,ny,1+int((index_-1)/(nx*ny)) cz = min ( 1 + int (( index_ - 1 ) / ( nx * ny )), nz ); cy = min ( 1 + int (( index_ - 1 - ( cz - 1 ) * nx * ny ) / nx ), ny ); cx = min ( index_ - ( cz - 1 ) * nx * ny - ( cy - 1 ) * nx , nx ); ! end subroutine index2position !======================================================================================== subroutine calculate_distance_matrix ( coordinates , distance_matrix , grid_type , toroidal ) !======================================================================================== !! Subroutine to calculate the distance between the units inside a kohonen layer real ( kind = wp ), dimension (:,:), intent ( inout ) :: coordinates !! Real array with the coordinates real ( kind = wp ), dimension (:,:), intent ( inout ) :: distance_matrix !! Real array with the distance_matrix character ( len =* ) :: grid_type !! Character variable with the grid type logical :: toroidal !! Logical variable for toroidal grid integer :: i , j real ( kind = wp ) :: maxdiffx , maxdiffy , maxdiffz real ( kind = wp ), dimension ( 3 ) :: diffs ! maxdiffx = maxval ( coordinates (:, 1 )) / 2.0_wp ; maxdiffy = maxval ( coordinates (:, 2 )) / 2.0_wp ; maxdiffz = maxval ( coordinates (:, 3 )) / 2.0_wp ; ! distance_matrix = 0.0d0 ; ! if ( toroidal ) then do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); if ( diffs ( 1 ) > maxdiffx ) diffs ( 1 ) = 2.0_wp * maxdiffx - diffs ( 1 ); if ( diffs ( 2 ) > maxdiffy ) diffs ( 2 ) = 2.0_wp * maxdiffy - diffs ( 2 ); !if (diffs(3) > maxdiffy) diffs(3)=2*maxdiffz - diffs(3); if ( trim ( grid_type ) == 'hexagonal' ) then distance_matrix ( i , j ) = sum ( diffs ** 2 ); elseif ( trim ( grid_type ) == 'rectangular' ) then !rectangular distance_matrix ( i , j ) = maxval ( diffs ); endif !write(*,*) 'd= ',i,j,diffs(1:3),trim(grid_type)!distance_matrix(i,j) enddo enddo else do i = 1 , size ( distance_matrix , 1 ); do j = i + 1 , size ( distance_matrix , 2 ); diffs = dabs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); distance_matrix ( i , j ) = dsqrt ( sum ( diffs ** 2 )); enddo enddo endif ! distance_matrix = distance_matrix + transpose ( distance_matrix ); ! end subroutine calculate_distance_matrix !======================================================================================== subroutine calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , coordinates , node_type ) !======================================================================================== !!  Subroutine to calculate the coordinates of the units inside a kohonen layer integer , intent ( in ) :: current_index , ix , iy , iz , nx , ny , nz !! real ( kind = wp ), dimension (:,:), intent ( out ) :: coordinates !! character ( len =* ), intent ( in ) :: node_type !! coordinates ( current_index , 1 ) = dble ( ix ); coordinates ( current_index , 2 ) = dble ( iy ); coordinates ( current_index , 3 ) = dble ( iz ); !write(*,*) coordinates(current_index,1:3); if ( trim ( node_type ) == 'hexagonal' ) then coordinates ( current_index , 1 ) = coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( coordinates ( current_index , 2 ), 2.0_wp )); coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2.0_wp ) * coordinates ( current_index , 2 ); endif ! end subroutine calculate_coordinates !======================================================================================== subroutine find_best_match_unit ( kohonen_map , current_prototype , ihit , jhit , khit , dist_hit ) !======================================================================================== !! Subroutine to calculate the best match unit class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_prototype ), intent ( inout ) :: current_prototype !! A `kohonen_prototype` object integer , intent ( out ) :: ihit , jhit , khit !! Integer variables for the coordinates of the BMU real ( kind = wp ), intent ( out ) :: dist_hit !! Real variable with the distance to the BMU integer :: debug_option , idbg , ix , iy , iz , number_variables real ( kind = wp ) :: dist ! idbg = kohonen_map % parameters % idbg ; debug_option = kohonen_map % parameters % debug_level ; number_variables = kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e7 ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); !write(*,*) 'dist= ',dist if ( debug_option > 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ); write ( idbg , * ) ix , iy , iz , dist ; endif dist = dist / float ( number_variables ); if ( dist < dist_hit ) then dist_hit = dist ; ihit = ix ; jhit = iy ; khit = iz ; endif enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! !        write(*,*) 'find= ',ihit,jhit,khit,dist_hit return ! end subroutine find_best_match_unit !======================================================================================== subroutine update_weights ( kohonen_map , current_values , ihit , jhit , khit ,& maximum_radius , iteration ) !======================================================================================== !!    Subroutine to update the weights class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: current_values !! A real array with the values of the current unit integer , intent ( inout ) :: ihit , jhit , khit , iteration !! Integer variables with the coordinates of the unit (neuron) to be modified real ( kind = wp ), intent ( inout ) :: maximum_radius !! Real variable with the maximum radius of the neighborhood real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: prototype_values real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: winner_values , term1 , term2 integer :: nx , ny , nz , debug_option , ic , current_pos , ineigh , jneigh , kneigh , idbg real ( kind = wp ) :: time_factor , current_radius , alpha , sigma2 , h_neighborhood , real_distance , term3 real ( kind = wp ) :: distance_ratio , geometric_distance2 , eps , current_distance , lambda !type(influence_function) :: influence_func real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: v_vector real ( kind = wp ) :: v_vector_norm , r , Psi character ( len = NUMCHAR ) :: m_estimator ! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; debug_option = kohonen_map % parameters % debug_level ; idbg = kohonen_map % parameters % idbg ; lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); time_factor = 1.0_wp - dble ( iteration ) / & dble ( kohonen_map % parameters % number_epochs * kohonen_map % parameters % number_patterns ); !current_radius = max(maximum_radius*real(1001-iteration)/1000.0 + 0.9999999999,4.0d0); current_radius = max ( maximum_radius * time_factor , 4.0_wp ); !alpha = max(kohonen_map%parameters%learning_rate*(1.0d0-real(iteration)/1000.0),0.01d0); alpha = max ( kohonen_map % parameters % learning_rate * time_factor , 0.01_wp ); sigma2 = current_radius ** 2 ; ! m_estimator = trim ( kohonen_map % parameters % m_estimator ); ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance < current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters % neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * dexp ( - 0.5_wp * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option > 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters % som_type )) case ( 'normal_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); !v_vector=(current_values-prototype_values); !v_vector_norm=dsqrt(sum(v_vector**2)); !r=v_vector_norm/sigma; !Psi=influence_func%calculate(m_estimator,r); !prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'visom' ) !write(*,*) trim(kohonen_map%parameters%som_type) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh == ihit ) . and . ( jneigh == jhit ) . and . ( kneigh == khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); eps = max ( 1.0_wp * time_factor , 0.0_wp ); term3 = 1.0_wp ; !((1.0d0-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * & ( distance_ratio - 1.0_wp ) * term3 ); endif !write(*,*) iteration,dsqrt(real_distance),dsqrt(geometric_distance2)*lambda,distance_ratio call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'robust_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); ! v_vector=(current_values-prototype_values); ! v_vector_norm=dsqrt(sum(v_vector**2)); ! r=v_vector_norm/sigma; ! Psi=influence_func%calculate(m_estimator,r); ! prototype_values=prototype_values+sigma*h_neighborhood*Psi*v_vector/v_vector_norm; call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo !ic ! end subroutine update_weights !======================================================================================== subroutine calculate_distance_between_prototypes ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the distance between the prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object integer :: nx , ny , ix , iy , iz , ix1 , iy1 , iz1 , pos , pos1 ! type ( kohonen_prototype ) :: current_prototype , current_prototype1 !! nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_prototype = kohonen_map % grid ( ix , iy , iz ); pos = position2index ( ix , iy , iz , nx , ny ); do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); pos1 = position2index ( ix1 , iy1 , iz1 , nx , ny ) current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); kohonen_map % distance ( pos , pos1 ) = current_prototype1 % distance ( current_prototype ,& kohonen_map % distance_function ); enddo !ix1 enddo !iy1 enddo !iz1 enddo !ix enddo !iy enddo !iz !$OMP end parallel do ! if ( kohonen_map % parameters % train_option < 3 ) then do ix = 1 , size ( kohonen_map % distance , 1 ) write ( kohonen_map % parameters % idist , * ) ( kohonen_map % distance ( ix , iy ), iy = 1 , size ( kohonen_map % distance , 2 )); enddo !ix endif ! end subroutine calculate_distance_between_prototypes !======================================================================================== subroutine find_bmu_grid ( kohonen_map , input_data ) !======================================================================================== !! Subroutine to calculate the best match unit over the grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array with the input data integer :: nx , ny , nz , ix , iy , iz , ihit , jhit , khit , idat , pat_hit type ( kohonen_prototype ) :: current_prototype real ( kind = wp ) :: dist , dist_min ! do idat = 1 , size ( input_data ) dist_min = 1.0e7 ; ihit = 0 ; jhit = 0 ; khit = 0 ; call input_data ( idat )% get ( current_prototype ); !$OMP parallel do do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( kohonen_map % parameters % number_variables ) if ( dist < dist_min ) then dist_min = dist ; ihit = ix ; jhit = iy ; khit = iz ; pat_hit = idat ; endif enddo enddo enddo !$OMP end parallel do kohonen_map % grid_pattern_index ( ihit , jhit , khit ) = pat_hit ; kohonen_map % cells_index ( idat , 1 ) = ihit ; kohonen_map % cells_index ( idat , 2 ) = jhit ; kohonen_map % cells_index ( idat , 3 ) = khit ; !    write(*,*) 'BMU= ',idat,ihit,jhit,khit,dist_min enddo ! ! end subroutine find_bmu_grid !======================================================================================== subroutine calculate_u_matrix ( kohonen_map ) !======================================================================================== !! Subroutine to calculate  the u_matrix class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object character ( len = NUMCHAR ) :: type_ integer :: nx , ny , nz , nt , ierr , ix , iy , iz , cx , cy , cz , nxu , nyu , nzu real ( kind = wp ) :: dist , u_temp ! type_ = trim ( kohonen_map % parameters % node_type ); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; ! nxu = size ( kohonen_map % u_matrix , 1 ); nyu = size ( kohonen_map % u_matrix , 2 ); nzu = size ( kohonen_map % u_matrix , 3 ); ! select case ( trim ( type_ )) ! case ( 'rectangular' ) !call kohonen_map%calculate_u_matrix_rectangular(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); ! horizontal if ( ix < nx ) then cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif !vertical if ( iy < ny ) then cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; endif ! if ( iz < nz ) then cx = ix ; cy = iy ; cz = iz + 1 ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! Diagonal if ( ix < nx . and . iy < ny ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = dist + kohonen_map % grid ( ix , cy , iz )% distance ( kohonen_map % grid ( cx , iy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; endif enddo enddo enddo ! do iz = 1 , size ( kohonen_map % u_matrix , 3 ), 2 do iy = 1 , size ( kohonen_map % u_matrix , 2 ), 2 do ix = 1 , size ( kohonen_map % u_matrix , 1 ), 2 u_temp = 0.0d0 ; if ( ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 ) . and . & iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == 1 . and . ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( iy == size ( kohonen_map % u_matrix , 2 ) . and . ix > 1 . and .& ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == 1 . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = 0.0_wp ; endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! case ( 'hexagonal' ) !call kohonen_map%calculate_u_matrix_hexagonal(); ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); if ( ix < nx ) then !horizontal cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! if ( iy < ny ) then !diagonals cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; if ( mod ( iy , 2 ) == 0 . and . ix < nx ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; elseif ( mod ( iy , 2 ) == 1 . and . ix > 1 ) then cx = ix - 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 2 , 2 * iy , 2 * iz - 1 ) = dist ; endif endif enddo enddo enddo ! do iz = 1 , nzu , 2 ; do iy = 1 , nyu , 2 ; do ix = 1 , nxu , 2 ; u_temp = 0.0d0 ; if ( ix > 1 . and . iy > 1 . and . ix < nxu . and . iy < nyu ) then !middle part of the map u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); endif nt = 6 ; elseif ( iy == 1 . and . ix > 1 . and . ix < nxu ) then ! upper edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == nyu . and . ix > 1 . and . ix < nxu ) then ! lower edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); endif nt = 4 ; elseif ( ix == 1 . and . iy > 1 . and . iy < nyu ) then ! left edge u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); nt = 5 ; endif elseif ( ix == nxu . and . iy > 1 . and . iy < nyu ) then ! right edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ); nt = 5 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; endif elseif ( ix == 1 . and . iy == 1 ) then ! top left corner u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == nxu . and . iy == 1 ) then ! top right corner u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == nyu ) then ! bottom left corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); nt = 3 ; endif ; elseif ( ix == nxu . and . iy == nyu ) then ! bottom right corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ); nt = 3 ; else u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; endif endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! end select ! if ( kohonen_map % parameters % train_option < 3 ) then do iz = 1 , size ( kohonen_map % u_matrix , 3 ); write ( kohonen_map % parameters % iumat , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % u_matrix , 1 ); write ( kohonen_map % parameters % iumat , '(100f10.5)' ) ( kohonen_map % u_matrix ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % u_matrix , 2 )); enddo enddo endif ! end subroutine calculate_u_matrix !======================================================================================== subroutine calculate_u_matrix_hexagonal ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matrix for an hexagonal grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_hexagonal !======================================================================================== subroutine calculate_u_matrix_rectangular ( kohonen_map ) !======================================================================================== !! Subroutine to calculate the u_matix for a rectangular grid class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object end subroutine calculate_u_matrix_rectangular !======================================================================================== subroutine get_u_matrix_som ( kohonen_map , u_matrix ) !======================================================================================== !! Subroutine to get the u_matrix from a SOM class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:,:), intent ( out ) :: u_matrix !! A real array to return the u_matrix u_matrix = kohonen_map % u_matrix ; ! end subroutine get_u_matrix_som !======================================================================================== subroutine get_prototypes ( kohonen_map , prototypes ) !======================================================================================== !! Subroutine to get SOM prototypes class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: prototypes !! A real array to return the values of the SOM prototypes integer :: i , j , k , pos , nvar1 , nvar2 integer , dimension ( 1 ) :: nvar real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 ,& kohonen_map % parameters % number_variables2 ) :: current_prototype real ( kind = wp ), dimension ( kohonen_map % parameters % number_variables1 * & kohonen_map % parameters % number_variables2 ) :: current_prototype1 ! nvar1 = kohonen_map % parameters % number_variables1 ; nvar2 = kohonen_map % parameters % number_variables2 ; nvar ( 1 ) = nvar1 * nvar2 pos = 0 ; do k = 1 , size ( kohonen_map % grid , 3 ) do j = 1 , size ( kohonen_map % grid , 2 ); do i = 1 , size ( kohonen_map % grid , 1 ); pos = pos + 1 ; call kohonen_map % grid ( i , j , k )% get_prototype ( current_prototype ); current_prototype1 ( 1 : nvar1 * nvar2 ) = reshape ( current_prototype , nvar ) prototypes ( pos ,:) = current_prototype1 ; enddo enddo enddo ! end subroutine get_prototypes !======================================================================================== function calculate_sigma ( kohonen_map , input_data , seed ) result ( sigma ) !======================================================================================== !!    Function to calculate the scaling factor sigma class ( self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_data !! A real array with the input data integer , intent ( inout ), optional :: seed !! An integer with the random seed real ( kind = wp ) :: sigma !! A real variable with the value of sigma integer :: ndat , nvar , seed1 , nx , ny , nz , nxyz , ierr , i , j real ( kind = wp ), allocatable :: sample_pos (:), p_vector (:,:), sigma_table (:,:) real ( kind = wp ), allocatable :: current_sigma (:) integer , allocatable :: sample_index (:) type ( quicksort ) :: qsort ! if (. not . present ( seed )) then seed1 = 12345 ; else seed1 = seed ; endif ! ndat = size ( input_data , 1 ); nvar = size ( input_data , 2 ); ! !kohonen_map%parameters=training_parameters(1); nx = kohonen_map % parameters % number_nodes_nx ; ny = kohonen_map % parameters % number_nodes_ny ; nz = kohonen_map % parameters % number_nodes_nz ; nxyz = nx * ny * nz ; allocate ( sample_pos ( ndat ), stat = ierr ); allocate ( sample_index ( ndat ), stat = ierr ); allocate ( p_vector ( nxyz , nvar ), stat = ierr ); allocate ( sigma_table ( ndat , nxyz ), stat = ierr ); allocate ( current_sigma ( ndat ), stat = ierr ); !call sgrnd(seed1); do i = 1 , size ( sample_pos ); sample_pos ( i ) = kohonen_map % rnumber_grator % generate (); enddo !call grnd_array(sample_pos); do i = 1 , nxyz sample_index ( i ) = i ; enddo ! call qsort % sort ( sample_pos , sample_index ); ! !  define p vector (See Lopez-Rubio et al, 2015) ! p_vector ( 1 : nxyz , 1 : nvar ) = input_data ( sample_index ( 1 : nxyz ), 1 : nvar ); ! !  Calculate the distance between the input data and the selected prototypes ! do i = 1 , ndat do j = 1 , nxyz sigma_table ( i , j ) = sum (( input_data ( i ,:) - p_vector ( j ,:)) ** 2 ); enddo enddo ! do j = 1 , nxyz current_sigma ( 1 : ndat ) = sigma_table ( 1 : ndat , j ); !(sample_index(i)=i,i=1,ndat) call qsort % sort ( current_sigma , sample_index ); !    if(current_sigma(1) > 1d-10) then !       current_sigma_value() enddo ! deallocate ( sample_pos , sample_index , p_vector , sigma_table , current_sigma ); ! end function calculate_sigma !======================================================================================== subroutine external_train_map ( x , nvar , npat , nx , ny , nepoch , alpha , grid_type ,& distance_type , neigh_type , toroidal , prot , distortion ,& u_matrix , coords , number_patterns , node_index ) bind ( C , name = \"train_som\" ) !======================================================================================== !!    Subroutine to connect the self_organizing_map module to R o C use , intrinsic :: iso_c_binding , only : c_double , c_int , c_char !! Import section real ( kind = wp ), parameter :: version = 0.1_wp ; !! Parameter version character ( len =* ), parameter :: program_name = \"som_train\" ; !! Parameter name of the function integer ( c_int ), intent ( in ) :: nvar , npat !! Integer variables to indicate the number of variables and patterns integer ( c_int ), intent ( in ) :: nx , ny !! Integer variables to indicate the number of nodes of the SOM integer ( c_int ), intent ( in ) :: nepoch !! Integer variables to indicate the number of epochs for training integer ( c_int ), intent ( in ) :: toroidal !! Integer variable to indicate if a toroidal grid is used real ( c_double ), intent ( out ) :: prot ( nx * ny , nvar ) !! Real array for the prototypes real ( c_double ), intent ( out ) :: distortion ( nepoch ) !! Real array for the distortion measure (error during training) real ( c_double ), intent ( out ) :: u_matrix ( 2 * nx - 1 , 2 * ny - 1 ) !! Real array for the u_matrix real ( c_double ), intent ( out ) :: coords ( nx * ny , 3 ) !! Real array for the grid coordinates of the SOM integer ( c_int ), intent ( out ) :: number_patterns ( nx , ny ) !! Integer array with the number of hits for each neuron integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! Integer array with the index node for all the neurons of the SOM real ( c_double ), intent ( in ) :: x ( npat , nvar ) !! Real array with the input patterns real ( c_double ), intent ( in ) :: alpha !! Real value with the initial learning rate integer ( c_int ), intent ( in ) :: grid_type !! Integer variable to indicate the type of grid integer ( c_int ), intent ( in ) :: distance_type !! Integer variable to indicate the distance type integer ( c_int ), intent ( in ) :: neigh_type !! Integer variable to indicate the neighborhood type type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters real ( kind = wp ), dimension ( nvar , 1 ) :: var integer :: i , j , k , ierr , pos , ihit , jhit , khit , nx1 , ny1 type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), dimension ( nx * ny , nvar ) :: prototypes real ( kind = wp ), dimension ( nvar , 1 ) :: temp ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = nepoch ; parameters ( 1 )% learning_rate = alpha ; parameters ( 1 )% random_seed_ = 12345 ; if ( grid_type == 0 ) then parameters ( 1 )% node_type = \"rectangular\" ; !\"hexagonal\" !rectangular, hexagonal elseif ( grid_type == 1 ) then parameters ( 1 )% node_type = \"hexagonal\" ; endif parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" ; parameters ( 1 )% pattern_file = \"NOFILE\" ; parameters ( 1 )% output_file = \"NOFILE\" ; parameters ( 1 )% distance_type = \"euclidean\" ; !\"euclidean\" !euclidean, manhattan, correlation, correlation2 if ( neigh_type == 0 ) then parameters ( 1 )% neighborhood_type = \"bubble\" ; elseif ( neigh_type == 1 ) then parameters ( 1 )% neighborhood_type = \"gaussian\" ; !gaussian,bubble endif parameters ( 1 )% som_type = \"normal_som\" !,visom if ( toroidal == 1 ) then parameters ( 1 )% toroidal_grid = . TRUE .; else parameters ( 1 )% toroidal_grid = . FALSE .; endif ! ! ADDED TO AVOID PRINTING UNIT INFO (THE CAUSE IS UNKNONW) ! write(*,*) '' ! write(*,'(A,A,f10.5)') trim(program_name),' version: ',version ! write(*,*) '' allocate ( input_patterns ( npat ), stat = ierr ); do i = 1 , npat var ( 1 : nvar , 1 ) = x ( i , 1 : nvar ) !write(*,*) i,var call input_patterns ( i )% create ( var ); !    call input_patterns(i)%print(); enddo ! Create SOM call my_som % create ( parameters ); ! Train SOM call my_som % train ( input_patterns ); ! Extract results pos = 0 k = 1 nx1 = nx ; ny1 = ny ; do j = 1 , ny do i = 1 , nx pos = position2index ( i , j , k , nx1 , ny1 ); !write(*,*) i,j,pos,i+(j-1)*nx call my_som % grid ( i , j , k )% get_prototype ( temp ); !position2index() prototypes ( pos , 1 : nvar ) = temp ( 1 : nvar , 1 ); enddo enddo ! ! Get the results in the arrays ! distortion = my_som % distortion u_matrix ( 1 : 2 * nx - 1 , 1 : 2 * ny - 1 ) = my_som % u_matrix (:,:, 1 ); !do i=1,size(my_som%coordinates,1); !write(*,*) my_som%coordinates(i,1:3); !   coords(i,1:3)=my_som%coordinates(i,1:3); !enddo coords = my_som % coordinates ; !coords(1:nx*nx,1)=my_som%coordinates(:,1); !coords(1:nx*nx,2)=my_som%coordinates(:,2); !coords(1:nx*nx,3)=my_som%coordinates(:,3); number_patterns = my_som % number_patterns (:,:, 1 ); node_index = my_som % cells_index prot = prototypes ; ! call my_som % destroy (); ! do i = 1 , npat call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); ! ! ! write(*,*) ! write(*,'(A,A,f10.5,2X,A)') trim(program_name),' version: ',version,'Finished' ! write(*,*) ! end subroutine external_train_map !======================================================================================== subroutine external_predict_map ( prot , nx , ny , new_pat , npat , nvar , node_index ) & bind ( C , name = \"predict_som\" ) !======================================================================================== !!    Subroutine to connect this module to R use , intrinsic :: iso_c_binding , only : c_double , c_int integer ( c_int ), intent ( in ) :: nx , ny , npat , nvar real ( c_double ), intent ( in ) :: prot ( nx * ny , nvar ), new_pat ( npat , nvar ) integer ( c_int ), intent ( out ) :: node_index ( npat , 3 ) !! type ( self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters integer :: ipat , inode , i_hit , nx1 , ny1 , nz1 , cx , cy , cz , ix , iy , iz , pos , ierr real ( kind = wp ) :: dist , dist_hit real ( kind = wp ), dimension ( nvar , 1 ) :: temp type ( kohonen_pattern ), dimension ( npat ) :: input_data ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx ; parameters ( 1 )% number_nodes_ny = ny ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = 1 ; parameters ( 1 )% learning_rate = 0.0d0 ; parameters ( 1 )% random_seed_ = 12345 ; parameters ( 1 )% node_type = \"hexagonal\" parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" parameters ( 1 )% pattern_file = \"NOFILE\" parameters ( 1 )% output_file = \"NOFILE\" parameters ( 1 )% distance_type = \"euclidean\" !\"euclidean\" !euclidean, manhattan, correlation, correlation2 parameters ( 1 )% neighborhood_type = \"gaussian\" !gaussian,bubble parameters ( 1 )% som_type = \"normal_som\" !,visom parameters ( 1 )% toroidal_grid = . TRUE . ! ! call parameters(1)%print(); ! call my_som % create ( parameters ); ! pos = 0 ; iz = 1 ; do iy = 1 , ny do ix = 1 , nx pos = pos + 1 ; temp ( 1 : nvar , 1 ) = prot ( pos , 1 : nvar ) call my_som % grid ( ix , iy , iz )% set_prototype ( temp ) enddo enddo ! do ipat = 1 , npat temp ( 1 : nvar , 1 ) = new_pat ( ipat , 1 : nvar ); call input_data ( ipat )% create ( temp ); enddo ! call my_som % predict ( input_data , node_index ); ! call my_som % destroy (); ! do ipat = 1 , size ( input_data ); call input_data ( ipat )% destroy (); enddo ! end subroutine external_predict_map ! end module self_organizing_map_utilities","tags":"","loc":"sourcefile\\self_organizing_map_utilities.f90.html"},{"title":"kohonen_map_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class for kohonen maps This file depends on sourcefile~~kohonen_map_base_utilities.f90~~EfferentGraph sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_map_base_utilities.f90~~AfferentGraph sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines an abstract class for kohonen maps module kohonen_map_base_utilities !! This module defines an abstract class for kohonen maps use precision_utilities , only : wp ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_pattern_utilities , only : kohonen_pattern ; ! implicit none ! type , abstract :: kohonen_map_base !! Abstract Class to represent a template for a kohonen map contains procedure ( kohonen_map_constructor ), public , deferred :: create procedure ( kohonen_map_destructor ), public , deferred :: destroy procedure ( kohonen_map_function1 ), public , deferred :: train procedure ( kohonen_map_function2 ), public , deferred :: predict end type kohonen_map_base !! abstract interface !======================================================================================== subroutine kohonen_map_constructor ( kohonen_map , training_parameters ) !======================================================================================== !! Template function for the constructor of a kohonen map import :: kohonen_map_base import :: kohonen_layer_parameters !! Import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` object end subroutine kohonen_map_constructor !======================================================================================== subroutine kohonen_map_destructor ( kohonen_map ) !======================================================================================== !! Template function for the destructor of a kohonen map import :: kohonen_map_base !! Import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object end subroutine kohonen_map_destructor !======================================================================================== subroutine kohonen_map_function1 ( kohonen_map , input_data ) !======================================================================================== !!   Template function for the training function of a kohonen map import :: kohonen_map_base import :: kohonen_pattern !! import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! An array of `kohonen_pottern` objects end subroutine kohonen_map_function1 !======================================================================================== subroutine kohonen_map_function2 ( kohonen_map , input_data , map_output ) !======================================================================================== !!   Template function for the prediction function of a kohonen map import :: kohonen_map_base import :: kohonen_pattern !! import section class ( kohonen_map_base ) :: kohonen_map !! A `kohonen_map_base` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! An array of `kohonen_pottern` objects integer , dimension (:,:), intent ( out ) :: map_output !! An integer array end subroutine kohonen_map_function2 ! end interface ! end module kohonen_map_base_utilities","tags":"","loc":"sourcefile\\kohonen_map_base_utilities.f90.html"},{"title":"random_generator_base_utilities.f90 – KohonenF08","text":"Define an abstract class random_generator_base to be used to derive different types of \n random number generators to be use with ATALIB03 This file depends on sourcefile~~random_generator_base_utilities.f90~~EfferentGraph sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~random_generator_base_utilities.f90~~AfferentGraph sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/06/2023 !! version: 0.1 !! Define an abstract class random_generator_base to be used to derive different types of !!  random number generators to be use with ATALIB03 module random_generator_base_utilities ! use precision_utilities , only : wp ; ! implicit none ; ! type , abstract :: random_generator_base !! Abstract class to derive random number generator classes contains !  * constructor procedure ( random_generator_constructor ), deferred :: create !  * destructor procedure ( random_generator_destructor ), deferred :: destroy !  * generate procedure ( random_generator_generate ), deferred :: generate !     procedure(random_generator_initialize),deferred :: initialize end type random_generator_base ! abstract interface !======================================================================================== subroutine random_generator_constructor ( generator , iseed ) !======================================================================================== !! Template of the constructor of the classes derived from the random_generator class. import :: random_generator_base !! random_generator_base class ( random_generator_base ) :: generator !! generator: A random_generator_base object integer , intent ( in ), optional :: iseed !! iseed: An integer with the seed of the random generator. end subroutine random_generator_constructor !======================================================================================== subroutine random_generator_destructor ( generator ) !======================================================================================== !! Template of the destructor of the classes derived from the random_generator class. import :: random_generator_base !! random_generator_base class ( random_generator_base ) :: generator !! generator: A random_generator_base object end subroutine random_generator_destructor !======================================================================================== function random_generator_generate ( generator ) result ( r ) !======================================================================================== !! Template of the function used to generate realizations of the random numbers in the !! classes derived from the random_generator class. import :: random_generator_base import :: wp !! random_generator_base class ( random_generator_base ) :: generator !! generator: A random_generator_base object real ( kind = wp ) :: r !! r: A real number end function random_generator_generate end interface !    ! end module random_generator_base_utilities","tags":"","loc":"sourcefile\\random_generator_base_utilities.f90.html"},{"title":"sort_base_utilities.f90 – KohonenF08","text":"Define an abstract class to represent a generic sort procedure. This file depends on sourcefile~~sort_base_utilities.f90~~EfferentGraph sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~sort_base_utilities.f90~~AfferentGraph sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 06/10/2023 !! version: 0.1 !!  Define an abstract class to represent a generic sort procedure. module sort_base_utilities ! use precision_utilities , only : wp ; ! implicit none ; ! type , abstract :: sort_base !! Abstract class to represent a generic sort algoritm contains ! METHODS !   * sort procedure ( sort_procedure ), deferred , pass :: sort end type sort_base ! abstract interface !=============================================================================================================== subroutine sort_procedure ( my_sort , list , order ) !=============================================================================================================== !! Subroutine to sort an array import :: sort_base import :: wp !! import sort_base class ( sort_base ), intent ( inout ) :: my_sort !! my_sort: A sort_base object real ( kind = wp ), dimension (:), intent ( inout ) :: list !! list: A real vector integer , dimension (:), intent ( inout ) :: order !! order: An integer vector end subroutine sort_procedure ! end interface ! end module sort_base_utilities","tags":"","loc":"sourcefile\\sort_base_utilities.f90.html"},{"title":"logger_utilities.f90 – KohonenF08","text":"This module includes the definition of a class called logger that is used \nto log messages on the screen during the development or running of a given \napplication This file depends on sourcefile~~logger_utilities.f90~~EfferentGraph sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~logger_utilities.f90~~AfferentGraph sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Arjen Markus, Oscar Garcia-Cabrejo !! date: 06/09/2023 !! version: 0.1 !! This module includes the definition of a class called logger that is used !! to log messages on the screen during the development or running of a given !! application module logger_utilities ! use constants_utilities , only : NUMCHAR ; ! implicit none ; ! private ; ! type logger private !! The Logger class is used to store all the variables related to the units of !! files used to store or print messages during the development (debugging ) or !! running integer :: fileunit , stdout logical :: activate_screen , activate_file , timestamp logical :: initialized , stoponerror character ( len = NUMCHAR ) :: level_string_volume , level_string_chapter , level_string_section character ( len = NUMCHAR ) :: level_string_subsection contains procedure , public :: create => create_logger procedure , public :: destroy => destroy_logger procedure , public :: startup procedure , public :: shutdown procedure , public :: is_initialized procedure , public :: message procedure , public :: write procedure , private :: get_available_unit procedure , private :: configure_logical procedure , private :: configure_integer procedure , private :: configure_character generic , public :: configure => configure_logical , configure_integer , configure_character !        generic,public :: get procedure , public :: get_unit procedure , public :: delimiter procedure , public :: get_delimiter procedure , public :: reset procedure , public :: error end type logger ! type ( logger ) :: global_logger ; ! public :: logger , global_logger ! contains !======================================================================================== subroutine create_logger ( current_log ) !======================================================================================== !! logger constructor class ( logger ) :: current_log !! a logger object current_log % initialized = . FALSE .; current_log % activate_screen = . TRUE .; current_log % activate_file = . TRUE .; current_log % timestamp = . FALSE .; current_log % fileunit = 10 ; current_log % stdout =- 1 ; current_log % stoponerror = . TRUE .; ! end subroutine create_logger !======================================================================================== subroutine destroy_logger ( current_log ) !======================================================================================== !! Logger destructor class ( logger ) :: current_log !! A logger object current_log % level_string_volume = '' current_log % level_string_chapter = '' current_log % level_string_section = '' ! end subroutine destroy_logger !======================================================================================== subroutine startup ( current_log , log_file , append_ ) !======================================================================================== !! Subroutine to initialize a logger object class ( logger ) :: current_log !! A logger object character ( len =* ) :: log_file !! A character variable with the name of the file associated to the logger logical , intent ( in ), optional :: append_ !! A logical (optional) variable to indicate if appending to an existing file !!          is desired ! logical :: append_real ! if ( present ( append_ )) then append_real = append_ ; else append_real = . TRUE .; endif if ( current_log % initialized ) then call current_log % error ( 'Logger not initialized' ); else current_log % fileunit = current_log % get_available_unit (); if ( append_real ) then open ( current_log % fileunit , file = log_file , status = 'unknown' , action = 'write' , position = 'append' ); else open ( current_log % fileunit , file = log_file , status = 'unknown' , action = 'write' , form = 'formatted' ); endif current_log % initialized = . TRUE .; endif ! end subroutine startup !======================================================================================== subroutine shutdown ( current_log ) !======================================================================================== !! Subroutine to turn-off the logger class ( logger ) :: current_log !! A logger object ! current_log % initialized = . FALSE .; ! end subroutine shutdown !======================================================================================== function is_initialized ( current_log ) result ( initialized ) !======================================================================================== !! Function to check if a logger is initialized class ( logger ) :: current_log !! A logger object logical :: initialized !!  A logical variable initialized = current_log % initialized ; ! end function is_initialized !======================================================================================== subroutine reset ( current_log ) !======================================================================================== !! Subroutine to reset the logger class ( logger ) :: current_log !! A logger object current_log % activate_screen = . TRUE .; current_log % activate_file = . TRUE .; current_log % timestamp = . FALSE .; ! end subroutine reset !======================================================================================== subroutine message ( current_log , msg ) !======================================================================================== !! Subroutine to send a message to the logger class ( logger ) :: current_log !! A logger object character ( len =* ) :: msg !! A character variable with the message to send to the logger ! character ( len = NUMCHAR ) :: date_string character ( len = NUMCHAR ) :: time_string character ( len = NUMCHAR ) :: stamp ! if ( current_log % timestamp ) then call date_and_time ( date = date_string , time = time_string ); write ( stamp , '(11A)' ) date_string ( 1 : 4 ), '-' , date_string ( 5 : 6 ), '-' , date_string ( 7 : 8 ), ' ' ,& time_string ( 1 : 2 ), ':' , time_string ( 3 : 4 ), ':' , time_string ( 5 : 6 ); else stamp = ' ' ; endif if ( current_log % activate_screen ) then if ( current_log % timestamp ) then call current_log % write ( current_log % stdout , trim ( stamp ) // ' ' // trim ( msg )); else call current_log % write ( current_log % stdout , trim ( msg )); endif endif if ( current_log % activate_file ) then if ( current_log % timestamp ) then call current_log % write ( current_log % fileunit , trim ( stamp ) // ' ' // trim ( msg )); else call current_log % write ( current_log % fileunit , trim ( msg )); endif endif ! end subroutine message !======================================================================================== subroutine write ( current_log , unit_ , msg ) !======================================================================================== !! Subroutine to write a message in a file associated with the logger class ( logger ) :: current_log !! A logger object integer , intent ( in ) :: unit_ !! An integer variable with the value of the output unit character ( len =* ) :: msg !! A character variable with the message to be written in the output unit character ( len = NUMCHAR ) :: filename integer :: unit1 ! unit1 = unit_ ; if ( unit1 == - 1 ) then write ( * , '(A)' ) trim ( msg ); else write ( unit1 , '(A)' ) trim ( msg ); inquire ( unit1 , name = filename ); close ( unit1 ); open ( unit1 , file = trim ( filename ), action = 'write' , status = 'unknown' , position = 'append' ); endif ! end subroutine write !======================================================================================== function get_available_unit ( current_log ) result ( un ) !======================================================================================== !! Function to get the next available unit class ( logger ) :: current_log !! A logger object integer :: un !! An integer variable with the number of the next available unit ! logical :: check_unit integer :: iunit ! if ( current_log % fileunit /= 10 ) then inquire ( unit = un , opened = check_unit ); if (. not . check_unit ) then un = current_log % fileunit ; return ; endif else do iunit = 10 , 99 inquire ( unit = iunit , opened = check_unit ) if (. not . check_unit ) then un = iunit ; current_log % fileunit = un ; return ; endif enddo endif ! end function get_available_unit !======================================================================================== subroutine configure_logical ( current_log , option , value ) !======================================================================================== !! Subroutine to define the logger state class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: option !! A character variable with the name of the state to be defined logical , intent ( in ) :: value !! A logical variable ! character ( len = NUMCHAR ) :: message ! select case ( option ) case ( \"timestamp\" ) current_log % timestamp = value ; case ( \"writeonstdout\" ) current_log % activate_screen = value ; case ( \"writeonlogfile\" ) current_log % activate_file = value ; case ( \"stoponerror\" ) current_log % stoponerror = value ; case default write ( message , \"(A,A,A,l5,A)\" ) \"Unknown option \" , option , & \" for value \" , value , \" in log_configure_logical\" call current_log % error ( message ); end select ! end subroutine configure_logical !======================================================================================== subroutine configure_integer ( current_log , option , value ) !======================================================================================== !! Subroutine to define a logger integer state class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: option !! A character variable with the name of the state to be defined integer , intent ( in ) :: value !! An integer variable character ( len = NUMCHAR ) :: message ! select case ( option ) case ( \"logfileunit\" ) current_log % fileunit = value case default write ( message , \"(A,A,A,I5,A)\" ) \"Unknown option \" , option , & \" for value \" , value , \" in log_configure_integer\" call current_log % error ( message ); end select ! end subroutine configure_integer !======================================================================================== subroutine configure_character ( current_log , option , value ) !======================================================================================== !! Subroutine to define a logger character state class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: option !! A character variable with the name of the state to be defined character ( len =* ), intent ( in ) :: value !! A character variable character ( len = NUMCHAR ) :: message ! select case ( option ) case ( \"volume\" ) current_log % level_string_volume = value ; case ( \"chapter\" ) current_log % level_string_chapter = value ; case ( \"section\" ) current_log % level_string_section = value ; case ( \"subsection\" ) current_log % level_string_subsection = value ; case default write ( message , \"(A,A,A,A,A)\" ) \"Unknown option \" , option , & \" for value \" , value , \" in log_configure_character\" ; call current_log % error ( message ); end select ! end subroutine configure_character !======================================================================================== subroutine delimiter ( current_log , level ) !======================================================================================== !! Subroutine that defines the delimiter in a logger repport class ( logger ) :: current_log !! A logger object character ( len =* ), optional :: level !! A character variable with the definition of the delimiter ! character ( len = NUMCHAR ) :: used_level character ( len = NUMCHAR ) :: msg ! if ( present ( level )) then used_level = level ; else used_level = 'volume' ; endif call current_log % get_delimiter ( used_level , msg ); call current_log % message ( msg ( 1 : 30 )); ! end subroutine delimiter !======================================================================================== subroutine get_delimiter ( current_log , level , msg ) !======================================================================================== !! Subroutine to get the delimiter text integer , parameter :: LOG_LEVEL_DELIMITER_LENGTH = 30 character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_volume = \"==============================\" ; character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_chapter = \"------------------------------\" ; character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_section = \"******************************\" ; character ( len = LOG_LEVEL_DELIMITER_LENGTH ), parameter :: log_level_string_subsection = \"++++++++++++++++++++++++++++++\" ; class ( logger ) :: current_log !! A logger object character ( len =* ) :: level !! A character variable character ( len = 100 ) :: msg !! A character variable select case ( level ) case ( 'volume' ) write ( msg , * ) trim ( log_level_string_volume ); case ( 'chapter' ) write ( msg , * ) trim ( log_level_string_chapter ); case ( 'section' ) write ( msg , * ) trim ( log_level_string_section ); case ( 'subsection' ) write ( msg , * ) trim ( log_level_string_subsection ); case default ! NOTE : ! We do not use m_exception here to limit the dependencies of ! such a low level utility. write ( * , * ) \"Bad value for the message level:\" , level write ( * , * ) stop end select ! end subroutine get_delimiter !======================================================================================== function get_unit ( current_log ) result ( logger_unit ) !======================================================================================== !! Function to get the logger unit class ( logger ) :: current_log !! A logger object integer :: logger_unit !! An integer variable with the logger unit logger_unit = current_log % fileunit ! end function get_unit !======================================================================================== subroutine error ( current_log , message ) !======================================================================================== !! Subroutine to print an error message class ( logger ) :: current_log !! A logger object character ( len =* ), intent ( in ) :: message !! A character varaible with the error message write ( 6 , \"(A)\" ) \"Error in m_logger.\" write ( 6 , \"(A)\" ) trim ( message ) stop ; ! end subroutine error ! end module logger_utilities","tags":"","loc":"sourcefile\\logger_utilities.f90.html"},{"title":"kohonen_pattern_utilities.f90 – KohonenF08","text":"This module defines a class called kohonen_pattern to store the input patterns This file depends on sourcefile~~kohonen_pattern_utilities.f90~~EfferentGraph sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_pattern_utilities.f90~~AfferentGraph sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a class called `kohonen_pattern` to store the input patterns module kohonen_pattern_utilities !! This module defines a class called `kohonen_pattern` to store the input patterns use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use kohonen_prototype_utilities , only : kohonen_prototype ; ! implicit none ! type kohonen_pattern !!  Class to represent a container for input data to  a kohonen map private type ( kohonen_prototype ) :: pattern character ( len = NUMCHAR ) :: pattern_name contains procedure , public :: create => kohonen_pattern_create procedure , public :: destroy => kohonen_pattern_destroy procedure , public :: get => kohonen_pattern_accessor procedure , public :: set => kohonen_pattern_mutator procedure , public :: print => kohonen_pattern_print procedure , public :: get_nrow => kohonen_pattern_nrow procedure , public :: get_ncol => kohonen_pattern_ncol ! end type kohonen_pattern ! contains !======================================================================================== subroutine kohonen_pattern_create ( current_pattern , input , name ) !======================================================================================== !!   Kohonen pattern constructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input !! A real array character ( len =* ), optional :: name !! A character string with the name of the pattern call current_pattern % pattern % create ( input ); if ( present ( name )) then current_pattern % pattern_name = trim ( name ); else current_pattern % pattern_name = \"\" ; endif ! end subroutine kohonen_pattern_create !======================================================================================== subroutine kohonen_pattern_destroy ( current_pattern ) !======================================================================================== !!   Kohonen pattern destructor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object call current_pattern % pattern % destroy (); ! end subroutine kohonen_pattern_destroy !======================================================================================== subroutine kohonen_pattern_accessor ( current_pattern , pattern_value ) !======================================================================================== !! Kohonen pattern accessor class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! pattern_value = current_pattern % pattern ; ! end subroutine kohonen_pattern_accessor !======================================================================================== subroutine kohonen_pattern_mutator ( current_pattern , pattern_value ) !======================================================================================== !!   kohonen_pattern_mutator class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object type ( kohonen_prototype ), intent ( inout ) :: pattern_value ! current_pattern % pattern = pattern_value ; ! end subroutine kohonen_pattern_mutator !======================================================================================== subroutine kohonen_pattern_print ( current_pattern , unit_ ) !======================================================================================== !! Subroutine to print a Kohonen pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer , intent ( inout ), optional :: unit_ !! An integer variable with the number of the unit where the patterns will be printed if ( present ( unit_ )) then write ( unit_ , * ) write ( unit_ , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( unit_ , * ) call current_pattern % pattern % print ( unit_ ); else write ( * , * ) write ( * , * ) 'PATTERN: ' , trim ( current_pattern % pattern_name ); write ( * , * ) call current_pattern % pattern % print (); endif ! end subroutine kohonen_pattern_print !======================================================================================== function kohonen_pattern_nrow ( current_pattern ) result ( nr ) !======================================================================================== !! Function to calculate the number of rows (samples) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nr !! An integer with the number of rows (samples) in a pattern nr = current_pattern % pattern % get_nrow (); ! end function kohonen_pattern_nrow !======================================================================================== function kohonen_pattern_ncol ( current_pattern ) result ( nc ) !======================================================================================== !! Function to calculate the number of columns (variables) in a pattern class ( kohonen_pattern ) :: current_pattern !! A `kohonen_pattern` object integer :: nc !! An integer with the number of columns (variables) in a pattern nc = current_pattern % pattern % get_ncol (); ! end function kohonen_pattern_ncol ! end module kohonen_pattern_utilities","tags":"","loc":"sourcefile\\kohonen_pattern_utilities.f90.html"},{"title":"factory_distance_utilities.f90 – KohonenF08","text":"This module defines a factory to create distance objects This file depends on sourcefile~~factory_distance_utilities.f90~~EfferentGraph sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~factory_distance_utilities.f90~~AfferentGraph sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/16/2025 !! version: 0.2 !! This module defines a factory to create distance objects module factory_distance_utilities !! This module defines a factory to create distance objects use distance_base_utilities , only : distance_base ; use euclidean_distance_utilities , only : euclidean_distance ; use manhattan_distance_utilities , only : manhattan_distance ; use max_distance_utilities , only : max_distance ; ! implicit none ; ! type factory_distance !!  Class to represent a distance factory contains procedure , public :: create_distance end type factory_distance ! contains !======================================================================================== subroutine create_distance ( factory , type_ , dist ) !======================================================================================== !! Class constructor class ( factory_distance ) :: factory !! A `factory_distance` object character ( len =* ) :: type_ !! A character string with the type of distance to be instantiated class ( distance_base ), allocatable :: dist !! An allocatable `distance_base` object select case ( trim ( type_ )) case ( 'euclidean' ) !write(*,*) 'Euclidean distance'; if ( allocated ( dist )) deallocate ( dist ); allocate ( euclidean_distance :: dist ); case ( 'manhattan' ) !         !write(*,*) 'Manhattan distance allocated'; if ( allocated ( dist )) deallocate ( dist ); allocate ( manhattan_distance :: dist ); case ( 'max' ) if ( allocated ( dist )) deallocate ( dist ); allocate ( max_distnace :: dist ); case default write ( * , * ) 'ERROR: the requested distance is not defined' stop end select ! end subroutine create_distance ! end module factory_distance_utilities","tags":"","loc":"sourcefile\\factory_distance_utilities.f90.html"},{"title":"kohonen_layer_parameters_utilities.f90 – KohonenF08","text":"This file depends on sourcefile~~kohonen_layer_parameters_utilities.f90~~EfferentGraph sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~kohonen_layer_parameters_utilities.f90~~AfferentGraph sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module kohonen_layer_parameters_utilities ! use error_handling , only : error_t , error_stop ; use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use tomlf , only : toml_table ; implicit none ! private ! type kohonen_layer_parameters integer :: train_option ! integer :: number_nodes_nx , number_nodes_ny , number_nodes_nz , number_patterns integer :: number_variables1 , number_variables2 , number_variables integer , allocatable :: column_var (:) integer :: number_epochs , debug_level !number_clusters, integer , dimension ( 1 ) :: random_seed_ real ( kind = wp ) :: learning_rate character ( len = NUMCHAR ) :: node_type !rectangular, hexagonal character ( len = NUMCHAR ) :: debug_file , pattern_file , output_file character ( len = NUMCHAR ) :: distance_type !euclidean, manhattan, correlation, correlation2 character ( len = NUMCHAR ) :: neighborhood_type !gaussian,bubble character ( len = NUMCHAR ) :: som_type !normal_som,visom,robust_som character ( len = NUMCHAR ) :: m_estimator !name of the M-estimator to be used logical :: toroidal_grid ! UNITS FOR TRAINING OUTPUT integer :: idbg , iout , iindex , iprot , ihit , idist , iumat , ipar , isam , iclus , icen , iclus1 , idisto ! UNITS FOR ESTIMATION OUTPUT integer :: iout1 , imeas logical :: view_flag ! FLAG FOR DEBUGGING REALIZATION integer :: ireal ! contains procedure , public :: print => print_parameters procedure , public :: read_parameters procedure , public :: read_parameters_toml !generic,public :: read => read_parameters, read_parameters_toml end type kohonen_layer_parameters public :: kohonen_layer_parameters ! contains !============================================================================== subroutine print_parameters ( parameters , layer_ind , unit_ ) !============================================================================== class ( kohonen_layer_parameters ) :: parameters integer , intent ( inout ) :: layer_ind integer , intent ( inout ), optional :: unit_ ! integer :: unit1 , j , toroidal character ( len = NUMCHAR ) :: current_line ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif write ( unit1 , '(A)' ) adjustl ( 'Kohonen Map Parameters' ); write ( unit1 , '(A)' ) adjustl ( 'SOM_TRAIN_PARAMETERS' ) write ( current_line , '(I5)' ) parameters % train_option write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Train option' ; if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % pattern_file ), '!Pattern file' ; endif write ( current_line , '(I5)' ) parameters % number_patterns write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number Patterns' ; write ( current_line , '(2I5)' ) parameters % number_variables1 , parameters % number_variables2 write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number Variables1,Number Variables2' ; if ( parameters % number_variables . le . 10 ) then write ( current_line , '(10I4)' ) ( parameters % column_var ( j ), j = 1 , parameters % number_variables ) else write ( current_line , '(4I4)' ) - 1 , - 1 , - 1 , - 1 endif write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Columns' if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % som_type ), '!SOM type' endif write ( current_line , '(3I5)' ) parameters % number_nodes_nx ,& parameters % number_nodes_ny ,& parameters % number_nodes_nz write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number nodes x, Number nodes y, Number nodes z' write ( current_line , '(I6)' ) parameters % number_epochs write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Number epochs' ; write ( current_line , '(f10.5)' ) parameters % learning_rate write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Learning rate' ; write ( current_line , '(I10)' ) parameters % random_seed_ write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Random seed' ; write ( unit1 , '(A40,A)' ) adjustl ( parameters % distance_type ), '!Distance type' ; write ( unit1 , '(A40,A)' ) adjustl ( parameters % node_type ), '!Node type' ; write ( unit1 , '(A40,A)' ) adjustl ( parameters % neighborhood_type ), '!Neigh type' ; write ( current_line , '(I5)' ) parameters % debug_level ; write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Debug level' ; if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % debug_file ), '!Debug file' ; endif if ( layer_ind == 1 ) then write ( unit1 , '(A40,A)' ) adjustl ( parameters % output_file ), '!Output file' ; endif if ( parameters % toroidal_grid ) then toroidal = 1 ; else toroidal = 0 ; endif write ( current_line , '(I2)' ) toroidal write ( unit1 , '(A40,A)' ) adjustl ( current_line ), '!Toroidal grid' ! return ! end subroutine print_parameters !============================================================================== subroutine read_parameters ( parameters , unit_ ) !============================================================================== class ( kohonen_layer_parameters ) :: parameters integer , intent ( inout ), optional :: unit_ ! integer :: unit1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif read ( unit1 , * ) !'Kohonen Map Parameters' read ( unit1 , '(A40)' ) parameters % pattern_file !,'!Pattern file'; read ( unit1 , '(I40)' ) parameters % number_patterns !,'!Number Patterns'; read ( unit1 , '(I40)' ) parameters % number_variables1 !,'!Number Variables1'; read ( unit1 , '(I40)' ) parameters % number_variables2 !,'!Number Variables2'; parameters % number_variables = parameters % number_variables1 * & parameters % number_variables2 !    read(unit1,'(A40)') parameters%output_file!,'!Output file'; !    read(unit1,'(A40)') parameters%debug_file!,'!Debug file'; !    read(unit1,'(I40)') parameters%debug_level!,'!Debug level'; read ( unit1 , '(I40)' ) parameters % number_nodes_nx !,'!Number nodes x'; read ( unit1 , '(I40)' ) parameters % number_nodes_ny !,'!Number nodes y'; read ( unit1 , '(I40)' ) parameters % number_nodes_nz !,'!Number nodes z'; read ( unit1 , '(I40)' ) parameters % number_epochs !,'!Number epochs'; read ( unit1 , * ) parameters % learning_rate !,'!Learning rate'; read ( unit1 , '(I40)' ) parameters % random_seed_ !,'!Random seed'; read ( unit1 , '(A40)' ) parameters % distance_type !,'!Distance type'; read ( unit1 , '(A40)' ) parameters % node_type !,'!Node type'; read ( unit1 , '(A40)' ) parameters % neighborhood_type !,'!Neigh type'; read ( unit1 , '(I40)' ) parameters % debug_level !,'!Debug level'; read ( unit1 , '(A40)' ) parameters % debug_file !,'!Debug file'; read ( unit1 , '(A40)' ) parameters % output_file !,'!Output file'; ! end subroutine read_parameters !======================================================================================== subroutine read_parameters_toml ( parameters , unit_ ) !======================================================================================== class ( kohonen_layer_parameters ) :: parameters integer , intent ( inout ), optional :: unit_ ! Create a subroutine to read a toml file end subroutine read_parameters_toml ! end module kohonen_layer_parameters_utilities","tags":"","loc":"sourcefile\\kohonen_layer_parameters_utilities.f90.html"},{"title":"manhattan_distance_utilities.f90 – KohonenF08","text":"This module defines a class to calculate the Manhattan distance between kohonen prototypes This file depends on sourcefile~~manhattan_distance_utilities.f90~~EfferentGraph sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~manhattan_distance_utilities.f90~~AfferentGraph sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a class to calculate the Manhattan distance between kohonen prototypes module manhattan_distance_utilities !! This module defines a class to calculate the Manhattan distance between kohonen prototypes use precision_utilities , only : wp ; use distance_base_utilities , only : distance_base ; ! implicit none ; ! private ; ! type , extends ( distance_base ) :: manhattan_distance !! Class to calculate the Manhattan distance contains procedure , public :: calculate => calculate_manhattan_distance end type manhattan_distance ! public :: manhattan_distance ; ! contains !======================================================================================== function calculate_manhattan_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate the Manhattan distance between vectors class ( manhattan_distance ) :: distance !! A `Manhattan_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 , vector2 !! A real vector real ( kind = wp ) :: d !! A real vector d = sum ( dabs ( vector1 - vector2 )); !! A real variable with the distance end function calculate_manhattan_distance ! end module manhattan_distance_utilities","tags":"","loc":"sourcefile\\manhattan_distance_utilities.f90.html"},{"title":"two_level_som_estimate_variables.f90 – KohonenF08","text":"This file depends on sourcefile~~two_level_som_estimate_variables.f90~~EfferentGraph sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module two_level_som_estimate_variables ! use precision_utilities , only : wp ; use constants_utilities , only : NUMCHAR ; use kohonen_layer_parameters_utilities , only : kohonen_layer_parameters ; use kohonen_map_base_utilities , only : kohonen_map_base ; use kohonen_prototype_utilities , only : kohonen_prototype ; use kohonen_pattern_utilities , only : kohonen_pattern ; use two_level_self_organizing_map_utilities , only : two_level_self_organizing_map ; use rkiss05_generator_utilities , only : rkiss05_generator ; ! implicit none ; ! type ( two_level_self_organizing_map ), save :: my_som type ( kohonen_layer_parameters ), dimension ( 2 ) :: som_parameters type ( kohonen_pattern ), allocatable :: input_patterns (:) integer :: ipattern , number_clusters_evaluations , iseed , ic , current_cluster , neval , i , j character ( len = NUMCHAR ) :: parfl character ( len = NUMCHAR ) :: matrix_fl integer , allocatable :: seeds (:), clusters (:) integer , dimension ( 3 ) :: min_nodes , max_nodes real ( kind = wp ), dimension ( 3 ) :: results ! total_results: declared as fixed size array due to a weird memory leakage ! real(kind=wp),dimension(10,10,3):: total_results real ( kind = wp ), allocatable :: total_results (:,:,:), association_matrix (:,:) integer :: number_nodes , p , min_cluster , number_clusters ; type ( rkiss05_generator ) :: rgrator ! contains ! subroutine initialize_variables ( par_file ) ! character ( len =* ) :: par_file ! integer :: idata , ipattern , ivar , ierr , number_variables , i , j , ipar , train_option , view_option integer :: random_seeds_option real ( kind = wp ), allocatable :: var (:,:) logical :: testfl , testop character ( len = NUMCHAR ) :: current_line character ( len = NUMCHAR ) :: current_file integer , dimension ( 1000 ) :: column_var character ( len = NUMCHAR ), allocatable :: pattern_files (:) ! idata = 1 ; ipar = 2 ; ! inquire ( file = trim ( par_file ), exist = testfl ); if (. not . testfl ) then stop 'ERROR: parameter file does not exist' endif open ( ipar , file = trim ( par_file ), status = 'unknown' , access = 'sequential' , action = 'read' ); write ( * , * ) 'Reading parameter file...' current_line = '' ; do while ( trim ( current_line ) . ne . 'TWO_LEVEL_SOM_ESTIMATE_PARAMETERS' ) read ( ipar , '(A)' ) current_line enddo do while ( trim ( current_line ) . ne . 'LAYER1' ) read ( ipar , '(A)' ) current_line enddo write ( * , * ) write ( * , * ) 'LAYER 1: Reading parameters...' ; write ( * , * ) read ( ipar , * ) train_option write ( * , * ) 'Train option= ' , train_option read ( ipar , '(A40)' ) som_parameters ( 1 )% pattern_file write ( * , * ) 'Pattern file= ' , trim ( som_parameters ( 1 )% pattern_file ) read ( ipar , * ) som_parameters ( 1 )% number_patterns ; write ( * , * ) 'Number patterns= ' , som_parameters ( 1 )% number_patterns ; read ( ipar , * ) som_parameters ( 1 )% number_variables1 ,& som_parameters ( 1 )% number_variables2 ; number_variables = som_parameters ( 1 )% number_variables1 * & som_parameters ( 1 )% number_variables2 ; write ( * , * ) 'nvar1,nvar2,nvar= ' , som_parameters ( 1 )% number_variables1 ,& som_parameters ( 1 )% number_variables2 ,& number_variables ; allocate ( var ( som_parameters ( 1 )% number_variables1 , som_parameters ( 1 )% number_variables2 ), stat = ierr ); allocate ( association_matrix ( som_parameters ( 1 )% number_patterns , som_parameters ( 1 )% number_patterns ), stat = ierr ); association_matrix = 0.0d0 ; allocate ( clusters ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( train_option . eq . 0 ) then if ( number_variables . le . 10 ) then read ( ipar , * ) ( column_var ( ivar ), ivar = 1 , number_variables ); write ( * , * ) 'columns= ' ,( column_var ( ivar ), ivar = 1 , number_variables ); else read ( ipar , * ) write ( * , * ) 'WARNING: Assigning columns internally' do ivar = 1 , number_variables column_var ( ivar ) = ivar ; enddo endif else read ( ipar , * ) endif read ( ipar , '(A40)' ) som_parameters ( 1 )% som_type write ( * , * ) 'SOM type= ' , trim ( som_parameters ( 1 )% som_type ); read ( ipar , * ) som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz write ( * , * ) 'number nodes= ' , som_parameters ( 1 )% number_nodes_nx ,& som_parameters ( 1 )% number_nodes_ny ,& som_parameters ( 1 )% number_nodes_nz read ( ipar , * ) som_parameters ( 1 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 1 )% number_epochs read ( ipar , * ) som_parameters ( 1 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 1 )% learning_rate !   read(ipar,*) som_parameters(1)%random_seed_(1) !   write(*,*) 'random seed= ',som_parameters(1)%random_seed_(1) read ( ipar , '(A40)' ) som_parameters ( 1 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 1 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 1 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 1 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 1 )% neighborhood_type ) read ( ipar , * ) som_parameters ( 1 )% debug_level write ( * , * ) 'debug level= ' , som_parameters ( 1 )% debug_level read ( ipar , '(A40)' ) som_parameters ( 1 )% debug_file write ( * , * ) 'debug file= ' , trim ( som_parameters ( 1 )% debug_file ); read ( ipar , '(A40)' ) som_parameters ( 1 )% output_file write ( * , * ) 'output file base= ' , trim ( som_parameters ( 1 )% output_file ) read ( ipar , * ) view_option if ( view_option . eq . 1 ) then som_parameters ( 1 )% view_flag = . TRUE .; else som_parameters ( 1 )% view_flag = . FALSE .; endif write ( * , * ) 'Print training results= ' , som_parameters ( 1 )% view_flag write ( * , * ) write ( * , * ) 'LAYER 1: Reading parameters...finished' ; write ( * , * ) current_line = '' ; do while ( trim ( current_line ) . ne . 'LAYER2' ) read ( ipar , '(A)' ) current_line enddo write ( * , * ) write ( * , * ) 'LAYER 2: Reading parameters...' ; write ( * , * ) som_parameters ( 2 )% number_nodes_nx = 0 ; som_parameters ( 2 )% number_nodes_ny = 0 ; som_parameters ( 2 )% number_nodes_nz = 0 ; read ( ipar , * ) ( min_nodes ( i ), i = 1 , 3 ); write ( 6 , * ) 'Min number of nodes= ' ,( min_nodes ( i ), i = 1 , 3 ); read ( ipar , * ) ( max_nodes ( i ), i = 1 , 3 ); write ( 6 , * ) 'Max number of nodes= ' ,( max_nodes ( i ), i = 1 , 3 ) !    write(*,*) 'number nodes= ',som_parameters(2)%number_nodes_nx,& !                 som_parameters(2)%number_nodes_ny,& !                 som_parameters(2)%number_nodes_nz read ( ipar , * ) som_parameters ( 2 )% number_epochs write ( * , * ) 'number epochs= ' , som_parameters ( 2 )% number_epochs read ( ipar , * ) som_parameters ( 2 )% learning_rate write ( * , * ) 'learning rate= ' , som_parameters ( 2 )% learning_rate !   read(ipar,*) som_parameters(2)%random_seed_ !   write(*,*) 'random seed= ',som_parameters(2)%random_seed_ read ( ipar , '(A40)' ) som_parameters ( 2 )% distance_type write ( * , * ) 'distance type= ' , trim ( som_parameters ( 2 )% distance_type ) read ( ipar , '(A40)' ) som_parameters ( 2 )% node_type write ( * , * ) 'node type= ' , trim ( som_parameters ( 2 )% node_type ) read ( ipar , '(A40)' ) som_parameters ( 2 )% neighborhood_type write ( * , * ) 'neighborhood type= ' , trim ( som_parameters ( 2 )% neighborhood_type ) write ( * , * ) write ( * , * ) 'LAYER 2: Reading parameters...finished' ; write ( * , * ) ! current_line = '' ; do while ( current_line . ne . 'RANDOM_SEEDS' ) read ( ipar , '(A)' ) current_line enddo write ( 6 , * ) '' write ( 6 , * ) 'RANDOM SEEDS: Reading parameters...' write ( 6 , * ) '' ! read ( ipar , * ) random_seeds_option ; write ( 6 , * ) 'random seeds option= ' , random_seeds_option ; read ( ipar , * ) number_clusters_evaluations ; write ( 6 , * ) 'Number random seeds= ' , number_clusters_evaluations ; allocate ( seeds ( number_clusters_evaluations ), stat = ierr ); if ( random_seeds_option . eq . 1 ) then read ( ipar , * ) ( seeds ( iseed ), iseed = 1 , number_clusters_evaluations ); write ( 6 , * ) 'Seeds= ' ,( seeds ( iseed ), iseed = 1 , number_clusters_evaluations ); else read ( ipar , * ) seeds ( 1 ); call rgrator % create ( seeds ( 1 )); !call sgrnd(seeds(1)); do i = 1 , number_clusters_evaluations !seeds(i)=int(1.0e7*grnd()); seeds ( i ) = int ( 1.0e7 * rgrator % generate ()); enddo call rgrator % destroy (); endif ! allocate ( total_results ( max_nodes ( 1 ) - min_nodes ( 1 ), number_clusters_evaluations , 3 ), stat = ierr ); ! write ( 6 , * ) '' write ( 6 , * ) 'RANDOM SEEDS: Reading parameters...finished' write ( 6 , * ) '' !   stop ! !   allocate(my_som(number_clusters_evaluations),stat=ierr); ! write ( * , * ) 'Reading parameter file...finished' close ( ipar ); inquire ( file = trim ( som_parameters ( 1 )% pattern_file ), exist = testfl ) if (. not . testfl ) then stop 'ERROR: input file does not exist' endif ! som_parameters ( 1 )% idbg = 10 ; som_parameters ( 1 )% iout = 11 ; som_parameters ( 1 )% iindex = 12 ; som_parameters ( 1 )% iprot = 13 ; som_parameters ( 1 )% ihit = 14 ; som_parameters ( 1 )% idist = 15 ; som_parameters ( 1 )% iumat = 16 ; som_parameters ( 1 )% ipar = 17 ; som_parameters ( 1 )% isam = 18 ; som_parameters ( 1 )% iclus = 19 ; som_parameters ( 1 )% icen = 20 ; som_parameters ( 1 )% iclus1 = 21 ; ! som_parameters ( 1 )% iout1 = 22 ; som_parameters ( 1 )% imeas = 23 ; ! ! ! allocate ( input_patterns ( som_parameters ( 1 )% number_patterns ), stat = ierr ); if ( train_option . eq . 0 ) then ! write ( * , * ) 'Reading patterns...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' ); do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , * , err = 90 ) ( var ( ivar , 1 ), ivar = 1 , number_variables ); !write(*,*) (var(ivar,1),ivar=1,number_variables); call input_patterns ( ipattern )% create ( var ); enddo !ipatterns close ( idata ) write ( * , * ) 'Reading patterns...OK!!!' elseif ( train_option . eq . 1 ) then allocate ( pattern_files ( som_parameters ( 1 )% number_patterns ), stat = ierr ); write ( * , * ) 'Reading pattern files...' open ( idata , file = trim ( som_parameters ( 1 )% pattern_file ), status = 'unknown' ,& access = 'sequential' , action = 'read' ); do ipattern = 1 , som_parameters ( 1 )% number_patterns read ( idata , '(A)' , err = 90 ) pattern_files ( ipattern ); enddo !ipattern write ( * , * ) 'Reading pattern files...finished!' ; ! write ( * , * ) 'Reading patterns...' ; do ipattern = 1 , som_parameters ( 1 )% number_patterns inquire ( file = trim ( pattern_files ( ipattern )), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the file ' , trim ( pattern_files ( ipattern )), ' does not exist' stop endif write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )); open ( idata , file = trim ( pattern_files ( ipattern )), status = 'unknown' , action = 'read' , access = 'sequential' ); do i = 1 , size ( var , 1 ) read ( idata , * , err = 91 ) ( var ( i , j ), j = 1 , size ( var , 2 )); enddo !ix close ( idata ); write ( * , * ) 'Currently reading ' , trim ( pattern_files ( ipattern )), ' finished' ; call input_patterns ( ipattern )% create ( var ); enddo !ipattern write ( * , * ) 'Reading patterns...finished!' ; endif ! if ( som_parameters ( 1 )% debug_level . gt . 0 ) then open ( som_parameters ( 1 )% idbg , file = trim ( som_parameters ( 1 )% debug_file ),& status = 'unknown' , access = 'sequential' , action = 'write' ); endif ! write ( * , * ) 'Opening output files...' ; ! output file current_file = trim ( som_parameters ( 1 )% output_file ) // '_evaluation_output.out' open ( som_parameters ( 1 )% iout1 , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); !    write(som_parameters(1)%iout1,'(A)') 'KOHONEN MAP EVALUATION RESULTS'; !    write(som_parameters(1)%iout1,'(A6,1X,6A12)') 'clust.','H Ind.','KL','CH','Ball','Silhouette','Friedman' ! current_file = trim ( som_parameters ( 1 )% output_file ) // '_association_matrix.out' ; matrix_fl = trim ( current_file ); open ( som_parameters ( 1 )% imeas , file = trim ( current_file ), status = 'unknown' ,& action = 'write' , access = 'sequential' ); !  write(som_parameters(1)%imeas,'(A)') 'KOHONEN MAP - ASSOCIATION MATRIX' !  write(som_parameters(1)%imeas,*) som_parameters(1)%number_patterns,som_parameters(1)%number_patterns ! ! parameter file ! !    current_file=trim(som_parameters(1)%output_file)//'_parameters.som'; !    open(som_parameters(1)%ipar,file=trim(current_file),status='unknown',& !         action='write',access='sequential') !    call som_parameters(1)%print(som_parameters(1)%ipar); !    som_parameters(2)%output_file='NOFILE'; !    som_parameters(2)%pattern_file='NOFILE'; !    som_parameters(2)%debug_file='NOFILE'; !    call som_parameters(2)%print(som_parameters(1)%ipar); !    close(som_parameters(1)%ipar) ! ! neuron indices !    current_file=trim(som_parameters(1)%output_file)//'_neuron_indices.out'; !    open(som_parameters(1)%iindex,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iindex,'(A)') 'KOHONEN MAP PATTERN INDICES' !    write(som_parameters(1)%iindex,'(A17,1X,2I6)') 'Number Patterns= ',& !          som_parameters(1)%number_patterns,3; !       write(som_parameters(1)%iindex,'(A21)') 'Pattern Number,ix,iy ' ! ! neuron prototypes !    current_file=trim(som_parameters(1)%output_file)//'_prototypes.out'; !    open(som_parameters(1)%iprot,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iprot,'(A)') 'KOHONEN MAP PROTOTYPES' !    write(som_parameters(1)%iprot,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz !    write(som_parameters(1)%iprot,'(A21,1X,2I6)') 'number of variables= ',& !         som_parameters(1)%number_variables1,som_parameters(1)%number_variables2 ! ! neuron hit !    current_file=trim(som_parameters(1)%output_file)//'_neuron_hit.out'; !    open(som_parameters(1)%ihit,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%ihit,'(A)') 'KOHONEN MAP NEURON HITS' !    write(som_parameters(1)%ihit,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! neuron distances !    current_file=trim(som_parameters(1)%output_file)//'_neuron_distances.out'; !    open(som_parameters(1)%idist,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%idist,'(A)') 'KOHONEN MAP DISTANCE MATRIX' !    write(som_parameters(1)%idist,'(A17,1X,2I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx*som_parameters(1)%number_nodes_ny*& !         som_parameters(1)%number_nodes_nz,& !         som_parameters(1)%number_nodes_nx*som_parameters(1)%number_nodes_ny*& !         som_parameters(1)%number_nodes_nz ! ! u-matrix !    current_file=trim(som_parameters(1)%output_file)//'_u-matrix.out'; !    open(som_parameters(1)%iumat,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iumat,'(A)') 'KOHONEN MAP U-MATRIX' !    write(som_parameters(1)%iumat,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_map_samples.out'; !    open(som_parameters(1)%isam,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%isam,'(A)') 'KOHONEN MAP SAMPLE LOCATION' !    write(som_parameters(1)%isam,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_clusters.out'; !    open(som_parameters(1)%iclus,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iclus,'(A)') 'KOHONEN MAP CLUSTERS' !    write(som_parameters(1)%iclus,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_cluster_centers.out'; !    open(som_parameters(1)%icen,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%icen,'(A)') 'KOHONEN MAP CLUSTER CENTERS' !    write(som_parameters(1)%icen,'(A17,1X,3I6)') 'number of nodes= ',& !         som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& !         som_parameters(1)%number_nodes_nz ! ! !    current_file=trim(som_parameters(1)%output_file)//'_cluster_samples.out'; !    open(som_parameters(1)%iclus1,file=trim(current_file),status='unknown',& !         action='write',access='sequential'); !    write(som_parameters(1)%iclus1,'(A)') 'KOHONEN MAP CLUSTER SAMPLES' ! !   write(som_parameters(1)%icen,'(A17,1X,3I6)') 'number of nodes= ',& ! !        som_parameters(1)%number_nodes_nx,som_parameters(1)%number_nodes_ny,& ! !        som_parameters(1)%number_nodes_nz !    write(som_parameters(1)%iclus1,'(2I6)') som_parameters(1)%number_patterns,5 ! write ( * , * ) 'Opening output files...finished!!!' ; ! deallocate ( var ); ! return ; ! 90 stop 'ERROR while reading pattern file' 91 stop 'ERROR while reading pattern sample file' ! end subroutine initialize_variables subroutine release_variables () integer :: i logical :: testop ! if ( allocated ( input_patterns )) then do i = 1 , size ( input_patterns ) call input_patterns ( i )% destroy (); enddo deallocate ( input_patterns ); endif ! if ( allocated ( seeds )) then deallocate ( seeds ); endif ! if ( allocated ( total_results )) then deallocate ( total_results ); endif ! if ( allocated ( association_matrix )) then deallocate ( association_matrix ); endif ! if ( allocated ( clusters )) then deallocate ( clusters ); endif ! inquire ( unit = som_parameters ( 1 )% iout1 , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% iout1 ); endif ! inquire ( unit = som_parameters ( 1 )% imeas , opened = testop ); if ( testop ) then close ( som_parameters ( 1 )% imeas ); endif !   inquire(unit=som_parameters(1)%iindex,opened=testop); !   if(testop) then !     close(som_parameters(1)%iindex); !   endif ! ! !   inquire(unit=som_parameters(1)%iprot,opened=testop); !   if(testop) then !     close(som_parameters(1)%iprot); !   endif ! ! !   inquire(unit=som_parameters(1)%ihit,opened=testop); !   if(testop) then !     close(som_parameters(1)%ihit); !   endif ! ! !   inquire(unit=som_parameters(1)%idist,opened=testop); !   if(testop) then !     close(som_parameters(1)%idist); !   endif ! ! !   inquire(unit=som_parameters(1)%iumat,opened=testop); !   if(testop) then !     close(som_parameters(1)%iumat); !   endif ! ! !   inquire(unit=som_parameters(1)%isam,opened=testop); !   if(testop) then !     close(som_parameters(1)%isam); !   endif ! ! !   inquire(unit=som_parameters(1)%iclus,opened=testop); !   if(testop) then !     close(som_parameters(1)%iclus); !   endif ! ! !   inquire(unit=som_parameters(1)%icen,opened=testop); !   if(testop) then !     close(som_parameters(1)%icen); !   endif ! ! !   inquire(unit=som_parameters(1)%iclus1,opened=testop); !   if(testop) then !     close(som_parameters(1)%iclus1); !   endif ! ! ! !   inquire(file=trim(som_parameters(1)%debug_file),opened=testop); !   if(testop) then !     close(som_parameters(1)%idbg); !   endif ! end subroutine release_variables end module two_level_som_estimate_variables","tags":"","loc":"sourcefile\\two_level_som_estimate_variables.f90.html"},{"title":"random_number_generator_utilities.f90 – KohonenF08","text":"This module defines the random_number_generator class that is used to generate random numbers \nin several procedures across ATALIB. This file depends on sourcefile~~random_number_generator_utilities.f90~~EfferentGraph sourcefile~random_number_generator_utilities.f90 random_number_generator_utilities.f90 sourcefile~mt19937_64.f90 mt19937_64.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~mt19937_64.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 05/01/2021 !! version: 0.1 !! This module defines the random_number_generator class that is used to generate random numbers !! in several procedures across ATALIB. module random_number_generator_utilities !! This module defines the random_number_generator class that is used to generate random numbers !! in several procedures across ATALIB. use precision_utilities , only : wp , i64 ; use mt19937_64 , only : init_genrand64 , init_by_array64 , genrand64_real3 ; ! implicit none ; ! private ; ! type random_number_generator private !! The random_number_generator class is used to encapsulate a generator or random numbers !! An object of this class is defined through the specification of the random seed or seeds integer ( i64 ) :: seed integer ( i64 ), allocatable :: seed_array (:) contains procedure , private :: create_random_number_grator_single procedure , private :: create_random_number_grator_array generic , public :: create => create_random_number_grator_single , create_random_number_grator_array procedure , public :: destroy => destroy_random_number_grator procedure , public :: generate end type random_number_generator ! public :: random_number_generator ! contains !======================================================================================== subroutine create_random_number_grator_single ( grator , iseed ) !======================================================================================== !! Class Constructor 1 class ( random_number_generator ) :: grator !! A `random_number_generator` object to be defined integer ( i64 ) :: iseed !! An integer value with the seed of the random_number_generator !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: iseed !!        type(random_number_generator) :: my_grator !!        ... !!        iseed=12345; !!        call my_grator%create(iseed); !!        ... !!    end program main grator % seed = iseed ; call init_genrand64 ( grator % seed ); ! end subroutine create_random_number_grator_single !======================================================================================== subroutine create_random_number_grator_array ( grator , iseed ) !======================================================================================== !! Class Destructor 2 class ( random_number_generator ) :: grator !! A `random_number_generator` object to be defined integer ( i64 ), dimension (:), intent ( inout ) :: iseed !! An integer array with the seeds of the random_number_generator !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: i !!        integer,dimension(5) :: iseed !!        type(random_number_generator) :: my_grator !!        ... !!        do i=1,5 !!            iseed(i)=12345+i; !!        enddo !!        call my_grator%create(iseed); !!        ... !!    end program main allocate ( grator % seed_array , source = iseed ); call init_by_array64 ( grator % seed_array ); ! end subroutine create_random_number_grator_array !======================================================================================== subroutine destroy_random_number_grator ( grator ) !======================================================================================== !! Class Destructor class ( random_number_generator ) :: grator !! A `random_number_generator` object to be destroyed !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: iseed !!        type(random_number_generator) :: my_grator !!        ... !!        iseed=12345; !!        call my_grator%create(iseed); !!        ... !!        call my_grator%destroy(); !!        ... !!    end program main grator % seed = 0 ; if ( allocated ( grator % seed_array )) then deallocate ( grator % seed_array ); endif ! end subroutine destroy_random_number_grator !======================================================================================== function generate ( grator ) result ( rn ) !======================================================================================== !! Function used to generate random numbers class ( random_number_generator ) :: grator !! A `random_number_generator` object real ( wp ) :: rn !! A real value with the random number generated !!    program main !!        use random_number_generator_utilities; !!        ... !!        integer :: iseed !!        real(wp) :: rnum !!        type(random_number_generator) :: my_grator !!        ... !!        iseed=12345; !!        call my_grator%create(iseed); !!        rnum=my_grator%generate(); !!        write(*,*) 'Random number= ',rnum; !!        ... !!    end program main rn = genrand64_real3 (); ! end function generate ! end module random_number_generator_utilities","tags":"","loc":"sourcefile\\random_number_generator_utilities.f90.html"},{"title":"max_distance_utilities.f90 – KohonenF08","text":"This module defines a class to calculate the Max distance between kohonen prototypes This file depends on sourcefile~~max_distance_utilities.f90~~EfferentGraph sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~max_distance_utilities.f90~~AfferentGraph sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/16/2025 !! version: 0.1 !! This module defines a class to calculate the Max distance between kohonen prototypes module max_distance_utilities !! This module defines a class to calculate the Max distance between kohonen prototypes use precision_utilities , only : wp ; use distance_base_utilities , only : distance_base ; ! implicit none ; ! private ; ! type , extends ( distance_base ) :: max_distance !! Class to calculate the Max distance contains procedure , public :: calculate => calculate_max_distance end type max_distance ! public :: max_distance ; ! contains !======================================================================================== function calculate_max_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate the Max distance between vectors class ( max_distance ) :: distance !! A `Max_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 , vector2 !! A real vector real ( kind = wp ) :: d !! A real vector d = maxval ( vector1 - vector2 ); !! A real variable with the distance end function calculate_manhattan_distance ! end module max_distance_utilities","tags":"","loc":"sourcefile\\max_distance_utilities.f90.html"},{"title":"cauchy_neighborhood_function_utilities.f90 – KohonenF08","text":"This module defines the Cauchy neighborhood function This file depends on sourcefile~~cauchy_neighborhood_function_utilities.f90~~EfferentGraph sourcefile~cauchy_neighborhood_function_utilities.f90 cauchy_neighborhood_function_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90->sourcefile~neighborhood_function_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/16/2025 !! version: 0.1 !! This module defines the Cauchy neighborhood function module cauchy_neighborhood_function_utilities !! This module defines the Cauchy neighborhood function use precision_utilities , only : wp ; use neighborhood_function_base_utilities , only : neighborhood_function_base ; implicit none ; ! private ; ! type , extends ( neighborhood_function_base ) :: cauchy_neighborhood_function !! Class that implements the Cauchy Neighborhood Function private real ( kind = wp ) :: sigma , p contains procedure , public :: create => create_cauchy_neighborhood procedure , public :: calculate => calculate_cauchy_neighborhood end type cauchy_neighborhood_function ! public :: cauchy_neighborhood_function ; ! contains ! subroutine create_cauchy_neighborhood ( my_neigh_fn , parameters ) !! Class Constructor class ( cauchy_neighborhood_function ) :: my_neigh_fn !! A `cauchy_neighborhood_function` object real ( kind = wp ), dimension (:), intent ( in ) :: parameters !! A real array with the paramters sigma and p my_neigh_fn % sigma = parameters ( 1 ); my_neigh_fn % p = parameters ( 2 ); end subroutine create_cauchy_neighborhood ! function calculate_cauchy_neighborhood ( my_neigh_fn , geometric_distance ) result ( n ) !! Function to calculate the value of the cauchy neighborhood class ( cauchy_neighborhood_function ) :: my_neigh_fn !! A `cauchy_neighborhood_function` object real ( kind = wp ), intent ( inout ) :: geometric_distance !! A real variable with the geometric distnace real ( kind = wp ) :: n !! A real value n = 1.0_wp / ( 1.0_wp + ( geometric_distance / my_neigh_fn % sigma ) ** my_neigh_fn % p ); ! end function calculate_cauchy_neighborhood ! end module cauchy_neighborhood_function_utilities","tags":"","loc":"sourcefile\\cauchy_neighborhood_function_utilities.f90.html"},{"title":"gaussian_neighborhood_function_utilities.f90 – KohonenF08","text":"This module defines the Gaussian neighborhood function This file depends on sourcefile~~gaussian_neighborhood_function_utilities.f90~~EfferentGraph sourcefile~gaussian_neighborhood_function_utilities.f90 gaussian_neighborhood_function_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90->sourcefile~neighborhood_function_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/16/2025 !! version: 0.1 !! This module defines the Gaussian neighborhood function module gaussian_neighborhood_function_utilities !! This module defines the Gaussian neighborhood function use precision_utilities , only : wp ; use neighborhood_function_base_utilities , only : neighborhood_function_base ; ! implicit none ; ! private ; ! type , extends ( neighborhood_function_base ) :: gaussian_neighborhood_function !! Class that implements the Gaussian Neighborhood Function private real ( kind = wp ) :: sigma , p contains procedure , public :: create => create_gaussian_neighborhood procedure , public :: calculate => calculate_gaussian_neighborhood end type gaussian_neighborhood_function ! public :: gaussian_neighborhood_function ; ! contains ! subroutine create_gaussian_neighborhood ( my_neigh_fn , parameters ) !! Class Constructor class ( gaussian_neighborhood_function ) :: my_neigh_fn !! A `gaussian_neighborhood_function` object real ( kind = wp ), dimension (:), intent ( in ) :: parameters !! A real array with the paramters sigma and p my_neigh_fn % sigma = parameters ( 1 ); my_neigh_fn % p = parameters ( 2 ); end subroutine create_gaussian_neighborhood ! function calculate_gaussian_neighborhood ( my_neigh_fn , geometric_distance ) result ( n ) !! Function to calculate the value of the Gaussian neighborhood class ( gaussian_neighborhood_function ) :: my_neigh_fn !! A `gaussian_neighborhood_function` object real ( kind = wp ), intent ( inout ) :: geometric_distance !! A real variable with the geometric distnace real ( kind = wp ) :: n !! A real value n = dexp ( - 0.5_wp * ( geometric_distance / my_neigh_fn % sigma ) ** my_neigh_fn % p ); ! end function calculate_gaussian_neighborhood ! end module gaussian_neighborhood_function_utilities","tags":"","loc":"sourcefile\\gaussian_neighborhood_function_utilities.f90.html"},{"title":"precision_utilities.f90 – KohonenF08","text":"This module defines the precision constants used in all modules of the library. Files dependent on this one sourcefile~~precision_utilities.f90~~AfferentGraph sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90 cauchy_neighborhood_function_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90 neighborhood_function_base_utilities.f90 sourcefile~cauchy_neighborhood_function_utilities.f90->sourcefile~neighborhood_function_base_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~dataframe_utilities.f90 dataframe_utilities.f90 sourcefile~dataframe_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~dataframe_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90 gaussian_neighborhood_function_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~gaussian_neighborhood_function_utilities.f90->sourcefile~neighborhood_function_base_utilities.f90 sourcefile~general_utilities.f90 general_utilities.f90 sourcefile~general_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~quicksort_utilities.f90 quicksort_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~neighborhood_function_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~sort_base_utilities.f90 sort_base_utilities.f90 sourcefile~quicksort_utilities.f90->sourcefile~sort_base_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~random_number_generator_utilities.f90 random_number_generator_utilities.f90 sourcefile~random_number_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~quicksort_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~precision_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~constants_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~precision_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 sourcefile~sort_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~constants_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~precision_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/23/2020 !! version: 0.1 !! This module defines the precision constants used in all modules of the library. module precision_utilities ! i8=>int8, i16=>int16, i32=>int32, i64=>int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , int8 , int16 , int32 , int64 , wp => real64 ! implicit none ; ! integer , parameter :: sp = real32 ; !! Single precision integer , parameter :: dp = wp ; !! Double precision integer , parameter :: ep = wp ; !! Extended precision integer , parameter :: i8 = int8 !! Integer (short) integer , parameter :: i16 = int16 !! Integer (short) integer , parameter :: i32 = int32 !! Integer (long) integer , parameter :: i64 = int64 !! Integer (long) end module precision_utilities","tags":"","loc":"sourcefile\\precision_utilities.f90.html"},{"title":"euclidean_distance_utilities.f90 – KohonenF08","text":"This module defines a class to calculate the Euclidean distance between kohonen prototypes This file depends on sourcefile~~euclidean_distance_utilities.f90~~EfferentGraph sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~euclidean_distance_utilities.f90~~AfferentGraph sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 12/04/2024 !! version: 0.1 !! This module defines a class to calculate the Euclidean distance between kohonen prototypes module euclidean_distance_utilities !! This module defines a class to calculate the Euclidean distance between kohonen prototypes use precision_utilities , only : wp ; use distance_base_utilities , only : distance_base ; ! implicit none ! type , extends ( distance_base ) :: euclidean_distance !! Class to calculate the euclidean distance contains procedure , public :: calculate => calculate_euclidean_distance ! end type euclidean_distance ! contains !======================================================================================== function calculate_euclidean_distance ( distance , vector1 , vector2 ) result ( d ) !======================================================================================== !! Function to calculate euclidean distance between vectors class ( euclidean_distance ) :: distance !! A `euclidean_distance` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector1 !! A real vector real ( kind = wp ), dimension (:,:), intent ( inout ) :: vector2 !! A real vector real ( kind = wp ) :: d !! A real variable with the distance d = sum (( vector1 - vector2 ) ** 2 ); ! end function calculate_euclidean_distance ! end module euclidean_distance_utilities","tags":"","loc":"sourcefile\\euclidean_distance_utilities.f90.html"},{"title":"two_level_self_organizing_map_utilities.f90 – KohonenF08","text":"This module defines a class that represents a two layer self_organizing_map  for clustering This file depends on sourcefile~~two_level_self_organizing_map_utilities.f90~~EfferentGraph sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~distance_base_utilities.f90 distance_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~factory_distance_utilities.f90 factory_distance_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~factory_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~random_generator_base_utilities.f90 random_generator_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~rkiss05_generator_utilities.f90 rkiss05_generator_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~rkiss05_generator_utilities.f90 sourcefile~distance_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90 euclidean_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~euclidean_distance_utilities.f90 sourcefile~manhattan_distance_utilities.f90 manhattan_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~manhattan_distance_utilities.f90 sourcefile~max_distance_utilities.f90 max_distance_utilities.f90 sourcefile~factory_distance_utilities.f90->sourcefile~max_distance_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~random_generator_base_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~rkiss05_generator_utilities.f90->sourcefile~random_generator_base_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~euclidean_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~manhattan_distance_utilities.f90->sourcefile~precision_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~distance_base_utilities.f90 sourcefile~max_distance_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~two_level_self_organizing_map_utilities.f90~~AfferentGraph sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/12/2025 !! version: 0.1 !! This module defines a class that represents a two layer self_organizing_map  for clustering module two_level_self_organizing_map_utilities !! This module defines a class that represents a two layer self_organizing_map  for clustering use precision_utilities , only : wp ; use kohonen_layer_parameters_utilities ; use kohonen_map_base_utilities ; use kohonen_prototype_utilities ; use kohonen_pattern_utilities ; use distance_base_utilities ; use factory_distance_utilities ; use random_generator_base_utilities , only : random_generator_base ; use rkiss05_generator_utilities , only : rkiss05_generator ; ! implicit none ; ! type , extends ( kohonen_map_base ) :: two_level_self_organizing_map private !!   Class to represent a two level self_organized_map type ( kohonen_prototype ), allocatable :: grid (:,:,:), cluster_layer (:) real ( kind = wp ), allocatable :: coordinates (:,:) integer , allocatable :: number_patterns (:,:,:), cells_index (:,:) integer , allocatable :: cluster_number_patterns (:), cluster_cells_index (:,:) integer , allocatable :: grid_cluster (:,:,:), cluster_samples (:) real ( kind = wp ), allocatable :: u_matrix (:,:,:), distance (:,:), cells_distances (:,:) integer , allocatable :: number_cluster_samples (:), index_cluster_samples (:,:) type ( kohonen_layer_parameters ), dimension ( 2 ) :: parameters type ( factory_distance ) :: factory class ( distance_base ), allocatable :: distance_function type ( rkiss05_generator ), dimension ( 2 ) :: rnumber_grator integer :: seed1 , seed2 integer :: number_variables , number_variables1 , number_variables2 , number_clusters integer :: number_nodes contains procedure , public :: create => create_2lsom procedure , public :: destroy => destroy_2lsom procedure , private :: create_random_sample procedure , public :: train => train_2lsom procedure , public :: predict => predict_2lsom procedure , public :: train_grid_layer procedure , public :: train_cluster_layer procedure , public :: print => print_2lsom procedure , public :: query => query_2lsom procedure , public :: set_cluster_layer procedure , public :: set_parameters !    procedure,public :: read => read_som procedure , private :: query_2lsom procedure , public :: read_som_layer procedure , private :: calculate_u_matrix procedure , private :: find_best_match_unit procedure , private :: update_weights procedure , private :: calculate_distance_between_prototypes procedure , private :: assign_input_to_clusters !procedure,public :: get_count => get_count_2lsom !procedure,public :: get_index => get_index_som !procedure,public :: get_u_matrix => get_u_matrix_som procedure , public :: calculate_sum2_clusters_samples => evaluate_2lsom procedure , public :: get_cluster_samples procedure , public :: calculate_sum2_clusters_grid procedure , nopass , private :: calculate_distance_matrix procedure , nopass , private :: calculate_coordinates ! procedure , nopass , public :: external_train_map !    procedure,nopass,public :: external_predict_map !***** end type two_level_self_organizing_map contains !======================================================================================== subroutine create_2lsom ( kohonen_map , training_parameters ) !======================================================================================== !!   Constructor of a two_level self_organized_map class class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_layer_parameters ), dimension (:) :: training_parameters !! A `kohonen_layer_parameters` structure integer :: ierr , nx , ny , nz , ix , iy , iz , nvar1 , nvar2 , number_clusters , ivar1 , ivar2 , current_index real ( kind = wp ), allocatable :: input (:,:) integer :: seed ! kohonen_map % parameters = training_parameters ( 1 : 2 ); nx = training_parameters ( 1 )% number_nodes_nx ; ny = training_parameters ( 1 )% number_nodes_ny ; nz = training_parameters ( 1 )% number_nodes_nz ; nvar1 = training_parameters ( 1 )% number_variables1 ; nvar2 = training_parameters ( 1 )% number_variables2 ; number_clusters = training_parameters ( 2 )% number_nodes_nx * & training_parameters ( 2 )% number_nodes_ny * & training_parameters ( 2 )% number_nodes_nz ; kohonen_map % number_clusters = number_clusters ; kohonen_map % number_variables = nvar1 * nvar2 ; kohonen_map % number_variables1 = nvar1 ; kohonen_map % number_variables2 = nvar2 ; kohonen_map % number_nodes = nx * ny * nz ; allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); kohonen_map % coordinates = 0 ; allocate ( input ( nvar1 , nvar2 ), stat = ierr ); input = 0.0_wp ; allocate ( kohonen_map % number_patterns ( nx , ny , nz ), stat = ierr ); allocate ( kohonen_map % cells_index ( training_parameters ( 1 )% number_patterns , 3 ), stat = ierr ); kohonen_map % number_patterns = 0 ; kohonen_map % cells_index = 0 ; allocate ( kohonen_map % u_matrix ( 2 * nx - 1 , 2 * ny - 1 , 2 * nz - 1 ), stat = ierr ); kohonen_map % u_matrix = 0.0_wp ; allocate ( kohonen_map % distance ( nx * ny * nz , nx * ny * nz ), stat = ierr ); !  cluster layer arrays allocate ( kohonen_map % cluster_layer ( number_clusters ), stat = ierr ); allocate ( kohonen_map % cluster_cells_index ( nx * ny * nz , 4 ), stat = ierr ); kohonen_map % cluster_cells_index = 0 ; allocate ( kohonen_map % cluster_number_patterns ( number_clusters ), stat = ierr ); kohonen_map % cluster_number_patterns = 0 ; allocate ( kohonen_map % grid_cluster ( nx , ny , nz ), stat = ierr ); kohonen_map % grid_cluster = 0 ; allocate ( kohonen_map % cluster_samples ( training_parameters ( 1 )% number_patterns ), stat = ierr ); allocate ( kohonen_map % number_cluster_samples ( number_clusters ), stat = ierr ); !Lack of initialization was causing problems during execution kohonen_map % number_cluster_samples = 0 ; allocate ( kohonen_map % index_cluster_samples ( number_clusters ,& training_parameters ( 1 )% number_patterns ), stat = ierr ); kohonen_map % index_cluster_samples = 0 ! call kohonen_map % factory % create_distance ( training_parameters ( 1 )% distance_type ,& kohonen_map % distance_function ); ! kohonen_map % seed1 = training_parameters ( 1 )% random_seed_ ( 1 ) + 100 ; call kohonen_map % rnumber_grator ( 1 )% create ( kohonen_map % seed1 ); !call sgrnd(seed) write ( * , * ) 'TWO LEVEL SOM: Initializing grid...' , seed do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx call kohonen_map % create_random_sample ( input ); !call grnd_array(input); !            write(*,*) ix,iy,input(1:2,1) call kohonen_map % grid ( ix , iy , iz )% create ( input ); !call kohonen_map%grid(ix,iy)%print(); current_index = position2index ( ix , iy , iz , nx , ny ); kohonen_map % coordinates ( current_index , 1 ) = dble ( ix ); kohonen_map % coordinates ( current_index , 2 ) = dble ( iy ); kohonen_map % coordinates ( current_index , 3 ) = dble ( iz ); !            write(*,*) ix+(iy-1)*nx+(iz-1)*nx*ny if ( trim ( training_parameters ( 1 )% node_type ) . eq . 'hexagonal' ) then !              write(*,*) 'hexagonal' kohonen_map % coordinates ( current_index , 1 ) = kohonen_map % coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( kohonen_map % coordinates ( current_index , 2 ), 2.0_wp )); kohonen_map % coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2._wp ) * kohonen_map % coordinates ( current_index , 2 ); endif enddo !iz enddo !iy enddo !ix ! ! ! allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); call kohonen_map % calculate_distance_matrix ( kohonen_map % coordinates ,& kohonen_map % cells_distances , training_parameters ( 1 )% node_type ,& training_parameters ( 1 )% toroidal_grid ); ! ! ! kohonen_map % seed2 = training_parameters ( 2 )% random_seed_ ( 1 ); !call sgrnd(seed); call kohonen_map % rnumber_grator ( 2 )% create ( kohonen_map % seed2 ); ! do ix = 1 , number_clusters !call grnd_array(input); call kohonen_map % create_random_sample ( input ); call kohonen_map % cluster_layer ( ix )% create ( input ); enddo ! deallocate ( input ); ! write ( * , * ) 'TWO LEVEL SOM: Initializing grid...OK' ! end subroutine create_2lsom !======================================================================================== subroutine destroy_2lsom ( kohonen_map ) !======================================================================================== !!   Destructor of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: ix , iy , iz ! write ( * , * ) 'TWO LEVEL SOM: Releasing memory...' if ( allocated ( kohonen_map % grid )) then do ix = 1 , size ( kohonen_map % grid , 1 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do iz = 1 , size ( kohonen_map % grid , 3 ); call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif ! if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif ! if ( allocated ( kohonen_map % number_patterns )) then deallocate ( kohonen_map % number_patterns ); endif ! if ( allocated ( kohonen_map % cells_index )) then deallocate ( kohonen_map % cells_index ); endif ! if ( allocated ( kohonen_map % u_matrix )) then deallocate ( kohonen_map % u_matrix ); endif ! if ( allocated ( kohonen_map % distance )) then deallocate ( kohonen_map % distance ); endif ! if ( allocated ( kohonen_map % distance_function )) then deallocate ( kohonen_map % distance_function ); endif ! ! Deallocate cluster layers arrays ! do ix = 1 , size ( kohonen_map % cluster_layer ) call kohonen_map % cluster_layer ( ix )% destroy (); enddo deallocate ( kohonen_map % cluster_layer ) ! if ( allocated ( kohonen_map % cluster_cells_index )) then deallocate ( kohonen_map % cluster_cells_index ); endif ! if ( allocated ( kohonen_map % cluster_number_patterns )) then deallocate ( kohonen_map % cluster_number_patterns ); endif ! if ( allocated ( kohonen_map % grid_cluster )) then deallocate ( kohonen_map % grid_cluster ); endif ! if ( allocated ( kohonen_map % cluster_samples )) then deallocate ( kohonen_map % cluster_samples ); endif ! if ( allocated ( kohonen_map % number_cluster_samples )) then deallocate ( kohonen_map % number_cluster_samples ); endif ! if ( allocated ( kohonen_map % index_cluster_samples )) then deallocate ( kohonen_map % index_cluster_samples ); endif ! write ( * , * ) 'TWO LEVEL SOM: Releasing memory...OK!' ! end subroutine destroy_2lsom !======================================================================================== subroutine create_random_sample ( kohonen_map , input ) !======================================================================================== !! Subroutine to generate random values that serve as inputs to the SOM class ( two_level_self_organizing_map ) :: kohonen_map !! A `self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( out ) :: input !! A real array with the initial values of the prototypes integer :: nvar1 , nvar2 , i , j ! nvar1 = size ( input , 1 ); nvar2 = size ( input , 2 ); do i = 1 , nvar1 ; do j = 1 , nvar2 ; input ( i , j ) = kohonen_map % rnumber_grator ( 1 )% generate (); end do end do ! end subroutine create_random_sample !======================================================================================== subroutine train_2lsom ( kohonen_map , input_data ) !======================================================================================== !!   Subroutine to train a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array call train_grid_layer ( kohonen_map , input_data ); ! call train_cluster_layer ( kohonen_map ); ! call kohonen_map % assign_input_to_clusters ( input_data ); ! end subroutine train_2lsom !======================================================================================== subroutine predict_2lsom ( kohonen_map , input_data , map_output ) !======================================================================================== !! Subroutine to make a prediction from a trained two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array integer , dimension (:,:), intent ( out ) :: map_output !! An integer array integer :: ipattern , ihit , jhit , khit , ix , iy , iz , number_variables , ic real ( kind = wp ) :: dist_hit , dist type ( kohonen_prototype ) :: current_prototype , predict_grid_prototype , predict_cluster_prototype real ( kind = wp ), dimension ( kohonen_map % number_variables1 , kohonen_map % number_variables2 ) :: current_values real ( kind = wp ), dimension ( kohonen_map % number_clusters ) :: distance_units ! number_variables = kohonen_map % number_variables1 * kohonen_map % number_variables2 ; ! write ( * , * ) write ( * , * ) ' TWO LEVEL SOM: Prediction starting...' ; write ( * , * ) !       write(*,*) '                Prediction for Grid Layer in progress' do ipattern = 1 , size ( input_data , 1 ) ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0 ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix ; jhit = iy ; khit = iz ; endif enddo !ix enddo !iy enddo !iz !call kohonen_map%grid(ihit,jhit,khit)%get_prototype(current_values); predict_grid_prototype = kohonen_map % grid ( ihit , jhit , khit ); ihit = 0 ; dist_hit = 1 0.0e4 ; do ic = 1 , size ( kohonen_map % cluster_layer ) dist = kohonen_map % cluster_layer ( ic )% distance ( predict_grid_prototype , kohonen_map % distance_function ); distance_units ( ic ) = dist ; if ( dist . lt . dist_hit ) then dist_hit = dist ; ihit = ic ; endif enddo !         write(*,*) ipattern,ihit predict_cluster_prototype = kohonen_map % cluster_layer ( ihit ); call predict_cluster_prototype % get_prototype ( current_values ); map_output ( ipattern , 1 ) = ihit enddo !ipattern write ( * , * ) 'TWO LEVEL SOM: Prediction finished' ; ! end subroutine predict_2lsom !======================================================================================== subroutine train_grid_layer ( kohonen_map , input_data ) !======================================================================================== !! Subroutine to train the grid layer of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array integer :: iteration , iepoch , ipattern , ix , iy , iz , jhit , ihit , khit , ineigh , jneigh , kneigh integer :: idbg , number_variables , max_pattern , ierr , nx , ny , nz , ic , current_pos integer :: cx , cy , cz , i , j , k , number_nodes , debug_option , pos , pos1 , ix1 , iy1 , iz1 real ( kind = wp ) :: distortion , dist , dist_hit , maximum_radius , minimum_radius , current_radius , alpha real ( kind = wp ) :: sigma2 , geometric_distance2 , h_neighborhood , real_distance , lambda , current_distance , d1 , d2 , d3 real ( kind = wp ) :: term3 , distance_ratio type ( kohonen_prototype ) :: current_prototype , current_prototype1 real ( kind = wp ), dimension ( kohonen_map % number_variables1 ,& kohonen_map % number_variables2 ) :: current_values , prototype_values , winner_values , term1 , term2 integer , allocatable :: pattern_index (:,:,:,:) logical :: testop integer :: unit_out nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; idbg = kohonen_map % parameters ( 1 )% idbg ; debug_option = kohonen_map % parameters ( 1 )% debug_level ; if ( debug_option . gt . 0 ) then open ( idbg , file = trim ( kohonen_map % parameters ( 1 )% debug_file ), status = 'unknown' ); endif iteration = 0 distortion = 0.0_wp number_variables = kohonen_map % number_variables ; maximum_radius = real ( max ( kohonen_map % parameters ( 1 )% number_nodes_nx , kohonen_map % parameters ( 1 )% number_nodes_ny ,& kohonen_map % parameters ( 1 )% number_nodes_nz )); lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); minimum_radius = 1.0_wp ; if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Grid Layer: Training starting...' endif do iepoch = 1 , kohonen_map % parameters ( 1 )% number_epochs if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion endif distortion = 0.0_wp do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns iteration = iteration + 1 !          det best match grid unit ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e7 call input_data ( ipattern )% get ( current_prototype ); call current_prototype % get_prototype ( current_values ); !call kohonen_map%find_best_match_unit(current_prototype,ihit,jhit,khit,dist_hit); !call current_prototype%print(unit_out); !write(*,*) 'check= ',ipattern,ihit,jhit,khit,dist_hit if ( debug_option . gt . 0 ) then write ( idbg , * ) 'Epoch,Current Pattern' , iepoch , ipattern ; call current_prototype % print ( idbg ); endif ! do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ! calculate distance !call kohonen_map%grid(ix,iy,iz)%print(); dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype ,& kohonen_map % distance_function ); !write(*,*) ix,iy,iz,dist !stop if ( debug_option . gt . 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ); write ( idbg , * ) ix , iy , iz , dist endif dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix ; jhit = iy ; khit = iz ; endif enddo !iz enddo !iy enddo !ix !write(*,*) 'epoch,ipat,i,j,k,d= ',iepoch,ipattern,ihit,jhit,dist_hit !            if(kohonen_map%parameters(1)%ireal == 7) then !               write(unit_out,*) 'current_prototype' !               call current_prototype%print(unit_out) !               write(unit_out,*) 'bmu ',ipattern,ihit,jhit,dist_hit !               call kohonen_map%grid(ihit,jhit,khit)%print(unit_out) !            endif !           kohonen_map%number_patterns(ihit,jhit)=kohonen_map%number_patterns(ihit,jhit)+1; distortion = distortion + dist_hit ; ! define radius current_radius = max ( maximum_radius * real ( 1001 - iteration ) / 100 0.0 + 0.9999999999 , 1.0_wp ); ! define learning rate alpha = max ( kohonen_map % parameters ( 1 )% learning_rate * ( 1.0_wp - real ( iteration ) / 100 0.0 ), 0.01_wp ); sigma2 = current_radius ** 2 !max(0.2*maximum_radius*(1.0_wp-real(iteration)/1000.0),1.0_wp); ! update prototypes if ( debug_option . gt . 0 ) then write ( idbg , * ) 'Neighborhood,alpha= ' , alpha endif ! !           call kohonen_map%update_weights(current_values,ihit,jhit,khit,maximum_radius,iteration) ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance . lt . current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters ( 1 )% neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * exp ( - 0.5 * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option . gt . 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters ( 1 )% som_type )); case ( 'normal_som' ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); case ( 'visom' ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh . eq . ihit ) . and . ( jneigh . eq . jhit ) . and . ( kneigh . eq . khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); !eps=max(1.0_wp*time_factor,0.0_wp); term3 = 1.0_wp ; !((1.0_wp-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * ( distance_ratio - 1.0_wp ) * term3 ); endif call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo ! enddo !ipattern !if(kohonen_map%parameters(1)%ireal == 7) stop enddo !iepoch if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Grid Layer: Training finished' endif ! Print prototypes !     print prototypes inquire ( unit = kohonen_map % parameters ( 1 )% iprot , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % grid , 3 ); write ( kohonen_map % parameters ( 1 )% iprot , '(A,I4)' ) 'Layer ' , iz do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters ( 1 )% iprot , '(A6,1X,3I4)' ) 'node= ' , ix , iy , iz call kohonen_map % grid ( ix , iy , iz )% print ( kohonen_map % parameters ( 1 )% iprot ); enddo enddo enddo !ix endif !     calculate and print distance matrix inquire ( unit = kohonen_map % parameters ( 1 )% idist , opened = testop ); if ( testop ) then call kohonen_map % calculate_distance_between_prototypes () ! !         do ix=1,size(kohonen_map%grid,1); !           do iy=1,size(kohonen_map%grid,2); !              do iz=1,size(kohonen_map%grid,3); !                  current_prototype=kohonen_map%grid(ix,iy,iz); !                  pos=ix+(iy-1)*kohonen_map%parameters(1)%number_nodes_ny+& !                    (iz-1)*kohonen_map%parameters(1)%number_nodes_nx*kohonen_map%parameters(1)%number_nodes_ny; !                  do ix1=1,size(kohonen_map%grid,1); !                     do iy1=1,size(kohonen_map%grid,2); !                        do iz1=1,size(kohonen_map%grid,3); !                           pos1=ix1+(iy1-1)*kohonen_map%parameters(1)%number_nodes_ny+& !                              (iz1-1)*kohonen_map%parameters(1)%number_nodes_nx*& !                              kohonen_map%parameters(1)%number_nodes_ny; !                           current_prototype1=kohonen_map%grid(ix1,iy1,iz1); !                           kohonen_map%distance(pos,pos1)=current_prototype1%distance(current_prototype,& !                                                         kohonen_map%distance_function); !                        enddo!iz1 !                     enddo!iy1 !                  enddo!ix1 !               enddo!iz !            enddo!iy !         enddo!ix ! ! !         do ix=1,size(kohonen_map%distance,1) !            write(kohonen_map%parameters(1)%idist,*) (kohonen_map%distance(ix,iy),iy=1,size(kohonen_map%distance,2)); !         enddo!ix endif ! !     final best match if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Grid Layer: Find Best Match Unit...' write ( 6 , * ) endif max_pattern = 0 ; do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 10000 0.0 ; call input_data ( ipattern )% get ( current_prototype ); !call current_prototype%get_prototype(current_values); !         call kohonen_map%find_best_match_unit(current_prototype,ihit,jhit,khit,dist_hit); !write(*,*) 'bmu=',ipattern,ihit,jhit,khit do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix ; jhit = iy ; khit = iz ; endif enddo enddo enddo kohonen_map % number_patterns ( ihit , jhit , khit ) = kohonen_map % number_patterns ( ihit , jhit , khit ) + 1 ; if ( kohonen_map % number_patterns ( ihit , jhit , khit ) . gt . max_pattern ) then max_pattern = kohonen_map % number_patterns ( ihit , jhit , khit ); endif kohonen_map % cells_index ( ipattern , 1 ) = ihit ; kohonen_map % cells_index ( ipattern , 2 ) = jhit ; kohonen_map % cells_index ( ipattern , 3 ) = khit ; if ( debug_option . gt . 0 ) then write ( idbg , * ) ipattern , ihit , jhit , khit endif inquire ( unit = kohonen_map % parameters ( 1 )% iindex , opened = testop ); if ( testop ) then write ( kohonen_map % parameters ( 1 )% iindex , * ) ipattern , ihit , jhit , khit endif !          mtchx(i) = ihit !          mtchy(i) = jhit !          ioutrep(ihit,jhit) = i enddo !ipattern if ( kohonen_map % parameters ( 1 )% debug_level . gt . 0 ) then close ( idbg ) endif allocate ( pattern_index ( size ( kohonen_map % grid , 1 ), size ( kohonen_map % grid , 2 ),& size ( kohonen_map % grid , 3 ),& max_pattern ), stat = ierr ); pattern_index =- 1 ; do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); do i = 1 , max_pattern if ( pattern_index ( ix , iy , iz , i ) . lt . 0 ) then pattern_index ( ix , iy , iz , i ) = ipattern ; exit endif enddo enddo !ipattern inquire ( unit = kohonen_map % parameters ( 1 )% isam , opened = testop ); if ( testop ) then do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters ( 1 )% isam , '(A,3I4)' ) 'Node= ' , ix1 , iy1 , iz1 if ( kohonen_map % number_patterns ( ix1 , iy1 , iz1 ) . gt . 0 ) then write ( kohonen_map % parameters ( 1 )% isam , '(A,100I4)' ) 'Sample ID= ' ,& pattern_index ( ix1 , iy1 , iz1 , 1 : kohonen_map % number_patterns ( ix1 , iy1 , iz1 )); else write ( kohonen_map % parameters ( 1 )% isam , '(A,I4)' ) 'Sample ID= ' , 0 endif enddo enddo enddo deallocate ( pattern_index ); endif !     print hit counter inquire ( unit = kohonen_map % parameters ( 1 )% ihit , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % grid , 3 ) write ( kohonen_map % parameters ( 1 )% ihit , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % grid , 1 ); write ( kohonen_map % parameters ( 1 )% ihit , '(100I6)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 , size ( kohonen_map % grid , 2 )); enddo !ix enddo !iz endif !     calculate u_matrix inquire ( unit = kohonen_map % parameters ( 1 )% iumat , opened = testop ); if ( testop ) then call kohonen_map % calculate_u_matrix (); !       do iz=1,size(kohonen_map%grid,3); !          do iy=1,size(kohonen_map%grid,2); !             do ix=1,size(kohonen_map%grid,1); !                dist=0.0_wp; !                number_nodes=0; !                do k=-1,1 !                   do j=-1,1 !                      do i=-1,1 !                         cx=ix+i;cy=iy+j;cz=iz+k; !                         if( (cx .ge. 1 .and. cx .le. size(kohonen_map%grid,1)) .and. & !                           (cy .ge. 1 .and. cy .le. size(kohonen_map%grid,2)) .and. & !                           (cz .ge. 1 .and. cz .le. size(kohonen_map%grid,3))) then !                               !write(*,*) ix,iy,cx,cy !                               dist=dist+kohonen_map%grid(ix,iy,iz)%distance(kohonen_map%grid(cx,cy,cz),& !                                     kohonen_map%distance_function); !                               number_nodes=number_nodes+1; !                         endif !                      enddo !                   enddo!j !                enddo!i !                kohonen_map%u_matrix(ix,iy,iz)=dist/real(number_nodes); !             enddo!iz !          enddo!iy !       enddo!ix !       do iz=1,size(kohonen_map%grid,3) !          write(kohonen_map%parameters(1)%iumat,'(A,I4)') 'Layer ',iz !          do ix=1,size(kohonen_map%grid,1) !             write(kohonen_map%parameters(1)%iumat,*) (kohonen_map%u_matrix(ix,iy,iz),iy=1,size(kohonen_map%grid,2)); !          enddo !       enddo endif if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Grid Layer: Find Best Match Unit finished' write ( 6 , * ) endif end subroutine train_grid_layer !======================================================================================== subroutine train_cluster_layer ( kohonen_map ) !======================================================================================== !! Subroutine to train the cluster layer of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: ix , iy , iz , iepoch , ihit , ic , number_variables , iteration , ineigh , current_pos , ipattern , ipos , pos type ( kohonen_prototype ) :: current_prototype real ( kind = wp ) :: dist_hit , dist , distortion , maximum_radius , minimum_radius , current_radius real ( kind = wp ) :: alpha , h_neighborhood , sigma2 , geometric_distance2 real ( kind = wp ), dimension ( kohonen_map % number_variables1 ,& kohonen_map % number_variables2 ) :: current_values , prototype_values real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ) :: centers real ( kind = wp ), dimension ( kohonen_map % number_clusters ) :: distance_units real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ,& kohonen_map % number_clusters ) :: centers1 logical :: testop ! number_variables = kohonen_map % number_variables1 * kohonen_map % number_variables2 ; !maximum_radius=real(max(kohonen_map%parameters%number_nodes_nx,kohonen_map%parameters%number_nodes_ny)); maximum_radius = real ( kohonen_map % number_clusters ); minimum_radius = 1.0_wp ; ! iteration = 0 distortion = 0.0_wp ; if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Cluster Layer: Training starting...' endif ! do iepoch = 1 , kohonen_map % parameters ( 2 )% number_epochs if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) ' Starting epoch -- distortion' , iepoch , ' -- ' , distortion endif distortion = 0.0_wp ; do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); iteration = iteration + 1 ihit = 0 ; dist_hit = 10000 0.0 ; current_prototype = kohonen_map % grid ( ix , iy , iz ); call current_prototype % get_prototype ( current_values ); do ic = 1 , size ( kohonen_map % cluster_layer ) dist = kohonen_map % cluster_layer ( ic )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ic ; endif enddo !ic distortion = distortion + dist_hit ; current_radius = max ( maximum_radius * real ( 1001 - iteration ) / 100 0.0 + 0.9999999999 , 0.49_wp ); sigma2 = current_radius ** 2 ; !current_radius=0.0_wp; ! define learning rate alpha = max ( kohonen_map % parameters ( 2 )% learning_rate * & ( 1.0_wp - real ( iteration ) / 100 0.0 ), 0.01_wp ); do ineigh = ihit - int ( current_radius ), ihit + int ( current_radius ) if ( ineigh . ge . 1 . and . ineigh . le . size ( kohonen_map % cluster_layer )) then select case ( trim ( kohonen_map % parameters ( 2 )% neighborhood_type )) case ( 'gaussian' ); geometric_distance2 = ( ihit - ineigh ) ** 2 ; h_neighborhood = alpha * exp ( - 0.5 * geometric_distance2 / sigma2 ); case ( 'bubble' ); h_neighborhood = alpha ; end select call kohonen_map % cluster_layer ( ineigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); call kohonen_map % cluster_layer ( ineigh )% set_prototype ( prototype_values ); endif enddo !ineigh enddo !iz enddo !iy enddo !ix enddo !iepoch if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( * , * ) 'TWO LEVEL SOM - Cluster Layer: Training finished' ; ! write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Cluster Layer: Find Best Match Unit...' write ( 6 , * ) endif ! current_pos = 0 ; do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_pos = current_pos + 1 ; ihit = 0 ; dist_hit = 10000 0.0 ; current_prototype = kohonen_map % grid ( ix , iy , iz ); call current_prototype % get_prototype ( current_values ); do ic = 1 , size ( kohonen_map % cluster_layer ); dist = kohonen_map % cluster_layer ( ic )% distance ( current_prototype , kohonen_map % distance_function ); dist = dist / float ( number_variables ); distance_units ( ic ) = dist ; if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ic ; !write(*,*) 'hit= ',ix,iy,iz,ihit endif enddo kohonen_map % cluster_cells_index ( current_pos , 1 ) = ix ; kohonen_map % cluster_cells_index ( current_pos , 2 ) = iy ; kohonen_map % cluster_cells_index ( current_pos , 3 ) = iz ; kohonen_map % cluster_cells_index ( current_pos , 4 ) = ihit ; !write(6,*) 'hit= ',ix,iy,iz,ihit !            if(kohonen_map%number_patterns(ix,iy,iz) .ge. 1) then kohonen_map % grid_cluster ( ix , iy , iz ) = ihit ; !            endif !             if(debug_option .gt. 0) then !               write(idbg,*) ix,iy,iz,ihit !             endif enddo !iz enddo !iy enddo !ix ! Print grid cluster inquire ( unit = kohonen_map % parameters ( 1 )% iclus , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % grid_cluster , 3 ); write ( kohonen_map % parameters ( 1 )% iclus , * ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % grid_cluster , 1 ); write ( kohonen_map % parameters ( 1 )% iclus , '(100I5)' ) ( kohonen_map % grid_cluster ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % grid_cluster , 2 )) enddo !ix enddo !iz endif ! !     do ipattern=1,48 !        write(*,*) kohonen_map%cells_index(ipattern,:) !     enddo do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns ix = kohonen_map % cells_index ( ipattern , 1 ); iy = kohonen_map % cells_index ( ipattern , 2 ); iz = kohonen_map % cells_index ( ipattern , 3 ); !write(*,*) 'pre= ',ipattern,ix,iy,iz,kohonen_map%parameters(1)%number_patterns do ipos = 1 , size ( kohonen_map % cluster_cells_index , 1 ) if ( kohonen_map % cluster_cells_index ( ipos , 1 ) . eq . ix . and . & kohonen_map % cluster_cells_index ( ipos , 2 ) . eq . iy . and . & kohonen_map % cluster_cells_index ( ipos , 3 ) . eq . iz ) then pos = ipos ; exit endif enddo !ipos ic = kohonen_map % cluster_cells_index ( pos , 4 ); kohonen_map % cluster_samples ( ipattern ) = ic ; !write(*,*) 'clust-train = ',pos,ipattern, ic inquire ( unit = kohonen_map % parameters ( 1 )% iclus1 , opened = testop ); if ( testop ) then write ( kohonen_map % parameters ( 1 )% iclus1 , * ) ipattern , ix , iy , iz , ic ; endif enddo !ipattern ! do ic = 1 , size ( kohonen_map % cluster_layer ); !write(unit1,*) 'Cluster= ',ic !call kohonen_map%cluster_layer(ic)%print(unit1); call kohonen_map % cluster_layer ( ic )% get_prototype ( centers ) centers1 (:, ic ) = centers (:) enddo !ic inquire ( unit = kohonen_map % parameters ( 1 )% icen , opened = testop ); if ( testop ) then do ix = 1 , size ( centers1 , 1 ) write ( kohonen_map % parameters ( 1 )% icen , * ) ix ,( centers1 ( ix , ic ), ic = 1 , size ( centers1 , 2 )) enddo endif ! if ( kohonen_map % parameters ( 1 )% view_flag ) then write ( 6 , * ) write ( 6 , * ) 'TWO LEVEL SOM - Cluster Layer: Find Best Match Unit finished' write ( 6 , * ) endif ! end subroutine train_cluster_layer !======================================================================================== subroutine print_2lsom ( kohonen_map , unit_ ) !======================================================================================== !!   Subroutine to print the layers of a two_level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer , optional :: unit_ !! An integer variable with the unit integer :: unit1 , ix , iy , iz , ic real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ) :: centers real ( kind = wp ), dimension ( kohonen_map % number_variables1 * kohonen_map % number_variables2 ,& kohonen_map % number_clusters ) :: centers1 ! if (. not . present ( unit_ )) then unit1 = 6 ; else unit1 = unit_ ; endif ! write ( unit1 , * ) 'TWO LEVEL SOM: Results' ; write ( unit1 , * ) call kohonen_map % parameters ( 1 )% print ( unit1 ); ! write(unit1,*) 'After' write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Grid nodes' ; write ( unit1 , * ) do iz = 1 , size ( kohonen_map % grid , 3 ); do ix = 1 , size ( kohonen_map % grid , 1 ); do iy = 1 , size ( kohonen_map % grid , 2 ); write ( unit1 , * ) ix , iy , iz call kohonen_map % grid ( ix , iy , iz )% print ( unit1 ); enddo !iy enddo !ix enddo write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Grid Hit count' ; write ( unit1 , * ) write ( unit1 , * ) 'Pattern Numbers' ; do iz = 1 , size ( kohonen_map % number_patterns , 3 ) write ( unit1 , * ) write ( unit1 , * ) 'Layer ' , iz write ( unit1 , * ) do ix = 1 , size ( kohonen_map % number_patterns , 1 ) write ( unit1 , '(100I5)' ) ( kohonen_map % number_patterns ( ix , iy , iz ), iy = 1 , size ( kohonen_map % number_patterns , 2 )) enddo enddo write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Grid Pattern index' write ( unit1 , * ) write ( unit1 , * ) write ( unit1 , * ) 'Pattern #, ix   ,iy' ; do ix = 1 , size ( kohonen_map % cells_index , 1 ) write ( unit1 , '(100I5)' ) ix , ( kohonen_map % cells_index ( ix , iy ), iy = 1 , size ( kohonen_map % cells_index , 2 )) enddo write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Cluster nodes' ; write ( unit1 , * ) open ( 2 , file = 'cluster_centers.out' , status = 'unknown' ) do ic = 1 , size ( kohonen_map % cluster_layer ); write ( unit1 , * ) 'Cluster= ' , ic call kohonen_map % cluster_layer ( ic )% print ( unit1 ); call kohonen_map % cluster_layer ( ic )% get_prototype ( centers ) centers1 (:, ic ) = centers (:) enddo !ic do ix = 1 , size ( centers1 , 1 ) write ( 2 , * ) ix ,( centers1 ( ix , ic ), ic = 1 , size ( centers1 , 2 )) enddo close ( 2 ) ! write ( unit1 , * ) write ( unit1 , * ) 'TWO LEVEL SOM: Cluster Pattern index' write ( unit1 , * ) ! do ix = 1 , size ( kohonen_map % cluster_cells_index , 1 ) write ( unit1 , * ) ( kohonen_map % cluster_cells_index ( ix , iy ), iy = 1 , size ( kohonen_map % cluster_cells_index , 2 )) enddo ! do iz = 1 , size ( kohonen_map % grid_cluster , 3 ); write ( unit1 , * ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % grid_cluster , 1 ); write ( unit1 , '(100I5)' ) ( kohonen_map % grid_cluster ( ix , iy , iz ), iy = 1 , size ( kohonen_map % grid_cluster , 2 )) enddo !ix enddo !iz ! end subroutine print_2lsom !======================================================================================== subroutine set_cluster_layer ( kohonen_map , seed ) !======================================================================================== !!   Subroutine to initialize the cluster layer of a Two Level Self-Organizing Map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: seed !! An integer variable with the random seed integer :: ix , number_clusters , ierr real ( kind = wp ), allocatable :: input (:,:) ! number_clusters = kohonen_map % parameters ( 2 )% number_nodes_nx * & kohonen_map % parameters ( 2 )% number_nodes_ny * & kohonen_map % parameters ( 2 )% number_nodes_nz ; write ( * , * ) 'nc=' , number_clusters allocate ( input ( kohonen_map % number_variables1 , kohonen_map % number_variables2 ), stat = ierr ) write ( * , * ) 'nc1= ' , size ( input , 1 ), size ( input , 2 ) ! seed = kohonen_map % parameters ( 2 )% random_seed_ ( 1 ); allocate ( kohonen_map % cluster_layer ( number_clusters ), stat = ierr ); write ( * , * ) seed call kohonen_map % rnumber_grator ( 2 )% create ( seed ); !call sgrnd(seed); do ix = 1 , number_clusters !call grnd_array(input); call kohonen_map % create_random_sample ( input ); write ( * , * ) ix , input write ( * , * ) size ( kohonen_map % cluster_layer ) call kohonen_map % cluster_layer ( ix )% create ( input ); enddo ! call kohonen_map % factory % create_distance ( kohonen_map % parameters ( 2 )% distance_type , kohonen_map % distance_function ); ! deallocate ( input ); ! end subroutine set_cluster_layer !======================================================================================== subroutine set_parameters ( kohonen_map , training_parameters ) !======================================================================================== !!   Subroutine to set parameters class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_layer_parameters ), dimension ( 2 ) :: training_parameters !A `kohonen_layer_parameters` object kohonen_map % parameters = training_parameters ; ! end subroutine set_parameters !======================================================================================== subroutine evaluate_2lsom ( kohonen_map , input_data , results ) !======================================================================================== !!   Subroutine to calculate some clustering statistics of a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_data !! A `kohonen_pattern` array real ( kind = wp ), dimension (:), optional :: results !! A real array integer :: ipattern1 , ipattern2 , current_cluster , ic , is , pos integer , dimension ( size ( input_data )) :: indicator , positions integer , dimension ( kohonen_map % number_clusters , size ( input_data )) :: sample_positions integer , dimension ( kohonen_map % number_clusters ) :: number_samples_cluster type ( kohonen_pattern ) :: current_pattern1 , current_pattern2 type ( kohonen_prototype ) :: current_prototype1 , current_prototype2 real ( kind = wp ), dimension ( kohonen_map % number_variables1 , kohonen_map % number_variables2 ) :: & current_values1 , current_values2 real ( kind = wp ) :: current_dissimilarity real ( kind = wp ), dimension ( size ( input_data )) :: mean_dissimilarity_a , silhouette , min_b , W , B real ( kind = wp ), dimension ( size ( input_data ), kohonen_map % number_clusters ) :: mean_dissimilarity_b !  Silouette or whatever !  find samples in each cluster min_b = 1 0.0d8 ; B = 0.0_wp ; W = 0.0_wp ; do is = 1 , size ( input_data ) positions ( is ) = is ; enddo ! do ic = 1 , kohonen_map % number_clusters indicator = 0 ; pos = 0 ; where ( kohonen_map % cluster_samples . eq . ic ) indicator = 1 ; end where number_samples_cluster ( ic ) = sum ( indicator ); if ( number_samples_cluster ( ic ) . eq . 0 ) then write ( 6 , * ) 'WARNING: Empty cluster. No cluster evaluation is done' if ( present ( results )) then results = 0.0_wp ; endif return endif do ipattern1 = 1 , size ( indicator ) if ( indicator ( ipattern1 ) . eq . 1 ) then pos = pos + 1 ; sample_positions ( ic , pos ) = ipattern1 ; endif enddo enddo !ic ! do ipattern1 = 1 , size ( input_data ) current_cluster = kohonen_map % cluster_samples ( ipattern1 ); ! get current prototype current_pattern1 = input_data ( ipattern1 ); call current_pattern1 % get ( current_prototype1 ); call current_prototype1 % get_prototype ( current_values1 ); current_dissimilarity = 0.0_wp ; do ipattern2 = 1 , number_samples_cluster ( current_cluster ); if ( sample_positions ( current_cluster , ipattern2 ) . ne . ipattern1 ) then current_pattern2 = input_data ( ipattern2 ); call current_pattern2 % get ( current_prototype2 ); call current_prototype2 % get_prototype ( current_values2 ); !\t    if(kohonen_map%number_variables1 .eq. 1 .or. kohonen_map%number_variables2 .eq. 1 ) then current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); !            else !              current_dissimilarity=current_dissimilarity+sum(sum((current_values1-current_values2)**2)); !            endif endif enddo !ipattern2 mean_dissimilarity_a ( ipattern1 ) = current_dissimilarity / max ( 1.0 , real ( number_samples_cluster ( current_cluster ) - 1 )); W ( ipattern1 ) = current_dissimilarity ; ! do ic = 1 , kohonen_map % number_clusters current_dissimilarity = 0.0_wp ; if ( ic . ne . current_cluster ) then do ipattern2 = 1 , number_samples_cluster ( ic ); current_pattern2 = input_data ( ipattern2 ); call current_pattern2 % get ( current_prototype2 ); call current_prototype2 % get_prototype ( current_values2 ); !               if(kohonen_map%number_variables1 .eq. 1 .or. kohonen_map%number_variables2 .eq. 1 ) then current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); !               else !                 current_dissimilarity=current_dissimilarity+sum(sum((current_values1-current_values2)**2)); !               endif enddo !ipattern2 endif mean_dissimilarity_b ( ipattern1 , ic ) = current_dissimilarity / max ( 1.0 , real ( number_samples_cluster ( ic ) - 1 )); B ( ipattern1 ) = B ( ipattern1 ) + current_dissimilarity ; enddo !ic ! do ic = 1 , kohonen_map % number_clusters if ( ic . ne . current_cluster . and . mean_dissimilarity_b ( ipattern1 , ic ) . lt . min_b ( ipattern1 ) ) then min_b ( ipattern1 ) = mean_dissimilarity_b ( ipattern1 , ic ) endif enddo ! if ( mean_dissimilarity_a ( ipattern1 ) . lt . min_b ( ipattern1 )) then silhouette ( ipattern1 ) = 1.0_wp - ( mean_dissimilarity_a ( ipattern1 ) / min_b ( ipattern1 )); else silhouette ( ipattern1 ) = ( min_b ( ipattern1 ) / mean_dissimilarity_a ( ipattern1 )) - 1.0_wp ; endif !write(6,*) ipattern1,mean_dissimilarity_a(ipattern1),min_b(ipattern1),silhouette(ipattern1) !(mean_dissimilarity_b(ipattern1,ic),ic=1,3); enddo !ipattern1 write ( 6 , * ) '' write ( 6 , * ) 'CH= ' ,( sum ( B ) / dble ( kohonen_map % number_clusters - 1 ))& / ( sum ( W ) / ( dble ( size ( input_data ) - kohonen_map % number_clusters ))); !,sum(B),sum(W), write ( 6 , * ) 'Silhouette= ' , sum ( silhouette ) / real ( size ( silhouette )) write ( 6 , * ) '' ! if ( present ( results )) then results ( 1 ) = sum ( B ); results ( 2 ) = sum ( W ); results ( 3 ) = sum ( silhouette ) / real ( size ( silhouette )); endif ! end subroutine evaluate_2lsom !======================================================================================== subroutine calculate_sum2_clusters_grid ( kohonen_map , results ) !======================================================================================== !! Subroutine to calculate some clustering statistics of a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:), optional :: results !! A real array integer :: ix1 , iy1 , iz1 , ic , current_cluster , j , ipos , pos , isample integer :: nx , ny , nz , cix , ciy , ciz , current_pos , sample_pos real ( kind = wp ), dimension ( kohonen_map % number_variables1 ,& kohonen_map % number_variables2 ) :: mean_unit real ( kind = wp ), dimension ( kohonen_map % number_clusters ) :: W , B real ( kind = wp ) :: current_dissimilarity real ( kind = wp ), dimension ( kohonen_map % number_variables1 * & kohonen_map % number_variables2 , 1 ) :: current_values1 , current_values2 type ( kohonen_prototype ) :: current_prototype1 , current_prototype2 integer , dimension ( kohonen_map % number_nodes ) :: indicator integer , dimension ( kohonen_map % number_clusters ) :: number_samples_cluster integer , dimension ( kohonen_map % number_nodes ) :: positions integer , dimension ( kohonen_map % number_clusters , kohonen_map % number_nodes ) :: sample_positions real ( kind = wp ), dimension ( kohonen_map % number_nodes ) :: mean_dissimilarity_a , min_b , silhouette real ( kind = wp ), dimension ( kohonen_map % number_nodes , kohonen_map % number_clusters ) :: mean_dissimilarity_b ! positions ( 1 : kohonen_map % number_nodes ) = ( / ( ipos , ipos = 1 , kohonen_map % number_nodes ) / ) ! nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; !  find samples in each cluster min_b = 1 0.0d8 ; ! B = 0.0_wp ; W = 0.0_wp ; mean_unit = 0.0_wp ! do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); current_cluster = kohonen_map % grid_cluster ( ix1 , iy1 , iz1 ); current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); call current_prototype1 % get_prototype ( current_values1 ); current_prototype2 = kohonen_map % cluster_layer ( current_cluster ); call current_prototype2 % get_prototype ( current_values2 ) W ( current_cluster ) = W ( current_cluster ) + sum (( current_values1 - current_values2 ) ** 2 ); mean_unit = mean_unit + current_values1 ; enddo !ix enddo !iy enddo !iz mean_unit = mean_unit / dble ( nx * ny * nz ); ! do ic = 1 , kohonen_map % number_clusters current_prototype1 = kohonen_map % cluster_layer ( ic ); call current_prototype1 % get_prototype ( current_values1 ); B ( ic ) = B ( ic ) + sum (( current_values1 - mean_unit ) ** 2 ); enddo !ic ! if ( present ( results )) then results ( 1 ) = sum ( W ); results ( 2 ) = sum ( B ); !  else !     write(6,*) 'Number clusters,W,B= ',kohonen_map%number_clusters,sum(W),sum(B) endif ! ! Silhouette for grid layer ! do ic = 1 , kohonen_map % number_clusters indicator = 0 ; where ( kohonen_map % cluster_cells_index (:, 4 ) == ic ) indicator = 1 ; end where number_samples_cluster ( ic ) = sum ( indicator ); pos = 0 ; do isample = 1 , size ( indicator ) if ( indicator ( isample ) . eq . 1 ) then pos = pos + 1 ; sample_positions ( ic , pos ) = isample ; endif enddo !write(6,*) (sample_positions(ic,isample),isample=1,number_samples_cluster(ic)); enddo ! current_pos = 0 ; do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); current_pos = current_pos + 1 ; current_cluster = kohonen_map % grid_cluster ( ix1 , iy1 , iz1 ); current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); call current_prototype1 % get_prototype ( current_values1 ); current_dissimilarity = 0.0_wp ; do ic = 1 , number_samples_cluster ( current_cluster ); if ( sample_positions ( current_cluster , ic ) . ne . current_pos ) then sample_pos = sample_positions ( current_cluster , ic ); cix = kohonen_map % cluster_cells_index ( sample_pos , 1 ); ciy = kohonen_map % cluster_cells_index ( sample_pos , 2 ); ciz = kohonen_map % cluster_cells_index ( sample_pos , 3 ); current_prototype2 = kohonen_map % grid ( cix , ciy , ciz ); call current_prototype2 % get_prototype ( current_values2 ); current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); endif enddo mean_dissimilarity_a ( current_pos ) = current_dissimilarity / dble ( number_samples_cluster ( current_cluster )); ! do ic = 1 , kohonen_map % number_clusters if ( ic /= current_cluster ) then current_dissimilarity = 0.0_wp ; do isample = 1 , number_samples_cluster ( ic ); sample_pos = sample_positions ( ic , isample ); cix = kohonen_map % cluster_cells_index ( sample_pos , 1 ); ciy = kohonen_map % cluster_cells_index ( sample_pos , 2 ); ciz = kohonen_map % cluster_cells_index ( sample_pos , 3 ); current_prototype2 = kohonen_map % grid ( cix , ciy , ciz ); call current_prototype2 % get_prototype ( current_values2 ); current_dissimilarity = current_dissimilarity + sum (( current_values1 - current_values2 ) ** 2 ); enddo !isample mean_dissimilarity_b ( current_pos , ic ) = current_dissimilarity / dble ( number_samples_cluster ( ic )); endif enddo !ic ! do ic = 1 , kohonen_map % number_clusters if ( ic . ne . current_cluster . and . mean_dissimilarity_b ( current_pos , ic ) . lt . min_b ( current_pos ) ) then min_b ( current_pos ) = mean_dissimilarity_b ( current_pos , ic ) endif enddo ! if ( mean_dissimilarity_a ( current_pos ) . lt . min_b ( current_pos )) then silhouette ( current_pos ) = 1.0_wp - ( mean_dissimilarity_a ( current_pos ) / min_b ( current_pos )); else silhouette ( current_pos ) = ( min_b ( current_pos ) / mean_dissimilarity_a ( current_pos )) - 1.0_wp ; endif ! enddo !ix1 enddo !iy1 enddo !iz1 write ( * , * ) 'Number clusters,W,B,sil= ' , kohonen_map % number_clusters , sum ( W ), sum ( B ), sum ( silhouette ) / dble ( kohonen_map % number_nodes ); if ( present ( results )) then results ( 3 ) = sum ( silhouette ) / dble ( kohonen_map % number_nodes ); endif !  write(*,*) 'b',min_b !mean_dissimilarity_b !  write(*,*) 'a',mean_dissimilarity_a !  write(*,*) 'a,b',sum(mean_dissimilarity_a)/dble(kohonen_map%number_clusters),& !                   sum(mean_dissimilarity_b)/dble(kohonen_map%number_clusters) ! ! end subroutine calculate_sum2_clusters_grid !======================================================================================== subroutine calculate_cluster_measures ( kohonen_map , results ) !======================================================================================== !! Subroutine to calculate some clustering statistics of a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:,:,:) :: results !! A real array logical :: testop ! inquire ( unit = kohonen_map % parameters ( 1 )% iout , opened = testop ); if (. not . testop ) then write ( 6 , * ) 'ERROR: the output file is not opened' stop endif ! end subroutine calculate_cluster_measures !======================================================================================== subroutine read_som_layer ( kohonen_map , som_fl , layer_type ) !======================================================================================== !! Subroutine to read the prototypes of the first/seconf layer of a two level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object character ( len =* ) :: som_fl , layer_type !! A character variable logical :: testfl , toroidal_grid integer :: isom , nx , ny , nz , nvar1 , nvar2 , ierr , ix , iy , iz , ivar , current_index character ( len = 40 ) :: current_line , node_type real ( kind = wp ), allocatable :: Prototype_value (:,:) ! isom = 20 ; inquire ( file = trim ( som_fl ), exist = testfl ); if (. not . testfl ) then write ( * , * ) 'ERROR: the som file does not exist' stop endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...' write ( * , * ) open ( isom , file = trim ( som_fl ), status = 'unknown' , action = 'read' , access = 'sequential' ); read ( isom , '(A)' ) current_line write ( * , * ) trim ( current_line ) read ( isom , '(A17,1X,3I6)' ) current_line , nx , ny , nz write ( * , * ) current_line , nx , ny , nz read ( isom , '(A21,1X,2I6)' ) current_line , nvar1 , nvar2 write ( * , * ) current_line , nvar1 , nvar2 kohonen_map % number_variables1 = nvar1 ; kohonen_map % number_variables2 = nvar2 ; kohonen_map % number_variables = nvar1 * nvar2 ; read ( isom , '(A25,1X,A11,1X,L4)' ) current_line , node_type , toroidal_grid write ( * , * ) current_line , node_type , toroidal_grid allocate ( Prototype_value ( nvar1 * nvar2 , 1 ), stat = ierr ); ! select case ( trim ( layer_type )) case ( 'grid' ) if ( allocated ( kohonen_map % grid )) then do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) call kohonen_map % grid ( ix , iy , iz )% destroy (); enddo enddo enddo deallocate ( kohonen_map % grid ); endif allocate ( kohonen_map % grid ( nx , ny , nz ), stat = ierr ); if ( allocated ( kohonen_map % coordinates )) then deallocate ( kohonen_map % coordinates ); endif allocate ( kohonen_map % coordinates ( nx * ny * nz , 3 ), stat = ierr ); if ( allocated ( kohonen_map % cells_distances )) then deallocate ( kohonen_map % cells_distances ); endif allocate ( kohonen_map % cells_distances ( nx * ny * nz , nx * ny * nz ), stat = ierr ); if ( allocated ( kohonen_map % cluster_cells_index )) then deallocate ( kohonen_map % cluster_cells_index ); endif allocate ( kohonen_map % cluster_cells_index ( nx * ny * nz , 4 ), stat = ierr ); if ( allocated ( kohonen_map % grid_cluster )) then deallocate ( kohonen_map % grid_cluster ); endif allocate ( kohonen_map % grid_cluster ( nx , ny , nz ), stat = ierr ); case ( 'cluster' ) if ( allocated ( kohonen_map % cluster_layer ) ) then do iz = 1 , size ( kohonen_map % cluster_layer , 1 ) call kohonen_map % cluster_layer ( ix )% destroy (); enddo deallocate ( kohonen_map % cluster_layer ); endif allocate ( kohonen_map % cluster_layer ( nx ), stat = ierr ); end select do iz = 1 , nz read ( isom , '(A)' ) current_line write ( * , * ) 'Reading ' , trim ( current_line ) do iy = 1 , ny do ix = 1 , nx read ( isom , '(A)' ) current_line !            write(*,*) current_line read ( isom , '(A)' ) current_line !            write(*,*) current_line read ( isom , * ) ( Prototype_value ( ivar , 1 ), ivar = 1 , nvar1 * nvar2 ) !write(*,*) ix,iy,(Prototype_value(ivar,1),ivar=1,nvar1*nvar2) select case ( trim ( layer_type )) case ( 'grid' ) call kohonen_map % grid ( ix , iy , iz )% create ( Prototype_value ); !call kohonen_map%grid(ix,iy,iz)%print() current_index = position2index ( ix , iy , iz , nx , ny ); call calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , kohonen_map % coordinates , node_type ); case ( 'cluster' ) call kohonen_map % cluster_layer ( ix )% set_prototype ( Prototype_value ); end select enddo enddo enddo close ( isom ) ! if ( trim ( layer_type ) . eq . 'grid' ) then call calculate_distance_matrix ( kohonen_map % coordinates , kohonen_map % cells_distances , node_type , toroidal_grid ); endif ! write ( * , * ) write ( * , * ) 'SOM: Reading SOM Prototypes...finished' write ( * , * ) ! end subroutine read_som_layer !======================================================================================== subroutine query_2lsom ( kohonen_map , input_pattern , sample_index ) !,output_patterns) !======================================================================================== !!  Function to find the input samples associated with specific vector class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: input_pattern !! A real array integer , allocatable :: sample_index (:) !! An integer array integer :: ix , iy , iz , ihit , jhit , khit , ivar1 , ivar2 , nvar1 , nvar2 , number_patterns , ipat , ierr integer :: number_selected , i , pos , ic , number_samples real ( kind = wp ), dimension ( kohonen_map % parameters ( 1 )% number_variables1 ,& kohonen_map % parameters ( 1 )% number_variables2 ) :: current_values , centers real ( kind = wp ) :: dist , dist_min integer , dimension ( size ( kohonen_map % cells_index , 1 )) :: position , real_position ! do ic = 1 , size ( kohonen_map % cluster_layer ); !write(unit1,*) 'Cluster= ',ic !call kohonen_map%cluster_layer(ic)%print(unit1); call kohonen_map % cluster_layer ( ic )% get_prototype ( centers ); !centers1(:,ic)=centers(:) dist_min = 1.0d5 ; dist = 0.0_wp ; do ix = 1 , size ( centers , 1 ); do iy = 1 , size ( centers , 2 ); if ( input_pattern ( ix , iy ) > 0.0_wp ) then dist = dist + ( input_pattern ( ix , iy ) - centers ( ix , iy )) ** 2 endif enddo enddo if ( dist < dist_min ) then dist_min = dist ; ihit = ic ; endif number_samples = kohonen_map % number_cluster_samples ( ihit ); if ( number_samples . gt . 0 ) then allocate ( sample_index ( number_samples ), stat = ierr ); sample_index = kohonen_map % index_cluster_samples ( ihit , 1 : number_samples ); else write ( * , * ) 'WARNING: Empty query' return endif enddo !ic ! end subroutine query_2lsom !======================================================================================== subroutine get_cluster_samples ( kohonen_map , clusters ) !======================================================================================== !! Accessor to cluster results obtained using a two-level self_organized_map class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer , dimension (:), intent ( inout ) :: clusters !! An integer array write ( * , * ) 'size_cluster= ' , size ( clusters ) if ( size ( clusters ) . eq . size ( kohonen_map % cluster_samples )) then clusters = kohonen_map % cluster_samples ; endif ! end subroutine get_cluster_samples !======================================================================================== function position2index ( ix , iy , iz , nx , ny ) result ( index_ ) !======================================================================================== !!   Function to calculate the index inside a rectangular grid from position ix,iy,iz integer , intent ( in ) :: ix , iy , iz , nx , ny !! Integer variables ix,iy,iz,nx,ny integer :: index_ !! Integer variable with the index !***** index_ = ix + ( iy - 1 ) * nx + ( iz - 1 ) * nx * ny ! end function position2index !======================================================================================== subroutine index2position ( index_ , nx , ny , nz , cx , cy , cz ) !======================================================================================== !!  Subroutine to calculate the position ix,iy,iz inside a rectangular grid from index integer , intent ( in ) :: index_ , nx , ny , nz !! Integer variables, index_,nx,ny,nz integer , intent ( inout ) :: cx , cy , cz !! Integer variables cx,cy,cz !  write(*,*) index_,nx,ny,1+int((index_-1)/(nx*ny)) cz = min ( 1 + int (( index_ - 1 ) / ( nx * ny )), nz ); cy = min ( 1 + int (( index_ - 1 - ( cz - 1 ) * nx * ny ) / nx ), ny ); cx = min ( index_ - ( cz - 1 ) * nx * ny - ( cy - 1 ) * nx , nx ); ! end subroutine index2position !======================================================================================== subroutine calculate_distance_matrix ( coordinates , distance_matrix , grid_type , toroidal ) !======================================================================================== !! Subroutine to calculate the distance between the units inside a kohonen layer real ( kind = wp ), dimension (:,:), intent ( inout ) :: coordinates !! A real array real ( kind = wp ), dimension (:,:), intent ( inout ) :: distance_matrix !! A real array character ( len =* ) :: grid_type !! A character varaible logical :: toroidal !! A logical variableS integer :: i , j real ( kind = wp ) :: maxdiffx , maxdiffy , maxdiffz real ( kind = wp ), dimension ( 3 ) :: diffs ! maxdiffx = maxval ( coordinates (:, 1 )) / 2.0_wp ; maxdiffy = maxval ( coordinates (:, 2 )) / 2.0_wp ; maxdiffz = maxval ( coordinates (:, 3 )) / 2.0_wp ; ! if ( toroidal ) then do i = 1 , size ( distance_matrix , 1 ) do j = i + 1 , size ( distance_matrix , 2 ) diffs = abs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); if ( diffs ( 1 ) > maxdiffx ) diffs ( 1 ) = 2.0_wp * maxdiffx - diffs ( 1 ); if ( diffs ( 2 ) > maxdiffy ) diffs ( 2 ) = 2.0_wp * maxdiffy - diffs ( 2 ); !if (diffs(3) > maxdiffy) diffs(3)=2*maxdiffz - diffs(3); if ( trim ( grid_type ) . eq . \"hexagonal\" ) then distance_matrix ( i , j ) = sum ( diffs ** 2 ); elseif ( trim ( grid_type ) . eq . \"rectangular\" ) then !rectangular distance_matrix ( i , j ) = maxval ( diffs ); endif enddo enddo else do i = 1 , size ( distance_matrix , 1 ) do j = i + 1 , size ( distance_matrix , 2 ) diffs = abs ( coordinates ( j , 1 : 3 ) - coordinates ( i , 1 : 3 )); distance_matrix ( i , j ) = dsqrt ( sum ( diffs ** 2 )); enddo enddo endif ! distance_matrix = distance_matrix + transpose ( distance_matrix ); !write(*,'(49f10.4)') distance_matrix(1,:) ! end subroutine calculate_distance_matrix !======================================================================================== subroutine calculate_coordinates ( current_index , ix , iy , iz , nx , ny , nz , coordinates , node_type ) !======================================================================================== !! Subroutine to calculate the coordinates of the units inside a kohonen layer integer , intent ( in ) :: current_index , ix , iy , iz , nx , ny , nz !! Integer variables real ( kind = wp ), dimension (:,:), intent ( out ) :: coordinates !! Real array character ( len =* ), intent ( in ) :: node_type !! Character variable coordinates ( current_index , 1 ) = dble ( ix ); coordinates ( current_index , 2 ) = dble ( iy ); coordinates ( current_index , 3 ) = dble ( iz ); if ( trim ( node_type ) . eq . 'hexagonal' ) then coordinates ( current_index , 1 ) = coordinates ( current_index , 1 ) + & . 5_wp * ( mod ( coordinates ( current_index , 2 ), 2.0_wp )); coordinates ( current_index , 2 ) = ( dsqrt ( 3.0_wp ) / 2._wp ) * coordinates ( current_index , 2 ); endif ! end subroutine calculate_coordinates !======================================================================================== subroutine find_best_match_unit ( kohonen_map , current_prototype , ihit , jhit , khit , dist_hit ) !======================================================================================== !!    Subroutine to calculate the best match unit class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_prototype ), intent ( inout ) :: current_prototype !! A `kohonen_prototype` object integer , intent ( out ) :: ihit , jhit , khit !! Integer variables real ( kind = wp ), intent ( out ) :: dist_hit !! A real variable integer :: debug_option , idbg , ix , iy , iz , number_variables real ( kind = wp ) :: dist ! idbg = kohonen_map % parameters ( 1 )% idbg ; debug_option = kohonen_map % parameters ( 1 )% debug_level ; number_variables = kohonen_map % parameters ( 1 )% number_variables1 * kohonen_map % parameters ( 1 )% number_variables2 ihit = 0 ; jhit = 0 ; khit = 0 ; dist_hit = 1.0e6 ; do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ) do ix = 1 , size ( kohonen_map % grid , 1 ) dist = 0.0_wp ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( current_prototype , kohonen_map % distance_function ); if ( debug_option . gt . 0 ) then call kohonen_map % grid ( ix , iy , iz )% print ( idbg ) write ( idbg , * ) ix , iy , iz , dist endif dist = dist / float ( number_variables ); if ( dist . lt . dist_hit ) then dist_hit = dist ihit = ix jhit = iy khit = iz !write(*,*)' fbmu= ',ihit,jhit,khit,dist endif enddo !ix enddo !iy enddo !iz ! return ! end subroutine find_best_match_unit !======================================================================================== subroutine update_weights ( kohonen_map , current_values , ihit , jhit , khit ,& maximum_radius , iteration ) !======================================================================================== !!    Subroutine to update the weights class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object real ( kind = wp ), dimension (:,:), intent ( inout ) :: current_values !! A real array integer , intent ( inout ) :: ihit , jhit , khit , iteration !! Integer variables real ( kind = wp ), intent ( inout ) :: maximum_radius !! A real variable with the maximum radius real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: prototype_values real ( kind = wp ), dimension ( size ( current_values , 1 ), size ( current_values , 2 )) :: winner_values , term1 , term2 integer :: nx , ny , nz , debug_option , ic , current_pos , ineigh , jneigh , kneigh , idbg real ( kind = wp ) :: time_factor , current_radius , alpha , sigma2 , h_neighborhood , real_distance , term3 real ( kind = wp ) :: distance_ratio , geometric_distance2 , eps , current_distance , lambda ! nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; debug_option = kohonen_map % parameters ( 1 )% debug_level ; idbg = kohonen_map % parameters ( 1 )% idbg ; lambda = 2.0_wp * ( 1.0_wp / maximum_radius ); time_factor = 1.0_wp - dble ( iteration ) / & dble ( kohonen_map % parameters ( 1 )% number_epochs * kohonen_map % parameters ( 1 )% number_patterns ); !current_radius = max(maximum_radius*real(1001-iteration)/1000.0 + 0.9999999999,4.0_wp); current_radius = max ( maximum_radius * time_factor , 4.0_wp ); !alpha = max(kohonen_map%parameters%learning_rate*(1.0_wp-real(iteration)/1000.0),0.01_wp); alpha = max ( kohonen_map % parameters ( 1 )% learning_rate * time_factor , 0.01_wp ); sigma2 = current_radius ** 2 ! do ic = 1 , size ( kohonen_map % coordinates , 1 ) current_pos = position2index ( ihit , jhit , khit , nx , ny ); current_distance = kohonen_map % cells_distances ( current_pos , ic ) if ( current_distance . lt . current_radius ) then geometric_distance2 = current_distance ** 2 ; call index2position ( ic , nx , ny , nz , ineigh , jneigh , kneigh ); !write(*,*) ic,ineigh,jneigh,kneigh,ihit,jhit,khit select case ( trim ( kohonen_map % parameters ( 1 )% neighborhood_type )) case ( 'gaussian' ) h_neighborhood = alpha * exp ( - 0.5 * geometric_distance2 / sigma2 ); case ( 'bubble' ) h_neighborhood = alpha ; end select if ( debug_option . gt . 0 ) then write ( idbg , * ) ihit , jhit , khit , ineigh , jneigh , kneigh endif select case ( trim ( kohonen_map % parameters ( 1 )% som_type )) case ( 'normal_som' ) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ) case ( 'visom' ) !write(*,*) trim(kohonen_map%parameters%som_type) call kohonen_map % grid ( ineigh , jneigh , kneigh )% get_prototype ( prototype_values ); call kohonen_map % grid ( ihit , jhit , khit )% get_prototype ( winner_values ); real_distance = sum (( winner_values - prototype_values ) ** 2 ); if ( ( ineigh . eq . ihit ) . and . ( jneigh . eq . jhit ) . and . ( kneigh . eq . khit ) ) then prototype_values = prototype_values + h_neighborhood * ( current_values - prototype_values ); else distance_ratio = dsqrt ( real_distance ) / ( dsqrt ( geometric_distance2 ) * lambda ); term1 = ( current_values - winner_values ); term2 = ( winner_values - prototype_values ); eps = max ( 1.0_wp * time_factor , 0.0_wp ); term3 = 1.0_wp ; !((1.0_wp-eps)+eps) prototype_values = prototype_values + h_neighborhood * ( term1 + term2 * ( distance_ratio - 1.0_wp ) * term3 ); endif !write(*,*) iteration,dsqrt(real_distance),dsqrt(geometric_distance2)*lambda,distance_ratio call kohonen_map % grid ( ineigh , jneigh , kneigh )% set_prototype ( prototype_values ); end select endif enddo !ic end subroutine update_weights !======================================================================================== subroutine calculate_distance_between_prototypes ( kohonen_map ) !======================================================================================== !!    Subroutine to calculate distance between prototypes class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object integer :: nx , ny , ix , iy , iz , ix1 , iy1 , iz1 , pos , pos1 type ( kohonen_prototype ) :: current_prototype , current_prototype1 logical :: testop !! A logical variable nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; do iz = 1 , size ( kohonen_map % grid , 3 ) do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); current_prototype = kohonen_map % grid ( ix , iy , iz ); pos = position2index ( ix , iy , iz , nx , ny ); do iz1 = 1 , size ( kohonen_map % grid , 3 ); do iy1 = 1 , size ( kohonen_map % grid , 2 ); do ix1 = 1 , size ( kohonen_map % grid , 1 ); pos1 = position2index ( ix1 , iy1 , iz1 , nx , ny ) current_prototype1 = kohonen_map % grid ( ix1 , iy1 , iz1 ); kohonen_map % distance ( pos , pos1 ) = current_prototype1 % distance ( current_prototype ,& kohonen_map % distance_function ); enddo !ix1 enddo !iy1 enddo !iz1 enddo !ix enddo !iy enddo !iz ! do ix = 1 , size ( kohonen_map % distance , 1 ) write ( kohonen_map % parameters ( 1 )% idist , * ) ( kohonen_map % distance ( ix , iy ), iy = 1 , size ( kohonen_map % distance , 2 )); enddo !ix ! end subroutine calculate_distance_between_prototypes !======================================================================================== subroutine calculate_u_matrix ( kohonen_map ) !======================================================================================== !!    Subroutine to calculate  the u_matrix class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object character ( len = 50 ) :: type_ integer :: nx , ny , nz , nt , ierr , ix , iy , iz , cx , cy , cz , nxu , nyu , nzu real ( kind = wp ) :: dist , u_temp logical :: testop ! type_ = kohonen_map % parameters ( 1 )% node_type ; nx = kohonen_map % parameters ( 1 )% number_nodes_nx ; ny = kohonen_map % parameters ( 1 )% number_nodes_ny ; nz = kohonen_map % parameters ( 1 )% number_nodes_nz ; ! nxu = size ( kohonen_map % u_matrix , 1 ); nyu = size ( kohonen_map % u_matrix , 2 ); nzu = size ( kohonen_map % u_matrix , 3 ); ! select case ( trim ( type_ )) ! case ( 'rectangular' ) ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); ! horizontal if ( ix < nx ) then cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif !vertical if ( iy < ny ) then cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; endif ! if ( iz < nz ) then cx = ix ; cy = iy ; cz = iz + 1 ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! Diagonal if ( ix < nx . and . iy < ny ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = dist + kohonen_map % grid ( ix , cy , iz )% distance ( kohonen_map % grid ( cx , iy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; endif enddo enddo enddo ! do iz = 1 , size ( kohonen_map % u_matrix , 3 ), 2 do iy = 1 , size ( kohonen_map % u_matrix , 2 ), 2 do ix = 1 , size ( kohonen_map % u_matrix , 1 ), 2 u_temp = 0.0_wp ; if ( ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 ) . and . & iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == 1 . and . ix > 1 . and . ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( iy == size ( kohonen_map % u_matrix , 2 ) . and . ix > 1 . and .& ix < size ( kohonen_map % u_matrix , 1 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy > 1 . and . iy < size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + & kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == 1 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == 1 . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; elseif ( ix == size ( kohonen_map % u_matrix , 1 ) . and . iy == size ( kohonen_map % u_matrix , 2 )) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = 0.0_wp ; endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! case ( 'hexagonal' ) ! do iz = 1 , size ( kohonen_map % grid , 3 ); do iy = 1 , size ( kohonen_map % grid , 2 ); do ix = 1 , size ( kohonen_map % grid , 1 ); if ( ix < nx ) then !horizontal cx = ix + 1 ; cy = iy ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy - 1 , 2 * iz - 1 ) = dist ; endif ! if ( iy < ny ) then !diagonals cx = ix ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 1 , 2 * iy , 2 * iz - 1 ) = dist ; if ( mod ( iy , 2 ) == 0 . and . ix < nx ) then cx = ix + 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix , 2 * iy , 2 * iz - 1 ) = dist ; elseif ( mod ( iy , 2 ) == 1 . and . ix > 1 ) then cx = ix - 1 ; cy = iy + 1 ; cz = iz ; dist = kohonen_map % grid ( ix , iy , iz )% distance ( kohonen_map % grid ( cx , cy , cz ),& kohonen_map % distance_function ); kohonen_map % u_matrix ( 2 * ix - 2 , 2 * iy , 2 * iz - 1 ) = dist ; endif endif enddo enddo enddo ! do iz = 1 , nzu , 2 ; do iy = 1 , nyu , 2 ; do ix = 1 , nxu , 2 ; u_temp = 0.0_wp ; if ( ix > 1 . and . iy > 1 . and . ix < nxu . and . iy < nyu ) then !middle part of the map u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); endif nt = 6 ; elseif ( iy == 1 . and . ix > 1 . and . ix < nxu ) then ! upper edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 4 ; elseif ( iy == nyu . and . ix > 1 . and . ix < nxu ) then ! lower edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); endif nt = 4 ; elseif ( ix == 1 . and . iy > 1 . and . iy < nyu ) then ! left edge u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix + 1 , iy + 1 , iz ); nt = 5 ; endif elseif ( ix == nxu . and . iy > 1 . and . iy < nyu ) then ! right edge u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ); if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ); nt = 5 ; else u_temp = u_temp + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; endif elseif ( ix == 1 . and . iy == 1 ) then ! top left corner u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 2 ; elseif ( ix == nxu . and . iy == 1 ) then ! top right corner u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix - 1 , iy + 1 , iz ) + & kohonen_map % u_matrix ( ix , iy + 1 , iz ); nt = 3 ; elseif ( ix == 1 . and . iy == nyu ) then ! bottom left corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; else u_temp = kohonen_map % u_matrix ( ix + 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix + 1 , iy - 1 , iz ); nt = 3 ; endif ; elseif ( ix == nxu . and . iy == nyu ) then ! bottom right corner if ( mod ( iy - 1 , 4 ) == 0 ) then u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ) + & kohonen_map % u_matrix ( ix - 1 , iy - 1 , iz ); nt = 3 ; else u_temp = kohonen_map % u_matrix ( ix - 1 , iy , iz ) + kohonen_map % u_matrix ( ix , iy - 1 , iz ); nt = 2 ; endif endif kohonen_map % u_matrix ( ix , iy , iz ) = u_temp / dble ( nt ); enddo enddo enddo ! end select ! inquire ( unit = kohonen_map % parameters ( 1 )% iumat , opened = testop ); if ( testop ) then do iz = 1 , size ( kohonen_map % u_matrix , 3 ); write ( kohonen_map % parameters ( 1 )% iumat , '(A,I4)' ) 'Layer ' , iz do ix = 1 , size ( kohonen_map % u_matrix , 1 ); write ( kohonen_map % parameters ( 1 )% iumat , '(100f10.5)' ) ( kohonen_map % u_matrix ( ix , iy , iz ),& iy = 1 , size ( kohonen_map % u_matrix , 2 )); enddo enddo endif ! end subroutine calculate_u_matrix !======================================================================================== subroutine assign_input_to_clusters ( kohonen_map , input_patterns ) !======================================================================================== !!    Subroutine to assign input to clusters class ( two_level_self_organizing_map ) :: kohonen_map !! A `two_level_self_organizing_map` object type ( kohonen_pattern ), dimension (:), intent ( inout ) :: input_patterns !! A `kohonen_pattern` array type ( kohonen_prototype ) :: current_prototype , current_prototype1 integer :: ipattern , ic , i_hit , current_pos real ( kind = wp ) :: dist_min , dist ! ! write(*,*) 'assign= ',size(input_patterns) do ipattern = 1 , kohonen_map % parameters ( 1 )% number_patterns call input_patterns ( ipattern )% get ( current_prototype ); !    write(*,*) 'ipat= ',ipattern dist_min = 1.0d5 ; do ic = 1 , size ( kohonen_map % cluster_layer ) current_prototype1 = kohonen_map % cluster_layer ( ic ) dist = current_prototype1 % distance ( current_prototype , kohonen_map % distance_function ); if ( dist < dist_min ) then i_hit = ic ; dist_min = dist ; !         write(*,*) 'ic= ',ipattern,i_hit endif enddo kohonen_map % number_cluster_samples ( i_hit ) = kohonen_map % number_cluster_samples ( i_hit ) + 1 ; current_pos = kohonen_map % number_cluster_samples ( i_hit ); !    write(*,*)' ic,pos= ',ic,i_hit,current_pos,allocated(kohonen_map%number_cluster_samples),& !                         size(kohonen_map%number_cluster_samples) !    write(*,*) kohonen_map%number_cluster_samples kohonen_map % index_cluster_samples ( i_hit , current_pos ) = ipattern ; enddo !ipattern1 ! !  do ic=1,size(kohonen_map%cluster_layer) !     write(*,*) ic,kohonen_map%number_cluster_samples(ic),(kohonen_map%index_cluster_samples(ic,1:5)) !  enddo ! end subroutine assign_input_to_clusters !======================================================================================== subroutine external_train_map ( x , nvar , npat , som_type , nx1 , ny1 , nepoch1 , alpha1 , grid_type1 ,& distance_type1 , neigh_type1 , toroidal1 , nx2 , nepoch2 , alpha2 , grid_type2 ,& prot , distortion , u_matrix , coords , number_patterns ,& node_index ) bind ( C , name = \"train_2lsom\" ) !======================================================================================== !!    Subroutine to connect the two_level_self_organizing_map module to R o C use , intrinsic :: iso_c_binding , only : c_double , c_int , c_char !! Use iso_c_binding module real ( kind = wp ), parameter :: version = 0.1_wp !! Subroutine Version character ( len =* ), parameter :: program_name = \"2lsom_train\" !! Subroutine name integer ( c_int ), intent ( in ) :: nvar , npat , som_type , nx1 , ny1 , nepoch1 , toroidal1 !! Integere variables real ( c_double ), intent ( out ) :: prot ( nx1 * ny1 , nvar ), distortion ( nepoch1 ) !! Real variables real ( c_double ), intent ( out ) :: u_matrix ( 2 * nx1 - 1 , 2 * ny1 - 1 ), coords ( nx1 * ny1 , 3 ) !! Real variables integer ( c_int ), intent ( out ) :: number_patterns ( nx1 , ny1 ), node_index ( npat , 3 ) !! Integer variables real ( c_double ), intent ( in ) :: x ( npat , nvar ) !! Real variables real ( c_double ), intent ( in ) :: alpha1 , alpha2 !! Real variables integer ( c_int ), intent ( in ) :: grid_type1 , distance_type1 , neigh_type1 !! Integer variables integer ( c_int ), intent ( in ) :: nx2 , grid_type2 , nepoch2 !,distance_type1,neigh_type2 !! Integer variables type ( two_level_self_organizing_map ) :: my_som type ( kohonen_layer_parameters ), dimension ( 1 ) :: parameters real ( kind = wp ), dimension ( nvar , 1 ) :: var integer :: i , j , k , ierr , pos , ihit , jhit , khit , nx1a , ny1a type ( kohonen_pattern ), allocatable :: input_patterns (:) real ( kind = wp ), dimension ( nx1 * ny1 , nvar ) :: prototypes real ( kind = wp ), dimension ( nvar , 1 ) :: temp ! parameters ( 1 )% train_option = 3 ; parameters ( 1 )% number_nodes_nx = nx1 ; parameters ( 1 )% number_nodes_ny = ny1 ; parameters ( 1 )% number_nodes_nz = 1 ; parameters ( 1 )% number_variables1 = nvar ; parameters ( 1 )% number_variables2 = 1 ; parameters ( 1 )% number_variables = nvar ; parameters ( 1 )% number_patterns = npat ; parameters ( 1 )% number_epochs = nepoch1 ; parameters ( 1 )% learning_rate = alpha1 ; parameters ( 1 )% random_seed_ = 12345 ; ! select case ( grid_type1 ) case ( 0 ) parameters ( 1 )% node_type = \"rectangular\" ; case ( 1 ) parameters ( 1 )% node_type = \"hexagonal\" ; end select ! parameters ( 1 )% debug_level = 0 ; parameters ( 1 )% debug_file = \"NOFILE\" ; parameters ( 1 )% pattern_file = \"NOFILE\" ; parameters ( 1 )% output_file = \"NOFILE\" ; parameters ( 1 )% distance_type = \"euclidean\" ; !\"euclidean\" !euclidean, manhattan, correlation, correlation2 ! select case ( neigh_type1 ) case ( 0 ) parameters ( 1 )% neighborhood_type = \"bubble\" ; case ( 1 ) parameters ( 1 )% neighborhood_type = \"gaussian\" ; end select ! select case ( som_type ) case ( 0 ) parameters ( 1 )% som_type = \"normal_som\" ; !,visom, robust_som case ( 1 ) parameters ( 1 )% som_type = \"visom\" ; case ( 2 ) parameters ( 1 )% som_type = \"robust_som\" ; end select ! if ( toroidal1 == 1 ) then parameters ( 1 )% toroidal_grid = . TRUE .; else parameters ( 1 )% toroidal_grid = . FALSE .; endif ! end subroutine external_train_map ! end module two_level_self_organizing_map_utilities","tags":"","loc":"sourcefile\\two_level_self_organizing_map_utilities.f90.html"},{"title":"constants_utilities.f90 – KohonenF08","text":"This module defines several numerical constants used in the ATALIB library. These constants \ncan be imported in any module of the library. This module is in constant evolution and new \nconstants are being added to the library. This file depends on sourcefile~~constants_utilities.f90~~EfferentGraph sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~precision_utilities.f90 precision_utilities.f90 sourcefile~constants_utilities.f90->sourcefile~precision_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~constants_utilities.f90~~AfferentGraph sourcefile~constants_utilities.f90 constants_utilities.f90 sourcefile~dataframe_utilities.f90 dataframe_utilities.f90 sourcefile~dataframe_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90 kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_layer_parameters_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90 kohonen_layer_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_pattern_utilities.f90 kohonen_pattern_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~kohonen_prototype_utilities.f90 kohonen_prototype_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_map_base_utilities.f90 kohonen_map_base_utilities.f90 sourcefile~kohonen_layer_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~kohonen_pattern_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~kohonen_prototype_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~logger_utilities.f90 logger_utilities.f90 sourcefile~logger_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90 self_organizing_map_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~constants_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_predict_variables.f90 som_predict_variables.f90 sourcefile~som_predict_variables.f90->sourcefile~constants_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_predict_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~som_train_variables.f90 som_train_variables.f90 sourcefile~som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~logger_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~self_organizing_map_utilities.f90 sourcefile~som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_estimate_variables.f90 two_level_som_estimate_variables.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~constants_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90 two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_estimate_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~two_level_som_train_variables.f90 two_level_som_train_variables.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~constants_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~kohonen_map_base_utilities.f90 sourcefile~two_level_som_train_variables.f90->sourcefile~two_level_self_organizing_map_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~kohonen_map_base_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_layer_parameters_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_pattern_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_prototype_utilities.f90 sourcefile~two_level_self_organizing_map_utilities.f90->sourcefile~kohonen_map_base_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! author: Oscar Garcia-Cabrejo !! date: 01/24/2020 !! version: 0.1 !! This module defines several numerical constants used in the ATALIB library. These constants !! can be imported in any module of the library. This module is in constant evolution and new !! constants are being added to the library. module constants_utilities ! use precision_utilities , only : wp , EP ; ! implicit none ; ! public ; ! real ( wp ), parameter :: PI = 4.0_wp * atan ( 1.0_wp ); real ( wp ), parameter :: LN2 = log ( 2.0_wp ); ! real ( wp ), parameter :: PIEP = 4.0_EP * atan ( 1.0_EP ) real ( wp ), parameter :: INVPIEP = 0.25_EP / atan ( 1.0_EP ) real ( wp ), parameter :: TWOPIEP = 8.0_EP * atan ( 1.0_EP ) real ( wp ), parameter :: PIOV2EP = 2.0_EP * atan ( 1.0_EP ) real ( EP ), parameter :: PIOV4EP = atan ( 1.0_EP ) complex ( wp ), parameter :: EYE = ( 0.0_wp , 1.0_wp ) complex ( wp ), parameter :: I_ = ( 0.0_wp , 1.0_wp ) real ( wp ), parameter :: E = exp ( 1.0_EP ) real ( wp ), parameter :: SQRT2 = sqrt ( 2.0_EP ) real ( wp ), parameter :: UNEST =- 99 9.999999_EP real ( wp ), parameter :: EPSILON = 1.0d-10 real ( wp ), parameter :: TOLERANCE = 1.0d-6 real ( wp ), parameter :: DEG2RAD = PI / 18 0.0_wp ! ! length of filenames ! integer , parameter :: NUMCHAR = 128 ; integer , parameter :: MAXNST = 10 ; end module constants_utilities","tags":"","loc":"sourcefile\\constants_utilities.f90.html"},{"title":"kohonen_layer_base_utilities.f90 – KohonenF08","text":"This module defines an abstract class that represents a layer in a self-organizing map Source Code !! author: Oscar Garcia-Cabrejo !! date: 03/05/2025 !! version: 0.1 !! This module defines an abstract class that represents a layer in a self-organizing map module kohonen_layer_base_utilities end module kohonen_layer_base_utilities","tags":"","loc":"sourcefile\\kohonen_layer_base_utilities.f90.html"}]}